<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ratix - Strategic Chess Variant</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #202020;
            margin: 0;
            padding: 20px;
        }
        #game-container {
            display: none;
            flex-direction: column;
            align-items: stretch;
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }
        #start-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #fff;
            padding: 20px;
            border: 2px solid #333;
            border-radius: 10px;
        }
        #start-menu h2 {
            margin-bottom: 20px;
        }
        #start-menu button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 5px;
            cursor: pointer;
        }
        /* Style for the selected difficulty button */
        #start-menu button.selected-diff {
            background-color: #4CAF50;
            color: white;
            border: 2px solid #4CAF50;
        }
        #start-menu button.selected-option {
            background-color: #4CAF50;
            color: white;
            border: 2px solid #4CAF50;
        }
        #start-menu button.selected-opponent {
            background-color: #4CAF50;
            color: white;
            border: 2px solid #4CAF50;
        }
        #start-menu button.selected-hint {
            background-color: #4CAF50;
            color: white;
            border: 2px solid #4CAF50;
        }
        .variant-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 15px;
            max-width: 300px;
            text-align: center;
        }
        .variant-option button.selected-variant {
            background-color: #4CAF50;
            color: #fff;
            border: 2px solid #4CAF50;
        }
        .variant-description {
            margin-top: 6px;
            font-size: 13px;
            line-height: 1.4;
            color: #333;
        }
        .variant-info {
            display: none;
            width: 100%;
            margin-top: 6px;
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: #f7f7f7;
            text-align: left;
        }
        .variant-info.visible {
            display: block;
            background-color: #f0f0f0;
        }
        .variant-difficulty {
            margin-top: 6px;
            font-size: 13px;
            color: #555;
        }
        #landing-header {
            text-align: center;
            color: #fff;
            margin-bottom: 20px;
        }
        #landing-header h1 {
            margin: 0;
            font-size: 48px;
            letter-spacing: 1px;
        }
        #landing-header p {
            margin: 6px 0 18px;
            font-size: 16px;
            color: #cccccc;
        }
        #landing-header .how-to-button {
            margin-bottom: 10px;
        }
        #landing-footer {
            margin-top: 20px;
            color: #cccccc;
            font-size: 14px;
            text-align: center;
        }
        #difficulty-selector {
            margin-top: 20px;
            border-top: 1px solid #ccc;
            padding-top: 15px;
            text-align: center;
        }
        #opponent-selector {
            margin-top: 20px;
            border-top: 1px solid #ccc;
            padding-top: 15px;
            text-align: center;
        }
        #opponent-selector button {
            width: calc(33.33% - 10px);
            margin: 5px;
            display: inline-block;
        }
        #hint-selector {
            margin-top: 20px;
            border-top: 1px solid #ccc;
            padding-top: 15px;
            text-align: center;
        }
        #game-timer-selector, #turn-timer-selector {
            margin-top: 20px;
            border-top: 1px solid #ccc;
            padding-top: 15px;
            text-align: center;
        }
        #board {
            display: grid;
            border: 2px solid #000000;
            background-color: #fff;
            margin: 0 auto;
        }
        .square {
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            cursor: pointer;
            position: relative;
            transition: background-color 0.5s ease-in-out; /* Smooth transition for background color */
        }
        .piece {
            font-family: Arial, sans-serif;
            font-weight: bold;
            font-size: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            background-color: rgb(0, 0, 0);
            border-radius: 50%;
            line-height: 1;
        }
        .piece.white {
            background-color: rgb(255, 255, 255);
        }
        .piece.black {
            background-color: rgb(0, 0, 0);
        }
        .light { background-color: #999999; }
        .dark { background-color: #363535; }
        .ai-move-highlight { background-color: #ffcc00 !important; }
        .selected { background-color: #ffcc00 !important; }
        .valid-move { background-color: #ffff99 !important; }
        .valid-capture { background-color: #ff2020 !important; }
        .valid-shoot { background-color: #ff2020 !important; }
        .valid-swap { background-color: #99ff99 !important; }
        .hint-highlight {
            background-color: transparent !important;
            box-shadow: 0 0 16px rgba(0, 255, 255, 0.9) !important;
            animation: pulse-hint 1.2s ease-in-out infinite;
            position: relative;
            z-index: 2;
            opacity: 1 !important;
        }
        #coin-toss-progress {
            display: none;
            color: #000000 !important;
            font-weight: bold;
            margin-left: 12px;
            text-shadow: none;
        }
        @keyframes pulse-hint {
            0%, 100% {
                box-shadow: 0 0 16px rgba(0, 255, 255, 0.95);
            }
            50% {
                box-shadow: 0 0 28px rgba(0, 255, 255, 0.25);
            }
        }
        .energy-blast-path,
        .energy-blast-residual {
            background-color: transparent !important;
            box-shadow: 0 0 16px rgba(0, 255, 255, 0.9) !important;
            animation: pulse-hint 1.2s ease-in-out infinite;
            position: relative;
            z-index: 2;
            opacity: 1 !important;
        }
        .piece-arrow {
            font-size: 12px;
            position: absolute;
            bottom: 0px;
            right: 0px;
        }
        #status {
            width: 100%;
            padding: 15px;
            background-color: #fff;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            color: #000;
            box-sizing: border-box;
        }
        #score-display {
            width: 100%;
            max-width: 960px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: stretch;
            gap: 20px;
            color: #fff;
            margin: 10px auto 0;
        }
        .player-panel,
        .round-panel {
            background-color: #2a2a2a;
            border: 1px solid #333;
            border-radius: 10px;
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 220px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
            color: #fff;
        }
        .player-panel {
            flex: 1 1 280px;
            max-width: 340px;
            text-align: left;
        }
        .round-panel {
            flex: 0 0 220px;
            align-items: center;
            text-align: center;
            justify-content: center;
        }
        .player-name {
            font-size: 14px;
            font-weight: 700;
        }
        .player-score,
        #round-number-display {
            font-size: 14px;
            font-weight: 600;
        }
        #round-number-display {
            font-weight: 700;
        }
        .timer-row {
            font-size: 14px;
            margin: 0;
        }
        .timer-row.player {
            text-align: left;
        }
        .timer-row.game {
            text-align: center;
        }
        .timer-row.ai {
            text-align: right;
        }
        .timer-row.low-time {
            color: #FFD700;
            font-weight: bold;
        }
        #info-box {
            width: 100%;
            padding: 15px;
            background-color: #fff;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            text-align: left;
            display: none;
            box-sizing: border-box;
            overflow-y: auto;
            max-height: var(--board-panel-max-height, 400px);
        }
        #game-log {
            width: 100%;
            height: 180px;
            padding: 15px;
            background-color: #fff;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            overflow-y: auto;
            text-align: left;
            box-sizing: border-box;
        }
        #captured-pieces {
            width: 100%;
            padding: 15px;
            background-color: #fff;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            text-align: left;
            box-sizing: border-box;
            overflow-y: auto;
            max-height: var(--board-panel-max-height, 400px);
            display: flex;
            gap: 15px;
        }
        #captured-pieces h3 {
            font-size: 14px;
            font-weight: normal;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .captured-column {
            flex: 1 1 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .captured-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px;
        }
        .captured-entry {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-weight: 600;
            background-color: #f7f7f7;
            border-radius: 4px;
            padding: 6px;
        }
        .captured-entry.empty {
            font-weight: 500;
            color: #777;
        }
        .captured-entry .piece {
            width: 30px;
            height: 30px;
            font-size: 20px;
            flex: 0 0 30px;
        }
        #game-layout {
            display: grid;
            grid-template-columns: minmax(220px, 260px) minmax(520px, auto) minmax(220px, 260px);
            gap: 20px;
            width: 100%;
            justify-content: center;
            align-items: flex-start;
            margin-top: 20px;
        }
        #board-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        #left-panel,
        #right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        #left-controls,
        #right-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #left-controls button,
        #right-controls button {
            width: 100%;
        }
        @media (max-width: 1024px) {
            #score-display {
                flex-direction: column;
                align-items: stretch;
            }
            .player-panel,
            .round-panel {
                flex: 1 1 auto;
                max-width: none;
            }
            #game-layout {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            #left-panel,
            #right-panel,
            #board-column {
                width: 100%;
                max-width: 520px;
            }
            #left-controls,
            #right-controls {
                flex-direction: row;
                flex-wrap: wrap;
            }
            #left-controls button,
            #right-controls button {
                width: auto;
                flex: 1 1 150px;
            }
        }
        #reinforce-modal, #turn-modal, #turn-move-modal, #turn-shoot-modal, #truce-modal, #coin-toss-modal, #king-summon-modal, #spell-direction-modal, #protection-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 20px;
            border: 2px solid #333;
            border-radius: 10px;
            z-index: 1000;
        }
        #truce-modal {
            z-index: 2001;
            max-width: 500px;
            text-align: center;
        }
        #truce-modal .modal-content p {
            margin: 15px 0;
            font-size: 16px;
        }
        #truce-modal .modal-footer button {
            margin: 10px;
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            color: white;
        }
        #truce-modal .modal-footer button:hover {
            opacity: 0.9;
        }
        #coin-toss-modal {
            z-index: 2002;
            max-width: 400px;
            text-align: center;
        }
        #coin-toss-modal .coin {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            margin: 20px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            border: 5px solid #333;
            background-color: #666;
            color: white;
            transition: all 0.3s ease;
        }
        #coin-toss-modal .coin.spinning {
            animation: flipCoin 2s ease-in-out;
        }
        #coin-toss-modal .coin.white {
            background-color: white;
            color: black;
        }
        #coin-toss-modal .coin.black {
            background-color: black;
            color: white;
        }
        @keyframes flipCoin {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(3600deg); }
        }
        #coin-toss-modal .modal-content p {
            margin: 15px 0;
            font-size: 18px;
            font-weight: bold;
        }
        #reinforce-modal select, #reinforce-modal button, #turn-modal select, #turn-modal button, #turn-move-modal select, #turn-move-modal button, #turn-shoot-modal select, #turn-shoot-modal button, #king-summon-modal select, #king-summon-modal button {
            margin: 10px;
            padding: 5px;
            font-size: 14px;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .modal-close {
            background: none;
            border: none;
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
        }
        .modal-close:hover {
            color: #c00;
        }
        #modal-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 0;
            background-color: rgba(50, 50, 50, 0.8);
            z-index: 2001;
        }
        #endgame-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #202020;
            z-index: 2003;
        }
        #how-to-play-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 0;
            border: 2px solid #333;
            border-radius: 10px;
            z-index: 2000;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow: hidden;
        }
        #how-to-play-modal .modal-header {
            background-color: #333;
            color: #fff;
            padding: 15px 20px;
            margin: 0;
            border-radius: 8px 8px 0 0;
        }
        #how-to-play-modal .modal-header .modal-close {
            color: #fff;
            font-size: 24px;
        }
        #how-to-play-modal .modal-content {
            padding: 20px;
            max-height: calc(80vh - 120px);
            overflow-y: auto;
        }
        #how-to-play-modal .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid #ddd;
            text-align: center;
        }
        #how-to-play-modal .modal-footer button {
            padding: 10px 30px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #how-to-play-modal .modal-footer button:hover {
            background-color: #45a049;
        }
        #rules-content h2 {
            color: #333;
            border-bottom: 2px solid #333;
            padding-bottom: 5px;
            margin-top: 20px;
        }
        #rules-content h3 {
            color: #555;
            margin-top: 15px;
        }
        #rules-content .piece-info {
            background-color: #f5f5f5;
            padding: 10px;
            margin: 10px 0;
            border-left: 4px solid #333;
            border-radius: 3px;
        }
        #rules-content .piece-name {
            font-weight: bold;
            color: #333;
            font-size: 16px;
        }
        #rules-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        #rules-content li {
            margin: 5px 0;
        }
        #controls {
            margin-top: 0;
            display: inline-flex;
            gap: 10px;
            flex-wrap: nowrap;
            justify-content: center;
            width: auto;
            min-width: max-content;
            overflow: visible;
        }
        #controls button {
            flex: 0 0 auto;
        }
        #board.low-time {
            border-color: #FFD700 !important;
            box-shadow: 0 0 10px #FFD700;
        }
        /* Alternating glow when both timer warning and warcry are active */
        #board.low-time.warcry-active-border {
            animation: alternatingTimerWarcryGlow 2s ease-in-out infinite !important;
        }
        @keyframes alternatingTimerWarcryGlow {
            0%, 100% {
                border-color: #FFD700;
                box-shadow: 0 0 30px #FFD700;
            }
            50% {
                border-color: #d4af37;
                box-shadow: 0 0 40px #d4af37;
            }
        }
        #board.coin-flip-success {
            border-color: #FFFFFF !important;
            box-shadow: 0 0 20px #FFFFFF;
            animation: coinFlipGlow 1.5s ease-in-out;
        }
        @keyframes coinFlipGlow {
            0% {
                border-color: #000000;
                box-shadow: 0 0 0px #000000;
            }
            50% {
                border-color: #FFFFFF;
                box-shadow: 0 0 30px #FFFFFF;
            }
            100% {
                border-color: #000000;
                box-shadow: 0 0 0px #000000;
            }
        }
        #board.coin-flip-success-energy {
            border-color: #6a80ff !important;
            box-shadow: 0 0 24px #8fd4ff;
            animation: coinFlipEnergyBlastGlow 3.4s ease-in-out forwards;
        }
        @keyframes coinFlipEnergyBlastGlow {
            0% {
                border-color: #000000;
                box-shadow: 0 0 0px #000000;
            }
            50% {
                border-color: #6a80ff;
                box-shadow: 0 0 32px #9fd6ff;
            }
            75% {
                border-color: #7f94ff;
                box-shadow: 0 0 40px #b8e5ff;
            }
            100% {
                border-color: #6a80ff;
                box-shadow: 0 0 20px #6a80ff;
            }
        }
        #board.coin-flip-failure {
            animation: coinFlipFailure 1.5s ease-in-out;
        }
        @keyframes coinFlipFailure {
            0% {
                background-color: #fff !important;
            }
            50% {
                background-color: #000000 !important;
            }
            100% {
                background-color: #fff !important;
            }
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        /* New styles for capture effects */
        .capture-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.5);
            animation: fadeOut 2s ease-in-out;
            z-index: 10;
        }
        .capture-background {
            background-color: rgb(223, 0, 0) !important;
            animation: fadeOutBackground 2s ease-in-out;
        }
        .capture-game-background {
            background-color: rgb(223, 0, 0) !important;
            animation: fadeOutGameBackground 2s ease-in-out;
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        @keyframes fadeOutBackground {
            from { background-color: rgb(223, 0, 0); }
            to { background-color: inherit; }
        }
        @keyframes fadeOutGameBackground {
            from { background-color: rgb(223, 0, 0); }
            to { background-color: #202020; }
        }
        .coinflip-failure-game-background {
            background-color: #000000 !important;
            animation: fadeOutCoinFlipFailureBackground 2s ease-in-out;
        }
        @keyframes fadeOutCoinFlipFailureBackground {
            from { background-color: #000000; }
            to { background-color: #202020; }
        }
        /* Warcry achievement popup styles */
        #warcry-achievement-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 30px 40px;
            border: 2px solid #333;
            border-radius: 10px;
            z-index: 2003;
            text-align: center;
            min-width: 400px;
        }
        #warcry-achievement-modal h1 {
            margin: 0;
            font-size: 48px;
            color: #d4af37;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            letter-spacing: 4px;
        }
        #warcry-achievement-modal p {
            margin: 15px 0 0 0;
            font-size: 20px;
            color: #666;
        }
        #board.warcry-achievement {
            border-color: #d4af37 !important;
            box-shadow: 0 0 30px #d4af37;
            animation: warcryGlow 2.6s ease-in-out;
        }
        @keyframes warcryGlow {
            0% {
                border-color: #000000;
                box-shadow: 0 0 0px #000000;
            }
            50% {
                border-color: #d4af37;
                box-shadow: 0 0 40px #d4af37;
            }
            100% {
                border-color: #000000;
                box-shadow: 0 0 0px #000000;
            }
        }
        .warcry-achievement-background {
            background-color: #000000 !important;
            animation: fadeOutWarcryAchievementBackground 2.6s ease-in-out;
        }
        @keyframes fadeOutWarcryAchievementBackground {
            from { background-color: #000000; }
            to { background-color: #202020; }
        }
        .energy-blast-overlay {
            background: linear-gradient(135deg, #150c2b 0%, #24104f 50%, #150c2b 100%) !important;
            background-size: 400% 400%;
            animation: energyBlastOverlay 6s ease-in-out infinite;
            position: relative;
        }
        @keyframes energyBlastOverlay {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }
        .energy-blast-overlay::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at 20% 20%, rgba(143, 212, 255, 0.25), transparent 70%),
                        radial-gradient(circle at 80% 0%, rgba(106, 128, 255, 0.2), transparent 65%),
                        radial-gradient(circle at 60% 80%, rgba(80, 58, 255, 0.15), transparent 70%);
            animation: energyBlastRipple 12s linear infinite;
            z-index: 0;
            opacity: 0.4;
        }
        @keyframes energyBlastRipple {
            0% {
                transform: translate3d(0, 0, 0);
                opacity: 0.5;
            }
            50% {
                transform: translate3d(-2%, -1%, 0);
                opacity: 0.35;
            }
            100% {
                transform: translate3d(2%, 1%, 0);
                opacity: 0.5;
            }
        }
        #energy-blast-popup {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #0e1330;
            padding: 30px 40px;
            border: 2px solid #6a80ff;
            border-radius: 10px;
            z-index: 2003;
            text-align: center;
            min-width: 400px;
            box-shadow: 0 0 30px rgba(122, 146, 255, 0.8);
        }
        #energy-blast-popup h1 {
            margin: 0;
            font-size: 48px;
            color: #8fd4ff;
            text-shadow: 0 0 15px rgba(143, 212, 255, 0.8);
            letter-spacing: 4px;
        }
        #energy-blast-popup p {
            margin: 15px 0 0 0;
            font-size: 20px;
            color: #c5e4ff;
        }
        #board.energy-blast-glow {
            border-color: #6a80ff !important;
            box-shadow: 0 0 20px #6a80ff;
            animation: energyBlastGlow 1.6s ease-in-out infinite !important;
        }
        @keyframes energyBlastGlow {
            0% {
                box-shadow: 0 0 10px #4b5dff;
            }
            50% {
                box-shadow: 0 0 32px #9fd6ff;
            }
            100% {
                box-shadow: 0 0 10px #4b5dff;
            }
        }
        /* Active warcry bonus background */
        .warcry-active-background {
            background: linear-gradient(135deg, #202020 0%, #3a2f1a 50%, #202020 100%) !important;
            animation: warcryActivePulse 3s ease-in-out infinite;
        }
        @keyframes warcryActivePulse {
            0%, 100% {
                background: linear-gradient(135deg, #202020 0%, #3a2f1a 50%, #202020 100%);
            }
            50% {
                background: linear-gradient(135deg, #202020 0%, #4a3f1a 50%, #202020 100%);
            }
        }
        /* Active warcry bonus border */
        #board.warcry-active-border {
            border-color: #d4af37 !important;
            box-shadow: 0 0 30px #d4af37;
            animation: warcryActiveBorderPulse 2s ease-in-out infinite;
        }
        @keyframes warcryActiveBorderPulse {
            0%, 100% {
                border-color: #d4af37;
                box-shadow: 0 0 20px #d4af37;
            }
            50% {
                border-color: #d4af37;
                box-shadow: 0 0 40px #d4af37;
            }
        }
        /* Game stats modal styles */
        #game-stats-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2004;
            max-width: 800px;
            min-width: 700px;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: 10px;
            box-shadow: 0 20px 45px rgba(0, 0, 0, 0.35);
        }
        #game-stats-modal .modal-header {
            background-color: #333;
            color: #fff;
            padding: 15px 20px;
            margin: -20px -20px 20px -20px;
            border-radius: 8px 8px 0 0;
            text-align: center;
        }
        #game-stats-modal .modal-header span {
            font-size: 24px;
            font-weight: bold;
            display: block;
            text-align: center;
        }
        #game-stats-modal .modal-content {
            padding: 0;
            background-color: #fff;
            max-height: 70vh;
            overflow-y: auto;
        }
        #stats-victory-message {
            text-align: center;
            margin-bottom: 30px;
        }
        #stats-reason {
            font-size: 22px;
            font-weight: bold;
            color: #333;
            margin: 0;
        }
        #stats-head-to-head {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 30px;
        }
        .stats-column {
            flex: 1;
            max-width: 300px;
        }
        .stats-column h3 {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin: 0 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #4CAF50;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            margin-bottom: 5px;
            background-color: #f9f9f9;
            border-radius: 5px;
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }
        .stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }
        #stats-game-info {
            text-align: center;
            padding-top: 20px;
            border-top: 2px solid #ddd;
        }
        #stats-game-info p {
            margin: 8px 0;
            font-size: 15px;
            color: #666;
        }
        #game-stats-modal .modal-footer {
            display: inline-flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            width: 100%;
        }
        #game-stats-modal .modal-footer button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="landing-header">
        <h1>Ratix</h1>
        <p>Created by Craig Skobel</p>
        <button class="how-to-button" onclick="openHowToPlay()">How to Play</button>
    </div>
    <div id="start-menu">
        <h2>Select Game Variant</h2>
        <div class="variant-option">
            <button id="variant-btn-24s" data-ready="false" onclick="handleVariantClick('24s')">24's (Standard)</button>
            <div id="variant-info-24s" class="variant-info">
                <p class="variant-description">Board: 10x14. Layout: single Infantry front rank backing a classic Cavalry, Troll, Dragon, Wizard, Guard, Champion, and King battle line.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Beginner-friendly for learning Ratix fundamentals, yet still offers solid tactical depth for any player.</p>
            </div>
        </div>
        <div class="variant-option">
            <button id="variant-btn-36s" data-ready="false" onclick="handleVariantClick('36s')">36's (Advanced)</button>
            <div id="variant-info-36s" class="variant-info">
                <p class="variant-description">Board: 10x14. Layout: Infantry shield, Archer/Troll support row, and heavy back line with Ogres, Ballista units, royal pieces, and additional cavalry.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Ideal for intermediate players ready for layered formations and expanded special abilities.</p>
            </div>
        </div>
        <div class="variant-option">
            <button id="variant-btn-36s-expert" data-ready="false" onclick="handleVariantClick('36s-expert')">36's (Expert)</button>
            <div id="variant-info-36s-expert" class="variant-info">
                <p class="variant-description">Board: 10x14. Layout: adds Mercenaries and Elephantry to the forward ranks on top of the Archer support line and elite back row for maximal piece variety.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Suited to veteran players comfortable juggling many unit types and long-term tactical planning.</p>
            </div>
        </div>
        <div class="variant-option">
            <button id="variant-btn-36s-elite" data-ready="false" onclick="handleVariantClick('36s-elite')">36's (Elite)</button>
            <div id="variant-info-36s-elite" class="variant-info">
                <p class="variant-description">Board: 10x14. Layout: mirrors the Expert ranks but unlocks Necromancers and relentless Zombie hordes for high-impact summoning play.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Designed for expert players ready to manage advanced summoning chains and relentless board pressure.</p>
            </div>
        </div>
        <div class="variant-option">
            <button id="variant-btn-36s-supreme" data-ready="false" onclick="handleVariantClick('36s-supreme')">36's (Supreme)</button>
            <div id="variant-info-36s-supreme" class="variant-info">
                <p class="variant-description">Board: 10x14. Layout mirrors the Elite formation but unlocks experimental spellcraft for Wizards and Necromancers plus Champion-summoned Huntsmen who dart across the board via coin-flip fueled bursts.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Intended for master tacticians who can leverage high-risk, high-reward magic.</p>
            </div>
        </div>
        <div class="variant-option">
            <button id="variant-btn-ccb" data-ready="false" onclick="handleVariantClick('ccb')">24's Close-Combat Battle</button>
            <div id="variant-info-ccb" class="variant-info">
                <p class="variant-description">Board: 8x12. Layout: no buffer columns, keeping Infantry and the elite Cavalry/Troll/Dragon/Wizard formation in immediate close-quarters contact.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Best for aggressive intermediate-to-advanced players who enjoy fast tactical clashes.</p>
            </div>
        </div>
        
        <div id="difficulty-selector">
            <h3>Select AI Difficulty</h3>
            <button id="diff-easy" onclick="setDifficulty('Easy', this)">Easy</button>
            <button id="diff-medium" onclick="setDifficulty('Medium', this)" class="selected-diff">Medium</button>
            <button id="diff-hard" onclick="setDifficulty('Hard', this)">Hard</button>
        </div>

        <div id="opponent-selector">
            <h3>Select Your Opponent</h3>
            <button id="opp-random" onclick="setOpponent('Random', this)" class="selected-opponent">Random</button>
            <button id="opp-berserker" onclick="setOpponent('Berserker', this)">Berserker</button>
            <button id="opp-guardian" onclick="setOpponent('Guardian', this)">Guardian</button>
            <button id="opp-tactician" onclick="setOpponent('Tactician', this)">Tactician</button>
            <button id="opp-sorcerer" onclick="setOpponent('Sorcerer', this)">Sorcerer</button>
            <button id="opp-nomad" onclick="setOpponent('Nomad', this)">Nomad</button>
        </div>

        <div id="hint-selector">
            <h3>Hint System</h3>
            <button id="hint-on" onclick="setHintMode('On', this)">On</button>
            <button id="hint-off" onclick="setHintMode('Off', this)" class="selected-hint">Off</button>
        </div>

        <div id="game-timer-selector">
            <h3>Select Game Timer</h3>
            <button id="game-timer-quick" onclick="setGameTimer('quick', this)">10 mins (Quick)</button>
            <button id="game-timer-standard" onclick="setGameTimer('standard', this)" class="selected-option">30 mins (Standard)</button>
            <button id="game-timer-long" onclick="setGameTimer('long', this)">60 mins (Long)</button>
        </div>
        <div id="turn-timer-selector">
            <h3>Select Round Timer</h3>
            <button id="turn-timer-blitz" onclick="setTurnTimer('blitz', this)">30 secs (Blitz)</button>
            <button id="turn-timer-standard" onclick="setTurnTimer('standard', this)" class="selected-option">60 secs (Standard)</button>
        </div>
    </div>
    <footer id="landing-footer">Ratix &copy; 2025 Skobel Games</footer>
    <div id="game-container">
        <div id="score-display">
            <div class="player-panel" id="player-panel">
            <div class="player-name" id="player-name-label">Player</div>
            <div class="player-score" id="player-score-value">Score: 0</div>
            <div class="timer-row player" id="player-timer-row">Turn Time: 00:00</div>
            </div>
            <div class="round-panel">
                <div id="round-number-display">Round 1</div>
                <div class="timer-row game" id="game-timer-row">Game Time: 00:00</div>
            </div>
            <div class="player-panel" id="ai-panel">
            <div class="player-name" id="ai-name-label">Opponent</div>
            <div class="player-score" id="ai-score-value">Score: 0</div>
            <div class="timer-row ai" id="ai-timer-row">Turn Time: 00:00</div>
            </div>
        </div>
        <div id="game-layout">
            <aside id="left-panel">
                <div id="left-controls">
                    <button onclick="returnToMainMenu()">Main Menu</button>
                    <button onclick="resetGame()">Reset Game</button>
                </div>
                <div id="game-log"></div>
                <div id="info-box"></div>
            </aside>
            <div id="board-column">
                <div id="board"></div>
                <div id="controls">
            <button id="turn-button" onclick="openTurnModal()" style="display: none;">Turn Piece</button>
            <button id="turn-move-button" onclick="openTurnAndMoveModal()" style="display: none;">Turn and Move</button>
            <button id="turn-shoot-button" onclick="openTurnAndShootModal()" style="display: none;">Turn and Shoot</button>
            <button id="archer-move-diag-shoot-button" onclick="activateArcherMoveDiagShoot()" style="display: none;">Skirmish (Move+Diag Shot)</button>
            <button id="archer-diag2-shoot-button" onclick="activateArcherDiag2Shoot()" style="display: none;">Longshot Diagonal</button>
            <button id="guard-honour-button" onclick="activateGuardOfHonour()" style="display: none;">Guard of Honour</button>
            <button id="teleport-button" onclick="activateTeleport()" style="display: none;">Teleport</button>
            <button id="teleport-swap-button" onclick="activateTeleportSwap()" style="display: none;">Teleport Swap</button>
            <button id="charge-button" onclick="activateCharge()" style="display: none;">Charge</button>
            <button id="inferno-button" onclick="activateInferno()" style="display: none;">Inferno</button>
            <button id="strafe-button" onclick="activateStrafe()" style="display: none;">Strafe</button>
            <button id="summon-spectre-button" onclick="activateSummonSpectre()" style="display: none;">Summon Spectre</button>
            <button id="energy-blast-button" onclick="activateEnergyBlast()" style="display: none;">Energy Blast</button>
            <button id="sacrifice-button" onclick="activateSacrifice()" style="display: none;">Sacrifice</button>
            <button id="hint-button" onclick="showHint()" style="display: none;">Get Hint</button>
            <button id="end-turn-button" onclick="endTurn()" disabled>End Round</button>
                </div>
            </div>
            <aside id="right-panel">
                <div id="right-controls">
                    <button class="how-to-button" onclick="openHowToPlay()">How to Play</button>
                    <button id="ratix-brand-button" type="button">Ratix</button>
                </div>
                <div id="status">Player's turn: 3 moves remaining</div>
                <div id="captured-pieces">
                    <div class="captured-column">
                        <h3>Player's Captured Pieces</h3>
                        <div id="player-captured" class="captured-grid"></div>
                    </div>
                    <div class="captured-column">
                        <h3>Opponent's Captured Pieces</h3>
                        <div id="ai-captured" class="captured-grid"></div>
                    </div>
                </div>
            </aside>
        </div>
    </div>
    <div id="modal-overlay"></div>
    <div id="reinforce-modal">
        <h3>Select Reinforcement Piece</h3>
        <select id="reinforce-select"></select>
        <button onclick="confirmReinforcement()">Confirm</button>
    </div>
    <div id="king-summon-modal">
        <div class="modal-header"><span>Select Unit to Summon</span><button class="modal-close" onclick="closeKingSummonModal()" aria-label="Close">&times;</button></div>
        <select id="king-summon-select"></select>
        <button onclick="confirmKingSummon()">Summon (2 pts + coin flip)</button>
    </div>
    <div id="spell-direction-modal">
        <div class="modal-header"><span id="spell-direction-title">Select Direction</span><button class="modal-close" onclick="closeSpellDirectionModal()" aria-label="Close">&times;</button></div>
        <select id="spell-direction-select"></select>
        <button onclick="confirmSpellDirection()">Confirm</button>
    </div>
    <div id="protection-modal">
        <div class="modal-header"><span>Spell Protection</span><button class="modal-close" onclick="declineProtection()" aria-label="Close">&times;</button></div>
        <div class="modal-content">
            <p id="protection-message"></p>
            <select id="protection-select"></select>
        </div>
        <div class="modal-footer">
            <button onclick="confirmProtection()">Sacrifice</button>
            <button onclick="declineProtection()">Decline</button>
        </div>
    </div>
    <div id="turn-modal">
        <div class="modal-header"><span>Select Facing Direction</span><button class="modal-close" onclick="closeTurnModal()" aria-label="Close">&times;</button></div>
        <select id="turn-select"></select>
                <button onclick="confirmTurn()">Confirm</button>
    </div>
    <div id="turn-move-modal">
        <div class="modal-header"><span>Select Facing Direction</span><button class="modal-close" onclick="closeTurnMoveModal()" aria-label="Close">&times;</button></div>
        <select id="turn-move-select"></select>
        <button onclick="confirmTurnAndMove()">Confirm</button>
    </div>
    <div id="turn-shoot-modal">
        <div class="modal-header"><span>Select Facing Direction</span><button class="modal-close" onclick="closeTurnShootModal()" aria-label="Close">&times;</button></div>
        <select id="turn-shoot-select"></select>
        <button onclick="confirmTurnAndShoot()">Confirm</button>
    </div>
    <div id="how-to-play-modal">
        <div class="modal-header">
            <span>How to Play - Ratix</span>
            <button class="modal-close" onclick="closeHowToPlay()" aria-label="Close">&times;</button>
        </div>
        <div class="modal-content">
            <div id="rules-content"></div>
        </div>
        <div class="modal-footer">
            <button onclick="closeHowToPlay()">Resume Game</button>
        </div>
    </div>
    <div id="truce-modal">
        <div class="modal-header">
            <span>Truce Proposal</span>
        </div>
        <div class="modal-content">
            <p id="truce-message">Both players have 6 or fewer pieces remaining. Do you wish to agree to a truce and end the game in a draw?</p>
            <p id="truce-attempts"></p>
        </div>
        <div class="modal-footer">
            <button onclick="acceptTruce()" style="background-color: #4CAF50;">Accept Truce</button>
            <button onclick="declineTruce()" style="background-color: #f44336;">Decline</button>
        </div>
    </div>
    <div id="coin-toss-modal">
        <div class="modal-header">
            <span id="coin-toss-title">Coin Toss</span>
        </div>
        <div class="modal-content">
            <div id="coin-result" class="coin">☠︎</div>
            <p id="coin-toss-message"></p>
            <p id="coin-toss-description" style="font-size: 14px; margin-top: 10px;"></p>
        </div>
        <div class="modal-footer">
            <button id="coin-toss-start" onclick="startCoinToss()" style="display: none; background-color: #2196F3;">Flip Coin</button>
            <button id="coin-toss-continue" onclick="closeCoinToss()" style="display: none; background-color: #4CAF50;">Continue</button>
            <span id="coin-toss-progress" class="coin-progress">Successes: 0/0</span>
        </div>
    </div>
    <div id="warcry-achievement-modal">
        <h1>WARCRY</h1>
        <p>Bonus Granted</p>
    </div>
    <div id="energy-blast-popup">
        <h1>ENERGY BLAST</h1>
        <p>Spell Unleashed</p>
    </div>
    <div id="endgame-overlay"></div>
    <div id="game-stats-modal">
        <div class="modal-header">
            <span id="game-stats-title">Game Complete</span>
        </div>
        <div class="modal-content">
            <div id="game-stats-content">
                <div id="stats-victory-message">
                    <p id="stats-reason"></p>
                </div>
                <div id="stats-head-to-head">
                    <div id="stats-player-column" class="stats-column">
                        <h3 id="stats-player-name">Player</h3>
                        <div class="stat-item">
                            <span class="stat-label">Final Score</span>
                            <span id="stats-player-score" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Warcry Bonuses</span>
                            <span id="stats-player-warcry" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Despair Penalties</span>
                            <span id="stats-player-despair" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Most Captures (Round)</span>
                            <span id="stats-player-captures" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Highest Score (Round)</span>
                            <span id="stats-player-high-score" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Successful Summons</span>
                            <span id="stats-player-summons" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Reinforcements</span>
                            <span id="stats-player-reinforcements" class="stat-value"></span>
                        </div>
                    </div>
                    <div id="stats-ai-column" class="stats-column">
                        <h3 id="stats-ai-name">AI</h3>
                        <div class="stat-item">
                            <span class="stat-label">Final Score</span>
                            <span id="stats-ai-score" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Warcry Bonuses</span>
                            <span id="stats-ai-warcry" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Despair Penalties</span>
                            <span id="stats-ai-despair" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Most Captures (Round)</span>
                            <span id="stats-ai-captures" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Highest Score (Round)</span>
                            <span id="stats-ai-high-score" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Successful Summons</span>
                            <span id="stats-ai-summons" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Reinforcements</span>
                            <span id="stats-ai-reinforcements" class="stat-value"></span>
                        </div>
                    </div>
                </div>
                <div id="stats-game-info">
                    <p id="stats-turn-count"></p>
                    <p id="stats-duration"></p>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button id="game-stats-close" onclick="closeGameStats()" style="background-color: #4CAF50; color: white; padding: 12px 30px; font-size: 16px; border: none; border-radius: 5px; cursor: pointer;">Return to Main Menu</button>
        </div>
    </div>
    <script>
        let ROWS = 10;
        let COLS = 12;
        let gameVariant = '24s';
        let isFirstPlayerTurn = true;
        let lastAction = null;
        let turnAndMoveMode = false;
        let turnAndShootMode = false;
        let archerMoveDiagMode = false;
        let archerDiagShootSelectMode = false;
        let archerMoveDiagStart = null;
        let archerDiag2ShootMode = false;
        let guardOfHonourMode = false;
        let teleportMode = false;
        let teleportSwapMode = false;
        let chargeMode = false;
        let infernoMode = false; // New state for Dragon's Inferno
        let strafeMode = false; // New state for Wizard/Dragon Strafe
        let summonSpectreMode = false; // New state for Wizard Spectre summoning
        let elephantryChargeMode = false; // New state for Elephantry Charge
        let elephantryExtendedRangeActive = false; // Active when player is in extended range shooting mode
        let elephantryMoveShootMode = false; // Active when Elephantry has moved and needs to select shoot target
        let elephantryMoveShootPosition = null; // Store the position Elephantry moved to
        let pistolierMoveShootMode = false; // Active when Pistolier has moved and needs to select shoot target
        let pistolierMoveShootPosition = null; // Store the position Pistolier moved to
        let fusilierCrackShotActive = null; // Holds Fusilier piece currently empowered by Crack Shot
        let fusilierStrafeActive = false; // Active when Fusilier is selecting strafe move
        let huntsmenSummoned = { 'W': 0, 'B': 0 }; // Track Huntsman summons per player
        let huntsmenOnBoard = { 'W': 0, 'B': 0 }; // Track active Huntsmen
        let huntsmanBurstMode = null; // Active when Huntsman is selecting burst destination
        let pendingHuntsmanBurst = null; // Tracks ongoing Huntsman flip sequence
        let huntsmanBurstPauseState = null; // Preserve timers while burst flips resolve
        let championSummonMode = null; // Champion summon targeting state
        let necromancerSummonMode = null; // Necromancer summon targeting state
        let kingShotMode = null; // King shot targeting mode
        let kingEvadeMode = null; // King evade destination selection
        let moralBoostUses = { 'W': 0, 'B': 0 }; // Track Moral Boost activations
        let kingShotUsed = { 'W': false, 'B': false }; // Track King Shot usage
        let kingEvadeUsed = { 'W': false, 'B': false }; // Track King Evade usage
        let initialMovesLeft = 3;
        let baseMovesThisTurn = 3; // Track base moves without bonus (to know when bonus moves are spent)
        let aiPending = false; // Prevent duplicate AI scheduling
        let gamePaused = false; // Track if game is paused
        let gameOver = false; // Track if game has ended
        let pausedTimers = { game: null, turn: null, turnPlayer: null }; // Store timer states when paused

        const ENERGY_BLAST_FLIP_COUNT = 4;
        const ENERGY_BLAST_RESIDUAL_DURATION = 3;
        const ENERGY_BLAST_STEP_PROBABILITIES = [0, 0.9375, 0.6875, 0.3125, 0.0625];
        const ENERGY_BLAST_AI_THRESHOLD = 6;
        const SACRIFICE_SUCCESS_PROBABILITY = 0.5;
        const SACRIFICE_AI_THRESHOLD = 6;
        const HUNTSMAN_MAX_ACTIVE = 2;
        const HUNTSMAN_SUMMON_LIMIT = 6;
        const HUNTSMAN_BURST_FLIP_COUNT = 4;
        const HUNTSMAN_BURST_SUCCESS_PROBS = [0, 0.9375, 0.6875, 0.3125, 0.0625];
        const HUNTSMAN_BURST_AI_THRESHOLD = 3.5;
        const KING_SUMMON_AI_THRESHOLD = 4;
        const VARIANT_LABELS = {
            '24s': "24's (Standard)",
            '36s': "36's (Advanced)",
            '36s-expert': "36's (Expert)",
            '36s-elite': "36's (Elite)",
            '36s-supreme': "36's (Supreme)",
            'ccb': "24's Close-Combat Battle"
        };
        const VARIANT_KEYS = Object.keys(VARIANT_LABELS);

        function resetVariantSelections() {
            VARIANT_KEYS.forEach(variant => {
                const button = document.getElementById(`variant-btn-${variant}`);
                if (button) {
                    button.classList.remove('selected-variant');
                    button.textContent = VARIANT_LABELS[variant];
                    button.dataset.ready = 'false';
                }
                const info = document.getElementById(`variant-info-${variant}`);
                if (info) {
                    info.classList.remove('visible');
                }
            });
        }

        function handleVariantClick(variant) {
            const button = document.getElementById(`variant-btn-${variant}`);
            const info = document.getElementById(`variant-info-${variant}`);
            if (!button || !info) return;

            if (button.dataset.ready === 'true') {
                startGame(variant);
                return;
            }

            resetVariantSelections();
            info.classList.add('visible');
            button.classList.add('selected-variant');
            button.dataset.ready = 'true';
            button.textContent = 'Start Game';
        }

        // Truce/Draw system
        let truceAttempts = 0;
        let truceMaxAttempts = 3;
        let truceDeclinedTurns = 0;
        let truceEligible = true;
        let trucePlayerVote = null; // null, 'accept', 'decline'
        let truceAIVote = null;

        function returnToMainMenu() {
            if (confirm('Return to main menu? Current game will be lost.')) {
                // Stop all timers and intervals
                stopGameTimer();
                stopTurnTimer();
                if (window.aiTurnWatch) {
                    clearInterval(window.aiTurnWatch);
                    window.aiTurnWatch = null;
                }

                // Clear zombie advance timer if active
                if (zombieAdvanceTimer) {
                    clearTimeout(zombieAdvanceTimer);
                    zombieAdvanceTimer = null;
                }

                // Reset all game state variables
                currentPlayer = 'W';
                roundCount = 1;
                playerRoundNumber = 0;
                aiRoundNumber = 0;
                gameRound = 1;
                firstPlayer = null;
                selectedPiece = null;
                validMoves = [];
                movedPieces.clear();
                reinforcementPending = null;
                aiPending = false;
                aiTurnTimeoutForced = false;
                movesLeft = 0;
                initialMovesLeft = 0;
                capturedPieces = { 'W': [], 'B': [] };
                scores = { 'W': 0, 'B': 0 };
                gameLog = [];
                lastAction = null;
                zombieAutoAdvanceInProgress = false;
                clearZombieCoinAnimations();

                // Reset game pause state
                gamePaused = false;

                // Reset mercenary bonus turn state
                mercenaryBonusTurnActive = false;
                mercenaryBonusTurnPiece = null;
                mercenaryBonusTurnUsed = { 'W': new Set(), 'B': new Set() };
                mercenaryBonusTurnCount = { 'W': 0, 'B': 0 };

                // Close any open modals and clear pending special modes
                cancelSpecialModes();
                const reinforceModal = document.getElementById('reinforce-modal');
                if (reinforceModal) reinforceModal.style.display = 'none';

                // Show main menu
                document.getElementById('game-container').style.display = 'none';
                document.getElementById('start-menu').style.display = 'flex';
                const landingHeader = document.getElementById('landing-header');
                if (landingHeader) landingHeader.style.display = 'block';
                const landingFooter = document.getElementById('landing-footer');
                if (landingFooter) landingFooter.style.display = 'block';
                resetVariantSelections();
            }
        }

        function openHowToPlay() {
            gamePaused = true;
            // Pause timers - save state BEFORE stopping
            pausedTimers.game = gameTimerInterval;
            pausedTimers.turn = turnTimerInterval;
            pausedTimers.turnPlayer = currentTurnTimerPlayer; // Save which player's timer was running
            stopGameTimer();
            stopTurnTimer();

            // Generate and display rules content
            generateRulesContent();
            document.getElementById('how-to-play-modal').style.display = 'block';
        }

        function closeHowToPlay() {
            document.getElementById('how-to-play-modal').style.display = 'none';
            gamePaused = false;

            // Resume timers if they were running
            if (pausedTimers.game && gameTimeRemaining > 0) {
                startGameTimer();
            }
            if (pausedTimers.turn && pausedTimers.turnPlayer) {
                if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                    startTurnTimer('W', { reset: false });
                } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                    startTurnTimer('B', { reset: false });
                }
            }
            pausedTimers = { game: null, turn: null, turnPlayer: null };
        }

        function generateRulesContent() {
            const rulesDiv = document.getElementById('rules-content');

            let html = `
                <h2>Game Overview</h2>
                <p><strong>Ratix</strong> is a strategic chess-like game where you command an army against an AI opponent. Capture the enemy King to win!</p>

                <h2>Game Variants</h2>
                <ul>
                    <li><strong>24's (Standard):</strong> 10x14 board with 24 pieces per side</li>
                    <li><strong>36's (Advanced):</strong> 10x14 board with 36 pieces per side - includes Archers, Ballistas, and Ogres</li>
                    <li><strong>36's (Expert):</strong> 10x14 board with 36 pieces per side - includes all advanced pieces plus Mercenaries and Elephantry</li>
                    <li><strong>36's (Elite):</strong> 10x14 board with 36 pieces per side - includes all Expert pieces plus Necromancers and Zombies for advanced summoning gameplay</li>
                    <li><strong>36's (Supreme):</strong> 10x14 board with the Elite roster and unlocks experimental spellcraft for Wizards and Necromancers.</li>
                    <li><strong>24's Close-Combat Battle:</strong> Smaller 8x12 board for faster games</li>
                </ul>

                <h2>How to Win</h2>
                <ul>
                    <li><strong>Regicide:</strong> Capture the enemy King (instant victory)</li>
                    <li><strong>Supremacy:</strong> Capture enemy Champion, keep their score ≤1, and get your King or Champion to their back row</li>
                    <li><strong>Relentless:</strong> Activate 3 reinforcements using Infantry while opponent has 0 reinforcements</li>
                    <li><strong>Score Victory:</strong> Highest score when game timer expires</li>
                </ul>

                <h2>Draw Conditions</h2>
                <ul>
                    <li><strong>Truce:</strong> When both players have 6 or fewer pieces remaining, either player can propose a truce. Both players must agree for the game to end in a draw. If declined, the truce can be proposed again at the start of the next 3 rounds. After 3 declined attempts, truce is no longer available.</li>
                    <li><strong>Match:</strong> When both players only have their King remaining, the game automatically ends in a draw.</li>
                </ul>

                <h2>Round Mechanics</h2>
                <ul>
                    <li>Each round you have 3 moves (or 2 if your Champion was captured)</li>
                    <li>Different actions cost different move points (1-2 points)</li>
                    <li><strong>Honour (Warcry):</strong> Score 10+ points in a round to gain +2 moves next round</li>
                    <li><strong>Despair:</strong> Lose 2+ non-basic pieces in a round to suffer -2 moves next round</li>
                    <li>Champions on enemy back row reduce opponent's moves by 1</li>
                </ul>

                <h2>Reinforcements</h2>
                <p>When Infantry, Champion, or King reaches the opponent's back row without capturing, you can reinforce a captured piece to your back row.</p>
                <ul>
                    <li><strong>36's (Expert):</strong> Champion/King can reinforce Ballista, Elephantry, or Mercenary</li>
                </ul>

                <h2>Piece Information</h2>
            `;

            // Add piece information
            for (let [pieceName, info] of Object.entries(pieceInfo)) {
                // Format the info.extra to make "Special Moves:" or "Special Move:" bold
                let formattedExtra = info.extra.replace(/Special Moves?:/g, '<strong>$&</strong>');

                html += `
                    <div class="piece-info">
                        <div class="piece-name">${pieceName}</div>
                        <div><strong>Movement:</strong> ${info.points}</div>
                        <div><strong>Important:</strong> ${formattedExtra}</div>
                    </div>
                `;
            }

            html += `
                <h2>Piece Point Values</h2>
                <p>When you capture an enemy piece, you gain points based on the piece's value:</p>
                <ul>
                    <li><strong>Infantry:</strong> 1 point</li>
                    <li><strong>Archer:</strong> 2 points</li>
                    <li><strong>Cavalry:</strong> 3 points</li>
                    <li><strong>Pistolier:</strong> 3 points</li>
                    <li><strong>Zombie:</strong> 3 points</li>
                    <li><strong>Fusilier:</strong> 4 points</li>
                    <li><strong>Guard:</strong> 4 points</li>
                    <li><strong>Ballista:</strong> 5 points</li>
                    <li><strong>Spectre:</strong> 5 points</li>
                    <li><strong>Huntsman:</strong> 6 points</li>
                    <li><strong>Troll:</strong> 6 points</li>
                    <li><strong>Dragon:</strong> 7 points</li>
                    <li><strong>Ogre:</strong> 8 points</li>
                    <li><strong>Wizard:</strong> 9 points</li>
                    <li><strong>Mercenary:</strong> 10 points</li>
                    <li><strong>Necromancer:</strong> 10 points</li>
                    <li><strong>Elephantry:</strong> 11 points</li>
                    <li><strong>Champion:</strong> 12 points</li>
                    <li><strong>King:</strong> 13 points</li>
                </ul>

                <h2>Special Abilities</h2>
                <ul>
                    <li><strong>King - Guard of Honour:</strong> Swap with adjacent Guard (2 points, once per game)</li>
                    <li><strong>Wizard - Teleport:</strong> Move to any empty square of same color (2 points, twice per game)</li>
                    <li><strong>Wizard - Teleport Swap:</strong> Swap with enemy Wizard on same color (2 points, once per game)</li>
                    <li><strong>Cavalry - Charge:</strong> Move unlimited squares in one direction (2 points, once per game)</li>
                    <li><strong>Dragon - Inferno:</strong> Move 1 square and capture all adjacent enemies (2 points, once per game)</li>
                    <li><strong>Archer - Skirmish:</strong> Move then shoot diagonally 1 square (2 points, twice per game)</li>
                    <li><strong>Archer - Longshot Diagonal:</strong> Shoot diagonally 2 squares (2 points, twice per game)</li>
                    <li><strong>Ballista - Extend Range:</strong> +1 shooting range this round (2 points, once per round)</li>
                    <li><strong>Ballista - Double Time:</strong> Move 2 squares in one direction (2 points, twice per game)</li>
                </ul>

                <h2>Supreme Spellcraft</h2>
                <p>Exclusive to the 36's (Supreme) variant:</p>
                <ul>
                    <li><strong>Energy Blast:</strong> Wizards and Necromancers must first succeed on a spellcasting coin flip (costs 2 move points even on failure), then perform four consecutive flips (1 square per success) to determine the blast distance. First use costs 2 move points, second costs 3. The blast travels straight or diagonally toward the opponent's side and vaporizes every enemy along its path while ignoring friendlies.</li>
                    <li><strong>Sacrifice Spell:</strong> Once per game, a Wizard or Necromancer may spend 3 move points, win a coin flip, and remove themselves from play to detonate a blast that reaches 2 squares orthogonally and 1 square diagonally. Only available if the coin flip succeeds.</li>
                    <li><strong>Protection:</strong> When a spell would capture a King, that player may (once per game) sacrifice a Wizard, Necromancer, or Champion to negate the capture. This also deducts 2 move points from the start of their next round.</li>
                    <li><strong>Huntsman:</strong> Champions can summon Huntsmen (max 2 active, 6 total per player). Huntsmen move 1 square, or spend 2 move points to roll four coin flips, gaining 1 chained step of movement per success. Shots against Huntsmen require a coin flip to succeed, while Huntsmen automatically capture Zombies.</li>
                </ul>

                <h2>Tips</h2>
                <ul>
                    <li>Protect your King and Champion - losing them severely weakens your army</li>
                    <li>Plan your moves carefully - you only get 3 per round</li>
                    <li>Use special abilities strategically - most can only be used once or twice</li>
                    <li>Watch the timers - running out of time forfeits your round</li>
                    <li>Score points by capturing enemy pieces - higher value pieces give more points</li>
                </ul>
            `;

            rulesDiv.innerHTML = html;
        }

        function countPieces(player) {
            let count = 0;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] && board[r][c].player === player) {
                        count++;
                    }
                }
            }
            return count;
        }

        function checkForMatch() {
            const playerPieces = countPieces('W');
            const aiPieces = countPieces('B');

            // Check if both players only have their King left
            if (playerPieces === 1 && aiPieces === 1) {
                let playerHasOnlyKing = false;
                let aiHasOnlyKing = false;

                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (board[r][c]) {
                            if (board[r][c].player === 'W' && board[r][c].type === 'King') {
                                playerHasOnlyKing = true;
                            }
                            if (board[r][c].player === 'B' && board[r][c].type === 'King') {
                                aiHasOnlyKing = true;
                            }
                        }
                    }
                }

                if (playerHasOnlyKing && aiHasOnlyKing) {
                    gameLog.push('Match: Both players only have their King remaining. Game ends in a draw.');
                    updateGameLog();
                    endGame('draw', 'Match');
                    return true;
                }
            }
            return false;
        }

        function checkForTruce() {
            if (!truceEligible || truceAttempts >= truceMaxAttempts) return;

            const playerPieces = countPieces('W');
            const aiPieces = countPieces('B');

            // Check if both players have 6 or fewer pieces
            if (playerPieces <= 6 && aiPieces <= 6) {
                // Only show truce modal at the start of player's turn after a decline
                if (truceDeclinedTurns > 0 && truceDeclinedTurns <= 3) {
                    proposeTruce();
                } else if (truceDeclinedTurns === 0) {
                    // First time checking - propose immediately
                    proposeTruce();
                }
            }
        }

        function proposeTruce() {
            gamePaused = true;
            stopGameTimer();
            stopTurnTimer();

            truceAttempts++;
            const attemptsRemaining = truceMaxAttempts - truceAttempts;

            document.getElementById('truce-attempts').textContent =
                `Attempt ${truceAttempts} of ${truceMaxAttempts}. ${attemptsRemaining} attempts remaining.`;

            // Calculate AI decision based on piece point values
            const aiPieces = countPieces('B');
            const playerPieces = countPieces('W');

            // Calculate total piece values for both players
            let aiTotalValue = 0;
            let playerTotalValue = 0;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece) {
                        const value = pieceValues[piece.type] || 0;
                        if (piece.player === 'B') {
                            aiTotalValue += value;
                        } else if (piece.player === 'W') {
                            playerTotalValue += value;
                        }
                    }
                }
            }

            // AI decision logic:
            // Base 50% chance, then adjusted by piece value difference
            // If AI has lower total value, more likely to accept
            // If AI has higher total value, less likely to accept
            const valueDifference = aiTotalValue - playerTotalValue;
            let acceptanceChance = 0.5; // Base 50% chance

            // Adjust based on value difference (normalized by typical piece value)
            acceptanceChance -= valueDifference / 50; // Adjust by ~2% per point difference

            // Clamp between 10% and 90%
            acceptanceChance = Math.max(0.1, Math.min(0.9, acceptanceChance));

            truceAIVote = (Math.random() < acceptanceChance) ? 'accept' : 'decline';

            // Set up 30-second timeout for auto-decline
            if (window.truceTimeout) {
                clearTimeout(window.truceTimeout);
            }
            window.truceTimeout = setTimeout(() => {
                if (document.getElementById('truce-modal').style.display === 'block') {
                    // Auto-decline if player hasn't responded
                    gameLog.push('Truce proposal timed out after 30 seconds. Automatically declined.');
                    updateGameLog();
                    declineTruce();
                }
            }, 30000); // 30 seconds

            document.getElementById('truce-modal').style.display = 'block';
        }

        function acceptTruce() {
            trucePlayerVote = 'accept';

            // Clear the timeout
            if (window.truceTimeout) {
                clearTimeout(window.truceTimeout);
                window.truceTimeout = null;
            }

            document.getElementById('truce-modal').style.display = 'none';

            if (truceAIVote === 'accept') {
                gameLog.push('Player accepted truce.');
                gameLog.push('AI accepted truce.');
                gameLog.push('Truce accepted by both players. Game ends in a draw.');
                updateGameLog();
                endGame('draw', 'Truce');
                return;
            } else {
                gameLog.push('Player accepted truce.');
                gameLog.push('AI declined truce.');
                gameLog.push(`Truce not established. ${truceMaxAttempts - truceAttempts} attempts remaining.`);
                updateGameLog();
                truceDeclinedTurns = 1;
                resumeAfterTruce();
            }
        }

        function declineTruce() {
            trucePlayerVote = 'decline';

            // Clear the timeout
            if (window.truceTimeout) {
                clearTimeout(window.truceTimeout);
                window.truceTimeout = null;
            }

            document.getElementById('truce-modal').style.display = 'none';

            gameLog.push('Player declined truce.');
            if (truceAIVote === 'accept') {
                gameLog.push('AI accepted truce.');
            } else {
                gameLog.push('AI declined truce.');
            }
            gameLog.push(`Truce not established. ${truceMaxAttempts - truceAttempts} attempts remaining.`);
            updateGameLog();

            if (truceAttempts >= truceMaxAttempts) {
                truceEligible = false;
                gameLog.push('Truce is no longer available for this game.');
                updateGameLog();
            } else {
                truceDeclinedTurns = 1;
            }

            resumeAfterTruce();
        }

        function resumeAfterTruce() {
            gamePaused = false;
            startGameTimer();
            if (currentPlayer === 'W') {
                startTurnTimer('W', { reset: false });
            } else {
                startTurnTimer('B', { reset: false });
            }
        }

        function performCoinToss(title, message, callback, automated = false, showOverlay = true) {
            gamePaused = true;
            // Save timer state before stopping
            pausedTimers.game = gameTimerInterval;
            pausedTimers.turn = turnTimerInterval;
            pausedTimers.turnPlayer = currentTurnTimerPlayer;
            stopGameTimer();
            stopTurnTimer();

            coinTossCallback = callback;

            // Store overlay state for later cleanup
            window.coinTossShowOverlay = showOverlay;

            // Determine if this is the first round coin toss or an in-game outcome
            const isFirstTurn = title === 'First Round';
            window.coinTossContext = isFirstTurn ? 'first-turn' : 'in-game';

            document.getElementById('coin-toss-title').textContent = title;
            document.getElementById('coin-toss-message').textContent = message;

            // Set appropriate description based on context
            if (isFirstTurn) {
                document.getElementById('coin-toss-description').textContent = 'The coin will flip to determine the outcome. White side means you go first, black side means AI goes first.';
            } else {
                document.getElementById('coin-toss-description').textContent = 'The coin will flip to determine the outcome. White side means success, black side means failure.';
            }

            const continueBtn = document.getElementById('coin-toss-continue');
            if (continueBtn) continueBtn.style.display = 'none';
            updateCoinTossEnergyBlastProgress();

            // If automated (AI action), hide the button and auto-start
            if (automated) {
                document.getElementById('coin-toss-start').style.display = 'none';
            } else {
                document.getElementById('coin-toss-start').style.display = 'inline-block';
            }

            const coinResult = document.getElementById('coin-result');
            // Reset coin to initial state
            coinResult.className = 'coin';
            coinResult.textContent = '☠︎';
            coinResult.style.backgroundColor = '#666';
            coinResult.style.color = 'white';

            // Show overlay and modal (conditionally show overlay)
            if (showOverlay) {
                document.getElementById('modal-overlay').style.display = 'block';
            }
            document.getElementById('coin-toss-modal').style.display = 'block';

            // Auto-start coin flip for AI
            if (automated) {
                setTimeout(() => startCoinToss(), 500);
            }
        }

        function startCoinToss() {
            // Hide the start button and description
            document.getElementById('coin-toss-start').style.display = 'none';
            document.getElementById('coin-toss-description').textContent = '';
            document.getElementById('coin-toss-message').textContent = 'Flipping...';

            const coinResult = document.getElementById('coin-result');
            const continueBtn = document.getElementById('coin-toss-continue');
            const isEnergyBlastFlip = !!coinTossEnergyBlastMode;

            // Determine result
            const result = Math.random() < 0.5; // true = white (success), false = black (failure)
            window.lastCoinTossResult = result;

            // Add spinning animation
            coinResult.classList.add('spinning');

            // After animation completes (2 seconds), show result
            setTimeout(() => {
                // Remove spinning class
                coinResult.classList.remove('spinning');

                // Apply result styling and show appropriate message based on context
                const isFirstTurn = window.coinTossContext === 'first-turn';

                if (result) {
                    coinResult.classList.add('white');
                    coinResult.style.backgroundColor = 'white';
                    coinResult.style.color = 'black';

                    if (isFirstTurn) {
                        document.getElementById('coin-toss-message').textContent = "You won the coin toss! You're going first.";
                    } else {
                        document.getElementById('coin-toss-message').textContent = "Success!";
                        applyCoinFlipSuccessEffect(coinTossSpecialEffect);
                    }
                } else {
                    coinResult.classList.add('black');
                    coinResult.style.backgroundColor = 'black';
                    coinResult.style.color = 'white';

                    if (isFirstTurn) {
                        document.getElementById('coin-toss-message').textContent = `${getOpponentDisplayName()} won the coin toss and is going first.`;
                    } else {
                        document.getElementById('coin-toss-message').textContent = "Failure!";
                        applyCoinFlipFailureEffect();
                    }
                }
                coinTossSpecialEffect = null;

                if (coinTossEnergyBlastMode) {
                    coinTossEnergyBlastMode.successes = Math.min(
                        coinTossEnergyBlastMode.total || ENERGY_BLAST_FLIP_COUNT,
                        (coinTossEnergyBlastMode.successes || 0) + (result ? 1 : 0)
                    );
                    updateCoinTossEnergyBlastProgress();
                }

                // Show continue button after result is displayed
                const showDelay = isEnergyBlastFlip ? 0 : 500;
                setTimeout(() => {
                    if (!isEnergyBlastFlip && continueBtn) {
                        continueBtn.style.display = 'inline-block';
                    }

                    // Auto-close after a delay
                    const autoCloseDelay = isEnergyBlastFlip ? 800 : 2000;
                    setTimeout(() => {
                        // Close overlay and modal
                        if (window.coinTossShowOverlay) {
                            document.getElementById('modal-overlay').style.display = 'none';
                        }
                        document.getElementById('coin-toss-modal').style.display = 'none';

                        // Wait for modal to be completely hidden before starting game
                        setTimeout(() => {
                            // Execute callback which will handle game initialization
                            if (coinTossCallback) {
                                const callback = coinTossCallback;
                                coinTossCallback = null;
                                callback(result);
                            }

                            // Unpause game and resume timers after callback completes
                            gamePaused = false;

                            // Resume timers if they were running before the coin toss
                            if (pausedTimers.game && gameTimeRemaining > 0) {
                                startGameTimer();
                            }
                            if (pausedTimers.turn && pausedTimers.turnPlayer) {
                                if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                                    startTurnTimer('W', { reset: false });
                                } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                                    startTurnTimer('B', { reset: false });
                                }
                            }
                            pausedTimers = { game: null, turn: null, turnPlayer: null };
                        }, 300);
                    }, autoCloseDelay);
                }, showDelay);
            }, 2000);
        }

        function closeCoinToss() {
            // Close overlay and modal
            if (window.coinTossShowOverlay) {
                document.getElementById('modal-overlay').style.display = 'none';
            }
            document.getElementById('coin-toss-modal').style.display = 'none';

            // Wait for modal to be completely hidden before starting game
            setTimeout(() => {
                // Execute callback if it exists
                if (coinTossCallback) {
                    const callback = coinTossCallback;
                    coinTossCallback = null;
                    // Use the stored result from the coin toss
                    callback(window.lastCoinTossResult);
                }

                // Unpause game and resume timers
                gamePaused = false;

                // Resume timers if they were running before the coin toss
                if (pausedTimers.game && gameTimeRemaining > 0) {
                    startGameTimer();
                }
                if (pausedTimers.turn && pausedTimers.turnPlayer) {
                    if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                        startTurnTimer('W', { reset: false });
                    } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                        startTurnTimer('B', { reset: false });
                    }
                }
                pausedTimers = { game: null, turn: null, turnPlayer: null };
            }, 300);
        }

        function triggerAiTurn() {
            if (gameOver || gamePaused || aiPending || reinforcementPending || currentPlayer !== 'W') return;
            stopTurnTimer();
            // Remove warcry active background when switching to AI turn
            removeWarcryActiveBackground();
            applyEndTurnEffects('W');
            // Update round statistics before switching to AI
            updateRoundStats('W');

            // Increment round when second player finishes their round
            if (firstPlayer === 'B') {
                // AI went first, so player finishing means round is complete
                gameRound++;
            }

            aiPending = true;
            try {
                aiTurn();
            } catch (err) {
                console.error('AI round failed:', err);
                completeAiTurn({ reason: 'AI encountered an error taking its round.' });
            } finally {
                // aiTurn clears the flag when it begins; keep safety fallback here
                if (aiPending) {
                    aiPending = false;
                }
            }
        }

        function completeAiTurn({ reason = null, skipEndEffects = false } = {}) {
            if (!skipEndEffects) {
                applyEndTurnEffects('B');
            }
            // Update round statistics before switching players
            updateRoundStats('B');
            aiPending = false;
            aiTurnTimeoutForced = false;
            stopTurnTimer();
            highlightSquares = [];
            currentPlayer = 'W';
            roundCount++; // Increment round counter when AI finishes and control returns to player

            // Increment round when second player finishes their round
            if (firstPlayer === 'W') {
                // Player went first, so AI finishing means round is complete
                gameRound++;
            }
            ballistaRangeBoostActive['W'] = false;
            ballistaRangeBoostUsedThisTurn['W'] = false;
            // Reset wizard summoning flag for new round
            wizardSummonedThisTurn['W'] = false;
            // Clear wizard movement restrictions from previous round
            wizardCannotMoveNextTurn['W'].clear();

            const humanBaseMoves = calculateBaseMoves('W');
            const playerCanMove = applyStartTurnModifiers('W', humanBaseMoves);

            movedPieces.clear();
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            checkGameOver();

            if (!playerCanMove) {
                triggerAiTurn();
            } else {
                ensureAITurnIfNeeded();
            }

            if (reason) {
                gameLog.push(reason);
                updateGameLog();
            }
        }

        function ensureAITurnIfNeeded() {
            if (gamePaused || currentPlayer !== 'W' || reinforcementPending || aiPending) return;
            // Don't end turn if pistolier is in move+shoot mode waiting for shot selection
            if (pistolierMoveShootMode) return;
            if (movesLeft <= 0) {
                triggerAiTurn();
                return;
            }
            // For larger boards, always check if turn should end (not just when moves used)
            // For smaller boards, only check if at least one move has been used
            if (movesLeft < initialMovesLeft || isLargeBoardVariant()) {
                let anyValidActions = false;
                outer: for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const piece = board[r][c];
                        if (piece && piece.player === 'W' && !movedPieces.has(`${r},${c}`)) {
                            const vm = getValidMoves(r, c);
                            // Check if any moves are actually affordable
                            for (let move of vm) {
                                if (move.cost <= movesLeft) {
                                    anyValidActions = true;
                                    break outer;
                                }
                            }
                        }
                    }
                }
                if (!anyValidActions) {
                    movesLeft = 0; // Ensure movesLeft is 0 before triggering
                    triggerAiTurn();
                }
            }
        }

        function isAnySpecialModeActive() {
            return turnAndShootMode || turnAndMoveMode || guardOfHonourMode || teleportMode || teleportSwapMode || chargeMode || infernoMode || strafeMode || summonSpectreMode || archerMoveDiagMode || archerDiagShootSelectMode || archerDiag2ShootMode || elephantryChargeMode || elephantryExtendedRangeActive || elephantryMoveShootMode || pistolierMoveShootMode || fusilierCrackShotActive || fusilierStrafeActive || huntsmanBurstMode || pendingHuntsmanBurst || championSummonMode || necromancerSummonMode || kingShotMode || kingEvadeMode;
        }

        function cancelSpecialModes(options = {}) {
            const { resetSelection = true } = options;
            turnAndShootMode = false;
            turnAndMoveMode = false;
            guardOfHonourMode = false;
            teleportMode = false;
            teleportSwapMode = false;
            chargeMode = false;
            infernoMode = false;
            strafeMode = false;
            summonSpectreMode = false;
            archerMoveDiagMode = false;
            archerDiagShootSelectMode = false;
            archerDiag2ShootMode = false;
            elephantryChargeMode = false;
            elephantryExtendedRangeActive = false;
            fusilierCrackShotActive = null;
            fusilierStrafeActive = false;
            elephantryMoveShootMode = false;
            elephantryMoveShootPosition = null;
            pistolierMoveShootMode = false;
            pistolierMoveShootPosition = null;
            const huntsmanContext = huntsmanBurstMode;
            huntsmanBurstMode = null;
            pendingHuntsmanBurst = null;
            resumeGameAfterHuntsmanBurst();
            if (huntsmanContext && typeof huntsmanContext.onComplete === 'function') {
                huntsmanContext.onComplete();
            }
            championSummonMode = null;
            necromancerSummonMode = null;
            kingShotMode = null;
            kingEvadeMode = null;
            archerMoveDiagStart = null;
            const turnModalEl = document.getElementById('turn-modal');
            if (turnModalEl) turnModalEl.style.display = 'none';
            const turnMoveModalEl = document.getElementById('turn-move-modal');
            if (turnMoveModalEl) turnMoveModalEl.style.display = 'none';
            const turnShootModalEl = document.getElementById('turn-shoot-modal');
            if (turnShootModalEl) turnShootModalEl.style.display = 'none';
            lastAction = null;

            if (resetSelection) {
                selectedPiece = null;
                validMoves = [];
                showPieceInfo(null);
            } else if (selectedPiece) {
                const { row, col } = selectedPiece;
                if (board[row][col] && board[row][col].player === currentPlayer) {
                    validMoves = getValidMoves(row, col);
                    showPieceInfo(board[row][col], currentPlayer);
                } else {
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                }
            } else {
                validMoves = [];
            }

            pendingEnergyBlast = null;
            activeEnergyBlastCost = null;
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            resumeGameForEnergyBlastFlips();
            removeEnergyBlastGlow();
        }

        function applyEndTurnEffects(player) {
            const opponent = getOpponent(player);
            let logUpdated = false;

            if (roundScoreGain[player] >= HONOUR_THRESHOLD) {
                nextRoundModifier[player] += HONOUR_BONUS;
                gameStats.warcryBonusCount[player]++;
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} triggered Honour (Warcry) bonus (+${HONOUR_BONUS} moves next round).`);
                logUpdated = true;
            }

            const losses = roundLosses[opponent] || {};
            for (let type in losses) {
                if (losses[type] >= 2 && !DESPAIR_EXCLUDED.has(type)) {
                    nextRoundModifier[opponent] -= DESPAIR_PENALTY;
                    gameStats.despairPenaltyCount[opponent]++;
                    gameLog.push(`${opponent === 'W' ? 'Player' : 'AI'} suffers Despair penalty (-${DESPAIR_PENALTY} moves next round).`);
                    logUpdated = true;
                    break;
                }
            }

            roundScoreGain[player] = 0;
            roundLosses[player] = {};
            roundLosses[opponent] = {};
            warcryAchievedThisRound[player] = false;

            // Update Fusilier cooldowns at the end of the player's round
            finalizeFusilierShots(player);

            // Clear mercenary bonus turn tracking at the end of the player's round
            mercenaryBonusTurnUsed[player].clear();

            // Clear mercenary bonus turn state to prevent it from carrying over to next round
            if (mercenaryBonusTurnActive && mercenaryBonusTurnPiece) {
                mercenaryBonusTurnActive = false;
                mercenaryBonusTurnPiece = null;
            }

            if (logUpdated) {
                updateGameLog();
            }
        }

        function finalizeFusilierShots(player) {
            const lastTurnSet = fusilierShotLastTurn[player];
            if (!lastTurnSet) return;

            if (fusilierCrackShotActive && fusilierCrackShotActive.player === player) {
                fusilierCrackShotActive = null;
            }

            lastTurnSet.clear();
            fusilierShotThisTurn[player].forEach(piece => {
                if (piece && piece.player === player && piece.type === 'Fusilier') {
                    lastTurnSet.add(piece);
                }
            });
            fusilierShotThisTurn[player].clear();
        }

        function pruneFusilierShotTracking(player) {
            const activeFusiliers = new Set();
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece && piece.player === player && piece.type === 'Fusilier') {
                        activeFusiliers.add(piece);
                    }
                }
            }

            const lastTurnSet = fusilierShotLastTurn[player];
            if (lastTurnSet) {
                const keep = [];
                lastTurnSet.forEach(piece => {
                    if (activeFusiliers.has(piece)) {
                        keep.push(piece);
                    }
                });
                lastTurnSet.clear();
                keep.forEach(piece => lastTurnSet.add(piece));
            }

            const thisTurnSet = fusilierShotThisTurn[player];
            if (thisTurnSet) {
                const keep = [];
                thisTurnSet.forEach(piece => {
                    if (activeFusiliers.has(piece)) {
                        keep.push(piece);
                    }
                });
                thisTurnSet.clear();
                keep.forEach(piece => thisTurnSet.add(piece));
            }
        }

        function calculateBaseMoves(player) {
            let base = championCaptured[player] ? 2 : 3;
            const opponent = getOpponent(player);
            base -= championsOnBackRow[opponent].length;
            return Math.max(0, base);
        }

        function applyStartTurnModifiers(player, baseMoves, options = {}) {
            const { skipStopTimer = false } = options;
            if (!skipStopTimer) {
                stopTurnTimer();
            }
            pruneFusilierShotTracking(player);
            const opponent = getOpponent(player);
            let modifier = nextRoundModifier[player] || 0;
            let moves = Math.max(0, baseMoves + modifier);

            if (modifier > 0) {
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} gains Honour (Warcry) bonus (+${modifier} moves).`);
                // Apply warcry active background
                applyWarcryActiveBackground();
            } else if (modifier < 0) {
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} is hindered by Despair penalty (-${Math.abs(modifier)} moves).`);
            }

            if (modifier !== 0) {
                updateGameLog();
            }

            nextRoundModifier[player] = 0;
            movesLeft = moves;
            initialMovesLeft = moves;
            baseMovesThisTurn = baseMoves; // Store base moves for tracking when bonus is spent
            roundScoreGain[player] = 0;
            roundLosses[player] = roundLosses[player] || {};
            roundLosses[opponent] = {};
            decrementNecromancerCooldown(player);
            decayEnergyBlastResiduals(player);
            let turnStartHandled = false;
            const finalizeTurnStart = () => {
                if (turnStartHandled) return;
                turnStartHandled = true;
                if (moves === 0) {
                    if (player === 'W') {
                        playerTurnTimeRemaining = 0;
                    } else {
                        aiTurnTimeRemaining = 0;
                    }
                    updateTimerDisplay();
                    gameLog.push(`${player === 'W' ? 'Player' : 'AI'} is immobilized this round.`);
                    updateGameLog();
                    return;
                }

                startTurnTimer(player);

                // Check for truce at start of player's round
                if (player === 'W' && truceDeclinedTurns > 0) {
                    truceDeclinedTurns++;
                    if (truceDeclinedTurns <= 3) {
                        checkForTruce();
                    }
                } else if (player === 'W' && truceDeclinedTurns === 0) {
                    checkForTruce();
                }
            };

            const zombiesPending = advanceZombiesForPlayer(player, finalizeTurnStart);
            if (!zombiesPending) {
                finalizeTurnStart();
            }

            return moves > 0;
        }
        let highlightSquares = [];
        let pendingSpellAction = null;
        let energyBlastUsage = new Map();
        let energyBlastUses = { 'W': 0, 'B': 0 };
        let sacrificeAttemptedPieces = new Set();
        let energyBlastFlipContext = null;
        let pendingEnergyBlast = null;
        let activeEnergyBlastCost = null;
        let energyBlastGlowActive = false;
        let energyBlastResidualSquares = new Map();
        let energyBlastFlipPauseState = null;
        let coinTossEnergyBlastMode = null;
        let coinTossSpecialEffect = null;
        let pendingAiEnergyBlastResume = null;
        let protectionUsed = { 'W': false, 'B': false };
        let pendingProtection = null;
        let kingSpecialUsed = { 'W': false, 'B': false };
        let wizardTeleportUsed = { 'W': 0, 'B': 0 };
        let wizardTeleportSwapUsed = { 'W': false, 'B': false };
        let cavalryChargeUsed = { 'W': false, 'B': false };
        let dragonInfernoUsed = { 'W': false, 'B': false }; // New state for Inferno usage
        let wizardStrafeUsed = { 'W': 0, 'B': 0 }; // Strafe move (limit 2)
        let dragonStrafeUsed = { 'W': 0, 'B': 0 }; // Strafe move (limit 2)
        let spectresSummoned = { 'W': 0, 'B': 0 }; // Spectre summoning (limit 2 per player)
        let wizardSummonedThisTurn = { 'W': false, 'B': false }; // Track if wizard summoned this turn
        let wizardCannotMoveNextTurn = { 'W': new Set(), 'B': new Set() }; // Wizards that cannot move next turn
        let necromancersSummoned = { 'W': 0, 'B': 0 }; // Necromancer summoning (limit 2 per player)
        let necromancerTeleportCounts = new Map(); // Track per-piece teleport usage
        let necromancerShootCooldown = new Map(); // Track per-piece ranged cooldown
        let zombiesSummoned = { 'W': 0, 'B': 0 }; // Total Zombies currently controlled (base cap 3)
        let zombiePendingAdvanceQueue = []; // Pending automatic Zombie advances requests
        let zombieConversions = { 'W': 0, 'B': 0 }; // Successful zombie conversions (max 2 to raise cap)
        let zombieCoinQueue = []; // Pending zombie coin flip animations
        let zombieCoinAnimating = false;
        let zombieCoinModalTimeouts = [];
        let zombieAutoAdvanceInProgress = false;
        let zombieAdvanceTimer = null;
        let coinTossCallback = null; // Callback for coin toss result
        let archerMoveDiagShootUsed = { 'W': 0, 'B': 0 }; // Move then shoot diagonally (limit 2)
        let archerDiag2ShootUsed = { 'W': 0, 'B': 0 }; // Diagonal 2-square shot (limit 2)
        let capturedSquares = []; // Track squares where captures occur
        // Ballista specials
        let ballistaRangeBoostActive = { 'W': false, 'B': false };
        let ballistaRangeBoostUsedThisTurn = { 'W': false, 'B': false };
        let ballistaDoubleTimeUsed = { 'W': 0, 'B': 0 };
        // Elephantry specials
        let elephantryChargeUsed = new Set(); // Track which elephantry pieces have used charge (set of "row,col,player")
        let elephantryExtendedRangeShotsRemaining = {}; // Map of "row,col,player" to remaining shots (starts at 3)
        let elephantryExtendedRangeMode = false; // Active during extended range shooting sequence
        // Fusilier specials
        let fusilierShotLastTurn = { 'W': new Set(), 'B': new Set() }; // Fusiliers that fired last turn (wait one turn before shooting again)
        let fusilierShotThisTurn = { 'W': new Set(), 'B': new Set() }; // Fusiliers that have fired during the current turn
        let fusilierCrackShotUsed = new Set(); // Track which fusilier pieces have used crack shot (set of "row,col,player", max 3 uses)
        let fusilierCrackShotCount = {}; // Map of "row,col,player" to remaining uses (starts at 3)
        let fusilierStrafeUsed = new Set(); // Track which fusilier pieces have used strafe (set of "row,col,player", max 2 uses)
        let fusilierStrafeCount = {}; // Map of "row,col,player" to remaining uses (starts at 2)
        // Mercenary specials
        let mercenaryBonusTurnUsed = { 'W': new Set(), 'B': new Set() }; // Mercenaries that have used their bonus turn this turn
        let mercenaryBonusTurnCount = { 'W': 0, 'B': 0 }; // Count of bonus turns used per game (max 3 per player)
        let mercenaryBonusTurnActive = false; // Track if we're in mercenary bonus turn mode
        let mercenaryBonusTurnPiece = null; // Track which mercenary is in bonus turn (row, col)
        // King summoning
        let pistoliersSummoned = { 'W': 0, 'B': 0 }; // Track summoned pistoliers (max 2 per player)
        let fusiliersSummoned = { 'W': 0, 'B': 0 }; // Track summoned fusiliers (max 2 per player)

        function getMaxZombies(player) {
            return 3 + Math.min(zombieConversions[player] || 0, 2);
        }

        function canChampionSummonNecromancer(player) {
            if (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme') return false;
            return (necromancersSummoned[player] || 0) < 2;
        }

        function canChampionSummonHuntsman(player) {
            if (gameVariant !== '36s-supreme') return false;
            if ((huntsmenSummoned[player] || 0) >= HUNTSMAN_SUMMON_LIMIT) return false;
            if ((huntsmenOnBoard[player] || 0) >= HUNTSMAN_MAX_ACTIVE) return false;
            return true;
        }

        function recordHuntsmanSpawn(player) {
            huntsmenSummoned[player] = (huntsmenSummoned[player] || 0) + 1;
            huntsmenOnBoard[player] = (huntsmenOnBoard[player] || 0) + 1;
        }

        function getNecromancerTeleportCount(piece) {
            if (!piece) return 0;
            return necromancerTeleportCounts.get(piece) || 0;
        }

        function incrementNecromancerTeleportCount(piece) {
            if (!piece) return;
            const used = getNecromancerTeleportCount(piece);
            necromancerTeleportCounts.set(piece, used + 1);
        }

        function setNecromancerShotCooldown(piece, turns) {
            if (!piece) return;
            if (turns > 0) {
                necromancerShootCooldown.set(piece, turns);
            } else {
                necromancerShootCooldown.delete(piece);
            }
        }

        function createZombiePiece(player) {
            return { type: 'Zombie', player, facing: player === 'W' ? 'U' : 'D' };
        }

        function createSpectrePiece(player) {
            return { type: 'Spectre', player };
        }

        function isPieceOnBoard(piece) {
            if (!piece) return false;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r] && board[r][c] === piece) {
                        return true;
                    }
                }
            }
            return false;
        }

        function cleanupNecromancerTracking(piece) {
            if (!piece) return;
            necromancerTeleportCounts.delete(piece);
            necromancerShootCooldown.delete(piece);
            if (piece.type === 'Necromancer' && necromancersSummoned[piece.player] > 0) {
                necromancersSummoned[piece.player]--;
            }
            if (piece.type === 'Zombie' && zombiesSummoned[piece.player] > 0) {
                zombiesSummoned[piece.player]--;
            }
        }

        function enqueueZombieCoinFlip(result, title, message) {
            zombieCoinQueue.push({ result, title, message });
            if (!zombieCoinAnimating) {
                processZombieCoinFlipQueue();
            }
        }

        function processZombieCoinFlipQueue() {
            if (!zombieCoinQueue.length) {
                zombieCoinAnimating = false;
                return;
            }
            zombieCoinAnimating = true;
            const { result, title, message } = zombieCoinQueue.shift();
            showZombieCoinFlipModal(result, title, message, () => {
                zombieCoinAnimating = false;
                processZombieCoinFlipQueue();
            });
        }

        function showZombieCoinFlipModal(result, title, message, done) {
            const modal = document.getElementById('coin-toss-modal');
            const coinResult = document.getElementById('coin-result');
            const titleEl = document.getElementById('coin-toss-title');
            const messageEl = document.getElementById('coin-toss-message');
            const descriptionEl = document.getElementById('coin-toss-description');
            const startBtn = document.getElementById('coin-toss-start');
            const continueBtn = document.getElementById('coin-toss-continue');

            if (!modal || !coinResult || !titleEl || !messageEl || !descriptionEl) {
                done();
                return;
            }

            if (startBtn) startBtn.style.display = 'none';
            if (continueBtn) continueBtn.style.display = 'none';

            titleEl.textContent = title || 'Coin Toss';
            messageEl.textContent = message || 'Flipping...';
            descriptionEl.textContent = 'The coin will flip to determine the outcome. White side means success, black side means failure.';

            coinResult.className = 'coin';
            coinResult.style.backgroundColor = '#666';
            coinResult.style.color = 'white';
            coinResult.textContent = '☠︎';

            modal.dataset.zombieFlip = 'true';
            modal.style.display = 'block';

            void coinResult.offsetWidth;
            coinResult.classList.add('spinning');

            const revealTimeout = setTimeout(() => {
                zombieCoinModalTimeouts = zombieCoinModalTimeouts.filter(id => id !== revealTimeout);
                coinResult.classList.remove('spinning');
                const outcomeText = result ? 'Success!' : 'Failure!';
                if (result) {
                    coinResult.classList.add('white');
                    coinResult.style.backgroundColor = 'white';
                    coinResult.style.color = 'black';
                    applyCoinFlipSuccessEffect();
                } else {
                    coinResult.classList.add('black');
                    coinResult.style.backgroundColor = 'black';
                    coinResult.style.color = 'white';
                    applyCoinFlipFailureEffect();
                }
                messageEl.textContent = message ? `${message} - ${outcomeText}` : outcomeText;

                const closeTimeout = setTimeout(() => {
                    zombieCoinModalTimeouts = zombieCoinModalTimeouts.filter(id => id !== closeTimeout);
                    if (modal.dataset.zombieFlip === 'true') {
                        modal.style.display = 'none';
                        delete modal.dataset.zombieFlip;
                    }
                    coinResult.className = 'coin';
                    coinResult.style.backgroundColor = '#666';
                    coinResult.style.color = 'white';
                    coinResult.textContent = '☠︎';
                    descriptionEl.textContent = '';
                    messageEl.textContent = '';
                    if (startBtn) startBtn.style.display = 'none';
                    if (continueBtn) continueBtn.style.display = 'none';
                    done();
                }, 1600);
                zombieCoinModalTimeouts.push(closeTimeout);
            }, 2000);
            zombieCoinModalTimeouts.push(revealTimeout);
        }

        function clearZombieCoinAnimations() {
            zombieCoinQueue = [];
            zombieCoinAnimating = false;
            while (zombieCoinModalTimeouts.length) {
                const timeoutId = zombieCoinModalTimeouts.pop();
                clearTimeout(timeoutId);
            }
            const modal = document.getElementById('coin-toss-modal');
            const coinResult = document.getElementById('coin-result');
            const messageEl = document.getElementById('coin-toss-message');
            const descriptionEl = document.getElementById('coin-toss-description');
            const startBtn = document.getElementById('coin-toss-start');
            const continueBtn = document.getElementById('coin-toss-continue');
            if (modal && modal.dataset.zombieFlip) {
                modal.style.display = 'none';
                delete modal.dataset.zombieFlip;
            }
            if (coinResult) {
                coinResult.className = 'coin';
                coinResult.style.backgroundColor = '#666';
                coinResult.style.color = 'white';
                coinResult.textContent = '☠︎';
            }
            if (descriptionEl) {
                descriptionEl.textContent = '';
            }
            if (messageEl) {
                messageEl.textContent = '';
            }
            if (startBtn) startBtn.style.display = 'none';
            if (continueBtn) continueBtn.style.display = 'none';
        }

        function zombieCoinFlip({ title = 'Zombie Coin Flip', message = '' } = {}) {
            const result = Math.random() < 0.5;
            enqueueZombieCoinFlip(result, title, message);
            return result;
        }

        function mercenaryCoinFlip(player) {
            const result = Math.random() < 0.5;
            const playerLabel = player === 'W' ? 'Player' : 'AI';
            const title = 'Mercenary Bonus Turn';
            const message = `${playerLabel} mercenary attempts bonus turn`;
            enqueueZombieCoinFlip(result, title, message);
            return result;
        }

        function randomCoinFlip() {
            return Math.random() < 0.5;
        }

        function getBackRow(player) {
            return player === 'W' ? ROWS - 1 : 0;
        }

        function getOpponentBackRow(player) {
            return player === 'W' ? 0 : ROWS - 1;
        }

        function findBackRowSpawnColumn(player, preferredCol = null) {
            const backRow = getBackRow(player);
            const columns = [];
            if (preferredCol !== null) columns.push(preferredCol);
            for (let c = 0; c < COLS; c++) {
                if (c !== preferredCol) columns.push(c);
            }
            for (const col of columns) {
                if (col >= 0 && col < COLS && !board[backRow][col]) {
                    return col;
                }
            }
            return null;
        }

        function hasBackRowSpawnSlot(player) {
            return findBackRowSpawnColumn(player) !== null;
        }

        function spawnZombieAtBackRow(player, preferredCol = null) {
            const spawnCol = findBackRowSpawnColumn(player, preferredCol);
            if (spawnCol === null) return false;
            const backRow = getBackRow(player);
            const zombie = createZombiePiece(player);
            board[backRow][spawnCol] = zombie;
            zombiesSummoned[player] = (zombiesSummoned[player] || 0) + 1;
            gameLog.push(`${player === 'W' ? 'Player' : 'AI'} zombie spawned at (${backRow},${spawnCol}).`);
            return true;
        }

        function awardZombieBonus(player, reason) {
            scores[player] += 3;
            registerScoreGain(player, 3);
            gameLog.push(`${player === 'W' ? 'Player' : 'AI'} gained +3 points (${reason}).`);
        }

        function capturePieceForZombie(player, row, col, targetPiece) {
            cleanupNecromancerTracking(targetPiece);
            capturedSquares.push([row, col]);
            capturedPieces[player].push(targetPiece);
            const captureValue = pieceValues[targetPiece.type] || 0;
            scores[player] += captureValue;
            registerScoreGain(player, captureValue);
            registerPieceLoss(targetPiece.player, targetPiece.type);
            trackCapture(player); // Track capture for statistics
            if (targetPiece.type === 'Champion') {
                championCaptured[targetPiece.player] = true;
            }
            if (targetPiece.type === 'King') {
                endGame(player);
                return;
            }
            board[row][col] = null;
        }

        function handleZombieReachedOpponentBackRow(player, row, col) {
            const opponentBackRow = getOpponentBackRow(player);
            if (row !== opponentBackRow) return false;
            const zombie = board[row][col];
            if (!zombie || zombie.type !== 'Zombie') return false;
            cleanupNecromancerTracking(zombie);
            board[row][col] = null;
            awardZombieBonus(player, 'Zombie reached opponent back row');
            const spawnSuccess = spawnZombieAtBackRow(player, col);
            if (!spawnSuccess) {
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} zombie could not respawn due to lack of space.`);
            }
            return true;
        }

        function moveZombieTo(fromRow, fromCol, toRow, toCol, player) {
            const zombie = board[fromRow][fromCol];
            board[toRow][toCol] = zombie;
            board[fromRow][fromCol] = null;
            handleZombieReachedOpponentBackRow(player, toRow, toCol);
        }

        function attemptZombieCapture(fromRow, fromCol, targetRow, targetCol, player) {
            const zombie = board[fromRow][fromCol];
            const targetPiece = board[targetRow]?.[targetCol];
            if (!targetPiece) {
                moveZombieTo(fromRow, fromCol, targetRow, targetCol, player);
                return 'moved';
            }
            const playerLabel = player === 'W' ? 'Player' : 'AI';
            if (targetPiece.type === 'Zombie') {
                const success = zombieCoinFlip({
                    title: 'Zombie Clash',
                    message: `${playerLabel} zombie challenges opposing Zombie.`
                });
                if (success) {
                    cleanupNecromancerTracking(targetPiece);
                    board[targetRow][targetCol] = null;
                    const spawnSuccess = zombieConversions[player] < 2 && spawnZombieAtBackRow(player);
                    if (spawnSuccess) {
                        zombieConversions[player]++;
                        gameLog.push(`${playerLabel} converted an opposing Zombie into their ranks.`);
                    } else if (zombieConversions[player] < 2) {
                        gameLog.push(`${playerLabel} destroyed an opposing Zombie but had no space to convert it.`);
                    } else {
                        gameLog.push(`${playerLabel} destroyed an opposing Zombie (conversion limit reached).`);
                    }
                    moveZombieTo(fromRow, fromCol, targetRow, targetCol, player);
                    return 'moved';
                } else {
                    cleanupNecromancerTracking(zombie);
                    board[fromRow][fromCol] = null;
                    gameLog.push(`${playerLabel} zombie lost the clash against an opposing Zombie at (${targetRow},${targetCol}).`);
                    return 'removed';
                }
            }
            const success = zombieCoinFlip({
                title: 'Zombie Capture',
                message: `${playerLabel} zombie attacks ${targetPiece.type}.`
            });
            if (success) {
                capturePieceForZombie(player, targetRow, targetCol, targetPiece);
                moveZombieTo(fromRow, fromCol, targetRow, targetCol, player);
                return 'moved';
            } else {
                gameLog.push(`${playerLabel} zombie failed to capture ${targetPiece.type} at (${targetRow},${targetCol}).`);
                return 'stay';
            }
        }

        function handleZombieCaptureAttempt(attackerPiece, fromRow, fromCol, targetRow, targetCol, options = {}) {
            const targetPiece = board[targetRow]?.[targetCol];
            if (!targetPiece || targetPiece.type !== 'Zombie') {
                return { handled: false };
            }
            if (attackerPiece.type === 'Elephantry') {
                gameLog.push(`${attackerPiece.player === 'W' ? 'Player' : 'AI'} Elephantry cannot capture Zombies by landing.`);
                return { handled: true, success: false, attackerRemoved: false };
            }
            if (attackerPiece.type === 'Huntsman') {
                cleanupNecromancerTracking(targetPiece);
                board[targetRow][targetCol] = null;
                capturedSquares.push([targetRow, targetCol]);
                capturedPieces[attackerPiece.player].push(targetPiece);
                const captureValue = pieceValues[targetPiece.type] || 0;
                scores[attackerPiece.player] += captureValue;
                registerScoreGain(attackerPiece.player, captureValue);
                registerPieceLoss(targetPiece.player, targetPiece.type);
                trackCapture(attackerPiece.player);
                gameLog.push(`${attackerPiece.player === 'W' ? 'Player' : 'AI'} Huntsman effortlessly captured Zombie at (${targetRow},${targetCol}).`);
                updateScoreDisplay();
                updateCapturedPiecesDisplay();
                updateGameLog();
                return { handled: true, success: true };
            }
            const attackerLabel = attackerPiece.player === 'W' ? 'Player' : 'AI';
            const zombieOwner = targetPiece.player;
            const viaRanged = options.ranged;
            const attemptVerb = viaRanged ? 'shoot' : 'capture';
            const successVerb = viaRanged ? 'shot' : 'captured';
            const success = zombieCoinFlip({
                title: 'Zombie Defense',
                message: `${attackerLabel} ${viaRanged ? 'shoots at' : 'attacks'} Zombie.`
            });
            if (success) {
                cleanupNecromancerTracking(targetPiece);
                board[targetRow][targetCol] = null;
                capturedSquares.push([targetRow, targetCol]);
                capturedPieces[attackerPiece.player].push(targetPiece);
                const captureValue = pieceValues[targetPiece.type] || 0;
                scores[attackerPiece.player] += captureValue;
                registerScoreGain(attackerPiece.player, captureValue);
                registerPieceLoss(zombieOwner, targetPiece.type);
                trackCapture(attackerPiece.player); // Track capture for statistics
                gameLog.push(`${attackerLabel} ${successVerb} Zombie at (${targetRow},${targetCol}) after winning the coin flip.`);
                return { handled: true, success: true };
            } else {
                // For ranged/shooting attacks, the attacker stays on the board
                if (viaRanged) {
                    gameLog.push(`${attackerLabel} failed to ${attemptVerb} Zombie at (${targetRow},${targetCol}). The shot missed and the attacker remains safe.`);
                    return { handled: true, success: false, attackerRemoved: false };
                } else {
                    // For landing captures, the attacker is captured by the zombie
                    board[fromRow][fromCol] = null;
                    cleanupNecromancerTracking(attackerPiece);
                    capturedSquares.push([fromRow, fromCol]);
                    capturedPieces[zombieOwner].push(attackerPiece);
                    registerPieceLoss(attackerPiece.player, attackerPiece.type);
                    scores[zombieOwner] += 3;
                    registerScoreGain(zombieOwner, 3);
                    trackCapture(zombieOwner); // Track capture for statistics
                    gameLog.push(`${attackerLabel} failed to ${attemptVerb} Zombie at (${targetRow},${targetCol}) and was lost in the attempt. (+3 bonus to ${zombieOwner === 'W' ? 'Player' : 'AI'})`);
                    renderBoard();
                    updateScoreDisplay();
                    updateCapturedPiecesDisplay();
                    updateGameLog();
                    return { handled: true, success: false, attackerRemoved: true };
                }
            }
        }

        function advanceZombieFromPosition(row, col, player) {
            const zombie = board[row][col];
            if (!zombie || zombie.type !== 'Zombie' || zombie.player !== player) return false;
            const direction = player === 'W' ? -1 : 1;
            if (handleZombieReachedOpponentBackRow(player, row, col)) {
                return true;
            }
            const forwardRow = row + direction;
            if (!isValid(forwardRow, col)) {
                if (handleZombieReachedOpponentBackRow(player, row, col)) {
                    return true;
                }
                return false;
            }
            const forwardPiece = board[forwardRow][col];
            if (!forwardPiece) {
                moveZombieTo(row, col, forwardRow, col, player);
                return true;
            }
            if (forwardPiece.player !== player) {
                const result = attemptZombieCapture(row, col, forwardRow, col, player);
                return result === 'moved' || result === 'removed';
            }
            const diagonals = [col - 1, col + 1];
            for (const diagCol of diagonals) {
                if (!isValid(forwardRow, diagCol)) continue;
                const diagPiece = board[forwardRow][diagCol];
                if (!diagPiece) {
                    moveZombieTo(row, col, forwardRow, diagCol, player);
                    return true;
                }
                if (diagPiece.player !== player) {
                    const result = attemptZombieCapture(row, col, forwardRow, diagCol, player);
                    if (result === 'moved' || result === 'removed') {
                        return true;
                    }
                }
            }
            return false;
        }

        function advanceZombiesForPlayer(player, onComplete = null) {
            if (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme') {
                if (typeof onComplete === 'function') {
                    onComplete();
                }
                return false;
            }
            const positions = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece && piece.type === 'Zombie' && piece.player === player) {
                        positions.push({ row: r, col: c });
                    }
                }
            }
            if (!positions.length) {
                if (typeof onComplete === 'function') {
                    onComplete();
                }
                return false;
            }
            if (zombieAutoAdvanceInProgress) {
                zombiePendingAdvanceQueue.push({ player, onComplete });
                return true;
            }
            positions.sort((a, b) => {
                if (a.col !== b.col) {
                    return a.col - b.col;
                }
                return player === 'W' ? a.row - b.row : b.row - a.row;
            });
            if (zombieAdvanceTimer) {
                clearTimeout(zombieAdvanceTimer);
                zombieAdvanceTimer = null;
            }
            zombieAutoAdvanceInProgress = true;
            let pendingUpdate = false;
            const completeAdvance = () => {
                if (zombieAdvanceTimer) {
                    clearTimeout(zombieAdvanceTimer);
                    zombieAdvanceTimer = null;
                }
                zombieAutoAdvanceInProgress = false;
                if (pendingUpdate) {
                    renderBoard();
                    updateScoreDisplay();
                    updateCapturedPiecesDisplay();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                }
                if (typeof onComplete === 'function') {
                    onComplete();
                }
                if (zombiePendingAdvanceQueue.length) {
                    const nextRequest = zombiePendingAdvanceQueue.shift();
                    zombieAdvanceTimer = setTimeout(() => advanceZombiesForPlayer(nextRequest.player, nextRequest.onComplete), 200);
                }
            };
            const processNextZombie = () => {
                if (!positions.length) {
                    completeAdvance();
                    return;
                }
                const pos = positions.shift();
                const piece = board[pos.row]?.[pos.col];
                if (!piece || piece.type !== 'Zombie' || piece.player !== player) {
                    processNextZombie();
                    return;
                }
                const moved = advanceZombieFromPosition(pos.row, pos.col, player);
                if (moved) {
                    pendingUpdate = true;
                    renderBoard();
                    updateScoreDisplay();
                    updateCapturedPiecesDisplay();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                }
                zombieAdvanceTimer = setTimeout(processNextZombie, 280);
            };
            processNextZombie();
            return true;
        }

        function decrementNecromancerCooldown(player) {
            necromancerShootCooldown.forEach((turns, piece) => {
                if (!isPieceOnBoard(piece)) {
                    cleanupNecromancerTracking(piece);
                    return;
                }
                if (piece.player === player && turns > 0) {
                    const next = turns - 1;
                    if (next <= 0) {
                        necromancerShootCooldown.delete(piece);
                    } else {
                        necromancerShootCooldown.set(piece, next);
                    }
                }
            });
            necromancerTeleportCounts.forEach((_, piece) => {
                if (!isPieceOnBoard(piece)) {
                    cleanupNecromancerTracking(piece);
                }
            });
        }
        
        // AI Difficulty
        let aiDifficulty = 'Medium';
        let baseAiDepth = 44; // Track difficulty selection (defaults to Medium, increased by 80% intelligence + 30% general difficulty: 19 * 1.8 * 1.3)
        let aiMaxDepth = 44; // Effective depth after variant adjustments - allows AI to plan 3+ moves ahead
        let pieceValueScale = 11.74238208; // Defaults to Medium (increased by 80% intelligence + 30% general difficulty: 5.018112 * 1.8 * 1.3)

        // Opponent Selection
        let selectedOpponent = 'Random'; // Default to random selection

        // Hint System
        let hintModeEnabled = false; // Default to off
        const AI_LEFTOVER_PENALTY = 0.75;
        const AI_TIE_EPSILON = 0.0001;
        const AI_TIME_LIMIT_DEFAULT = 3600; // Increased to 3600ms to support deeper search and 3+ move planning (tripled from 1200ms)
        const AI_TIME_LIMIT_LARGE = 1200; // Increased to 1200ms for large boards to support deeper search (tripled from 400ms)

        // AI Player Profiles - Different strategies and play styles (invisible to player)
        const AI_PROFILES = {
            'Berserker': {
                name: 'Berserker',
                displayName: 'Ragnar the Berserker',
                description: 'Hyper-aggressive attacker, prioritizes captures above all else',
                threatWeight: 1.8,           // Heavily values threatening enemy pieces
                mobilityWeight: 0.25,        // Lower mobility concern
                centerWeight: 0.15,          // Lower center control concern
                captureBonus: 1.4,           // +40% bonus to capture values
                specialAbilityBonus: 1.3,    // +30% bonus to special abilities
                aggressionLevel: 1.5         // Highly aggressive
            },
            'Guardian': {
                name: 'Guardian',
                displayName: 'Thorne the Guardian',
                description: 'Defensive player, focuses on piece preservation and center control',
                threatWeight: 0.6,           // Lower threat priority
                mobilityWeight: 0.7,         // Values having options
                centerWeight: 0.6,           // Strongly values center control
                captureBonus: 0.8,           // -20% capture bonus (more cautious)
                specialAbilityBonus: 0.9,    // -10% special ability usage
                aggressionLevel: 0.6         // Defensive playstyle
            },
            'Tactician': {
                name: 'Tactician',
                displayName: 'Astra the Tactician',
                description: 'Balanced strategist, adapts to board position',
                threatWeight: 1.0,           // Balanced threat evaluation
                mobilityWeight: 0.55,        // Moderate mobility value
                centerWeight: 0.35,          // Moderate center control
                captureBonus: 1.0,           // Normal capture values
                specialAbilityBonus: 1.1,    // Slightly favors special abilities
                aggressionLevel: 1.0         // Balanced approach
            },
            'Sorcerer': {
                name: 'Sorcerer',
                displayName: 'Zephyr the Sorcerer',
                description: 'Special ability specialist, maximizes use of unique powers',
                threatWeight: 0.85,          // Moderate threat focus
                mobilityWeight: 0.6,         // Values positioning for abilities
                centerWeight: 0.25,          // Lower center concern
                captureBonus: 0.95,          // Slightly lower capture priority
                specialAbilityBonus: 1.7,    // +70% bonus to special abilities
                aggressionLevel: 1.1         // Slightly aggressive
            },
            'Nomad': {
                name: 'Nomad',
                displayName: 'Kira the Nomad',
                description: 'Mobility-focused player, constantly repositioning for advantage',
                threatWeight: 0.75,          // Lower direct threat focus
                mobilityWeight: 0.85,        // Highly values movement options
                centerWeight: 0.4,           // Moderate center value
                captureBonus: 0.9,           // Slightly cautious on captures
                specialAbilityBonus: 1.0,    // Normal special ability usage
                aggressionLevel: 0.85        // Moderately cautious, prefers mobility
            }
        };

        let lastRandomAiProfileName = null;

        function getRandomInt(max) {
            if (max <= 0) return 0;
            if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
                const array = new Uint32Array(1);
                crypto.getRandomValues(array);
                return array[0] % max;
            }
            return Math.floor(Math.random() * max);
        }

        function chooseRandomAiProfileName() {
            const profileNames = Object.keys(AI_PROFILES);
            if (!profileNames.length) return null;
            let index = getRandomInt(profileNames.length);
            let candidate = profileNames[index];
            if (profileNames.length > 1 && candidate === lastRandomAiProfileName) {
                const offset = 1 + getRandomInt(profileNames.length - 1);
                candidate = profileNames[(index + offset) % profileNames.length];
            }
            lastRandomAiProfileName = candidate;
            return candidate;
        }

        // Current AI profile (selected randomly at game start)
        let currentAiProfile = null;
        const LARGE_BOARD_VARIANTS = ['36s', '36s-expert', '36s-elite', '36s-supreme'];
        let aiSearchDeadline = 0;
        function aiTimeExpired() {
            return aiSearchDeadline && Date.now() >= aiSearchDeadline;
        }

        const pieceIcons = {
            'Cavalry': 'C', 'Troll': 'T', 'Dragon': 'D', 'Wizard': 'W', 'Guard': 'G',
            'King': 'K', 'Champion': '✠', 'Infantry': 'I', 'Archer': 'A', 'Ballista': 'B',
            'Elephantry': 'E', 'Mercenary': 'M', 'Ogre': 'O', 'Spectre': 'S', 'Pistolier': 'P', 'Fusilier': 'F'
        };
        pieceIcons['Necromancer'] = 'N';
        pieceIcons['Zombie'] = 'Z';
        pieceIcons['Huntsman'] = 'H';
        const facingIcons = {
            'U': '^', 'D': 'v', 'L': '<', 'R': '>'
        };
        const basePieceValues = {
            'Infantry': 1, 'Archer': 2, 'Cavalry': 3, 'Pistolier': 3, 'Fusilier': 4, 'Guard': 4, 'Ballista': 5,
            'Troll': 6, 'Dragon': 7, 'Ogre': 8, 'Wizard': 9, 'Spectre': 5, 'Mercenary': 3,
            'Elephantry': 11, 'Champion': 12, 'King': 13
        };
        basePieceValues['Necromancer'] = 10;
        basePieceValues['Zombie'] = 3;
        basePieceValues['Huntsman'] = 6;
        const pieceValues = basePieceValues;
        let aiPieceValues = { ...basePieceValues };

        function isLargeBoardVariant() {
            return LARGE_BOARD_VARIANTS.includes(gameVariant);
        }

        function getAiTimeBudget() {
            let base = isLargeBoardVariant() ? AI_TIME_LIMIT_LARGE : AI_TIME_LIMIT_DEFAULT;
            if (aiDifficulty === 'Hard') {
                base += isLargeBoardVariant() ? 600 : 1800; // Increased for depth 65 planning: allows extensive multi-move lookahead
            } else if (aiDifficulty === 'Medium') {
                base += isLargeBoardVariant() ? 400 : 1200; // Increased for depth 44 planning: allows significant multi-move lookahead
            } else if (aiDifficulty === 'Easy') {
                base += isLargeBoardVariant() ? 200 : 600; // Increased for depth 25 planning: allows 3+ move lookahead
            }
            return base;
        }

        const GAME_TIME_OPTIONS = {
            quick: 10 * 60,
            standard: 30 * 60,
            long: 60 * 60
        };
        const TURN_TIME_OPTIONS = {
            blitz: 30,
            standard: 60
        };
        let selectedGameTimerKey = 'standard';
        let selectedTurnTimerKey = 'standard';
        let gameTimeRemaining = GAME_TIME_OPTIONS[selectedGameTimerKey];
        let gameTimerInterval = null;
        let turnTimerInterval = null;
        let playerTurnTimeRemaining = TURN_TIME_OPTIONS[selectedTurnTimerKey];
        let aiTurnTimeRemaining = TURN_TIME_OPTIONS[selectedTurnTimerKey];
        let currentTurnTimerPlayer = null;
        let aiTurnTimeoutForced = false;
        let roundCount = 1; // Initialize round counter early for timer display
        let playerRoundNumber = 0; // Track player's round count (for first 2 rounds features)
        let aiRoundNumber = 0; // Track AI's round count (for first 2 rounds features)
        let gameRound = 1; // Track game rounds (both players taking 1 round = 1 complete round)
        let firstPlayer = null; // Track who went first to properly count rounds

        const HONOUR_THRESHOLD = 10;
        const HONOUR_BONUS = 2;
        const DESPAIR_PENALTY = 2;
        const DESPAIR_EXCLUDED = new Set(['Mercenary', 'Infantry', 'Archer']);
        const RELENTLESS_THRESHOLD = 3;
        const MORAL_BOOST_LIMIT = 2;
        const MORAL_BOOST_BONUS = 2;
        const KING_SHOT_RANGE = 3;
        const KING_EVADE_RANGE = 2;
        const KING_SHOT_AI_THRESHOLD = 5; // Minimum target value before AI considers King Shot
        const KING_EVADE_CAPTURE_BONUS = 6; // Weight applied to captured piece value when evading
        const KING_EVADE_DISTANCE_BONUS = 1; // Small reward for creating distance while evading
        const WARCRY_POPUP_DELAY_MS = 200; // Base delay before showing warcry popup
        const CAPTURE_EFFECT_SETTLE_MS = 2000; // Allow capture animation to finish before warcry popup
        const BOARD_ANCHORED_MODAL_IDS = [
            'modal-overlay',
            'reinforce-modal',
            'king-summon-modal',
            'spell-direction-modal',
            'protection-modal',
            'turn-modal',
            'turn-move-modal',
            'turn-shoot-modal',
            'how-to-play-modal',
            'truce-modal',
            'coin-toss-modal',
            'warcry-achievement-modal',
            'energy-blast-popup'
        ];
        let boardModalObservers = [];
        let boardAnchorUpdateScheduled = false;
        let boardResizeObserver = null;

        let roundScoreGain = { 'W': 0, 'B': 0 };
        let roundLosses = { 'W': {}, 'B': {} };
        let nextRoundModifier = { 'W': 0, 'B': 0 };
        let warcryAchievedThisRound = { 'W': false, 'B': false };
        let pendingWarcryCelebrations = [];
        let warcryPopupTimeoutId = null;
        let captureEffectActiveUntil = 0;
        let reinforcementTotals = { 'W': 0, 'B': 0 };
        let infantryReinforcements = { 'W': 0, 'B': 0 };

        function getBoardAnchorRect() {
            const boardElement = document.getElementById('board');
            if (!boardElement) return null;
            const rect = boardElement.getBoundingClientRect();
            const scrollX = window.scrollX || window.pageXOffset || 0;
            const scrollY = window.scrollY || window.pageYOffset || 0;
            return {
                left: rect.left + scrollX,
                top: rect.top + scrollY,
                width: rect.width,
                height: rect.height,
                centerX: rect.left + scrollX + rect.width / 2,
                centerY: rect.top + scrollY + rect.height / 2
            };
        }

        function updateBoardAnchoredElements() {
            const anchor = getBoardAnchorRect();
            if (!anchor) {
                updateSidePanelScrollLimits(null);
                return;
            }
            BOARD_ANCHORED_MODAL_IDS.forEach(id => {
                const el = document.getElementById(id);
                if (!el || getComputedStyle(el).display === 'none') {
                    return;
                }
                if (id === 'modal-overlay') {
                    el.style.left = `${anchor.left}px`;
                    el.style.top = `${anchor.top}px`;
                    el.style.width = `${anchor.width}px`;
                    el.style.height = `${anchor.height}px`;
                } else {
                    el.style.left = `${anchor.centerX}px`;
                    el.style.top = `${anchor.centerY}px`;
                    el.style.transform = 'translate(-50%, -50%)';
                }
            });
            updateSidePanelScrollLimits(anchor);
            constrainSidePanelsToBoard(anchor);
        }

        function scheduleBoardAnchorUpdate() {
            if (boardAnchorUpdateScheduled) return;
            boardAnchorUpdateScheduled = true;
            requestAnimationFrame(() => {
                boardAnchorUpdateScheduled = false;
                updateBoardAnchoredElements();
            });
        }

        function initializeBoardAnchoredModals() {
            const boardElement = document.getElementById('board');
            if (typeof ResizeObserver !== 'undefined' && boardElement) {
                boardResizeObserver = new ResizeObserver(() => scheduleBoardAnchorUpdate());
                boardResizeObserver.observe(boardElement);
            }
            window.addEventListener('scroll', () => scheduleBoardAnchorUpdate());
            window.addEventListener('resize', () => scheduleBoardAnchorUpdate());
            if (typeof MutationObserver !== 'undefined') {
                BOARD_ANCHORED_MODAL_IDS.forEach(id => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    const observer = new MutationObserver(() => scheduleBoardAnchorUpdate());
                    observer.observe(el, { attributes: true, attributeFilter: ['style', 'class'] });
                    boardModalObservers.push(observer);
                });
            }
            scheduleBoardAnchorUpdate();
        }

        function updateSidePanelScrollLimits(anchorRect) {
            const root = document.documentElement;
            if (anchorRect) {
                root.style.setProperty('--board-panel-max-height', `${anchorRect.height}px`);
            } else {
                root.style.removeProperty('--board-panel-max-height');
            }
        }

        function constrainSidePanelsToBoard(anchorRect) {
            ['info-box', 'captured-pieces'].forEach(id => {
                const element = document.getElementById(id);
                constrainElementToBoardBounds(element, anchorRect);
            });
        }

        function constrainElementToBoardBounds(element, anchorRect) {
            if (!element || !anchorRect) return;
            const style = window.getComputedStyle(element);
            if (style.display === 'none') return;
            const rect = element.getBoundingClientRect();
            const scrollY = window.scrollY || window.pageYOffset || 0;
            const elementTop = rect.top + scrollY;
            const available = anchorRect.top + anchorRect.height - elementTop - 10;
            if (available >= 0) {
                element.style.maxHeight = `${available}px`;
            } else {
                element.style.maxHeight = '0px';
            }
        }

        // Game statistics tracking
        let gameStats = {
            warcryBonusCount: { 'W': 0, 'B': 0 },
            despairPenaltyCount: { 'W': 0, 'B': 0 },
            gameStartTime: null,
            gameDuration: 0,
            // New statistics for end game display
            capturesThisRound: { 'W': 0, 'B': 0 },
            mostCapturesInRound: { 'W': 0, 'B': 0 },
            scoreThisRound: { 'W': 0, 'B': 0 },
            highestScoreInRound: { 'W': 0, 'B': 0 },
            summonCount: { 'W': 0, 'B': 0 },
            reinforcementCount: { 'W': 0, 'B': 0 }
        };

        // Helper functions for tracking statistics
        function trackCapture(player) {
            gameStats.capturesThisRound[player]++;
        }

        function trackScore(player, scoreGain) {
            gameStats.scoreThisRound[player] += scoreGain;
        }

        function updateRoundStats(player) {
            // Update max captures if this round had more
            if (gameStats.capturesThisRound[player] > gameStats.mostCapturesInRound[player]) {
                gameStats.mostCapturesInRound[player] = gameStats.capturesThisRound[player];
            }
            // Update max score if this round had more
            if (gameStats.scoreThisRound[player] > gameStats.highestScoreInRound[player]) {
                gameStats.highestScoreInRound[player] = gameStats.scoreThisRound[player];
            }
            // Reset for next round
            gameStats.capturesThisRound[player] = 0;
            gameStats.scoreThisRound[player] = 0;
        }

        function updateAiPieceValues() {
            aiPieceValues = Object.fromEntries(Object.entries(basePieceValues).map(([k, v]) => [k, Math.round(v * pieceValueScale)]));
        }

        updateAiPieceValues();
        function setGameTimer(option, element) {
            selectedGameTimerKey = option;
            gameTimeRemaining = GAME_TIME_OPTIONS[selectedGameTimerKey];
            const buttons = document.querySelectorAll('#game-timer-selector button');
            buttons.forEach(btn => btn.classList.remove('selected-option'));
            if (element) {
                element.classList.add('selected-option');
            }
            updateTimerDisplay();
        }

        function setTurnTimer(option, element) {
            selectedTurnTimerKey = option;
            const duration = TURN_TIME_OPTIONS[selectedTurnTimerKey];
            playerTurnTimeRemaining = duration;
            aiTurnTimeRemaining = duration;
            const buttons = document.querySelectorAll('#turn-timer-selector button');
            buttons.forEach(btn => btn.classList.remove('selected-option'));
            if (element) {
                element.classList.add('selected-option');
            }
            updateTimerDisplay();
        }

        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTimerDisplay() {
            const gameTimerRow = document.getElementById('game-timer-row');
            const playerTimerRow = document.getElementById('player-timer-row');
            const aiTimerRow = document.getElementById('ai-timer-row');
            const roundDisplay = document.getElementById('round-number-display');
            const board = document.getElementById('board');
            const opponentLabel = getOpponentDisplayName();

            if (gameTimerRow) {
                gameTimerRow.textContent = `Game Time: ${formatTime(Math.max(0, gameTimeRemaining))}`;
            }
            if (roundDisplay) {
                roundDisplay.textContent = `Round ${roundCount}`;
            }

            // Update player timer with warning color
            if (playerTimerRow) {
                playerTimerRow.textContent = `Player Time: ${formatTime(Math.max(0, playerTurnTimeRemaining))}`;
                if (playerTurnTimeRemaining <= 10 && playerTurnTimeRemaining > 0 && currentTurnTimerPlayer === 'W') {
                    playerTimerRow.classList.add('low-time');
                } else {
                    playerTimerRow.classList.remove('low-time');
                }
            }

            // Update AI timer with warning color
            if (aiTimerRow) {
                aiTimerRow.textContent = `${opponentLabel} Time: ${formatTime(Math.max(0, aiTurnTimeRemaining))}`;
                if (aiTurnTimeRemaining <= 10 && aiTurnTimeRemaining > 0 && currentTurnTimerPlayer === 'B') {
                    aiTimerRow.classList.add('low-time');
                } else {
                    aiTimerRow.classList.remove('low-time');
                }
            }

            // Update board border color based on active timer
            if (board) {
                const isPlayerTimerLow = playerTurnTimeRemaining <= 10 && playerTurnTimeRemaining > 0 && currentTurnTimerPlayer === 'W';
                const isAiTimerLow = aiTurnTimeRemaining <= 10 && aiTurnTimeRemaining > 0 && currentTurnTimerPlayer === 'B';

                if (isPlayerTimerLow || isAiTimerLow) {
                    board.classList.add('low-time');
                } else {
                    board.classList.remove('low-time');
                }
            }
        }

        function stopGameTimer() {
            if (gameTimerInterval) {
                clearInterval(gameTimerInterval);
                gameTimerInterval = null;
            }
        }

        function startGameTimer() {
            stopGameTimer();
            // Record game start time
            if (gameStats.gameStartTime === null) {
                gameStats.gameStartTime = Date.now();
            }
            gameTimerInterval = setInterval(() => {
                if (gameTimeRemaining > 0) {
                    gameTimeRemaining -= 1;
                    updateTimerDisplay();
                    if (gameTimeRemaining <= 0) {
                        gameTimeRemaining = 0;
                        updateTimerDisplay();
                        stopGameTimer();
                        handleGameTimerExpired();
                    }
                }
            }, 1000);
        }

        function handleGameTimerExpired() {
            gameLog.push('Game timer expired.');
            updateGameLog();
            stopTurnTimer();
            const playerScore = scores['W'];
            const aiScore = scores['B'];
            if (playerScore > aiScore) {
                endGame('W', 'Game timer expired.');
            } else if (aiScore > playerScore) {
                endGame('B', 'Game timer expired.');
            } else {
                endGame('draw', 'Game timer expired.');
            }
        }

        function stopTurnTimer() {
            if (turnTimerInterval) {
                clearInterval(turnTimerInterval);
                turnTimerInterval = null;
            }
            currentTurnTimerPlayer = null;
        }

        function startTurnTimer(player, options = {}) {
            const { reset = true } = options;
            stopTurnTimer();
            currentTurnTimerPlayer = player;
            if (reset) {
                const duration = TURN_TIME_OPTIONS[selectedTurnTimerKey];
                if (player === 'W') {
                    playerTurnTimeRemaining = duration;
                } else {
                    aiTurnTimeRemaining = duration;
                }
            } else {
                const remaining = player === 'W' ? playerTurnTimeRemaining : aiTurnTimeRemaining;
                if (!remaining || remaining <= 0) {
                    currentTurnTimerPlayer = null;
                    return;
                }
            }
            updateTimerDisplay();
            turnTimerInterval = setInterval(() => {
                if (currentTurnTimerPlayer === 'W') {
                    playerTurnTimeRemaining = Math.max(0, playerTurnTimeRemaining - 1);
                    updateTimerDisplay();
                    if (playerTurnTimeRemaining === 0) {
                        stopTurnTimer();
                        handleTurnTimeout('W');
                    }
                } else if (currentTurnTimerPlayer === 'B') {
                    aiTurnTimeRemaining = Math.max(0, aiTurnTimeRemaining - 1);
                    updateTimerDisplay();
                    if (aiTurnTimeRemaining === 0) {
                        stopTurnTimer();
                        handleTurnTimeout('B');
                    }
                }
            }, 1000);
        }

        function handleTurnTimeout(player) {
            if (player === 'W') {
                playerTurnTimeRemaining = 0;
            } else {
                aiTurnTimeRemaining = 0;
            }
            updateTimerDisplay();
            if (player === 'W') {
                gameLog.push('Player round timer expired. Round forfeited.');
                cancelSpecialModes();
                if (reinforcementPending && reinforcementPending.player === 'W') {
                    reinforcementPending = null;
                    const modal = document.getElementById('reinforce-modal');
                    if (modal) modal.style.display = 'none';
                }
                movesLeft = 0;
                updateGameLog();
                updateStatus();
                updateEndTurnButton();
                triggerAiTurn();
            } else {
                aiTurnTimeoutForced = true;
                movesLeft = 0;
                completeAiTurn({ reason: 'AI round timer expired. Player resumes round.' });
            }
        }

        updateTimerDisplay();

        function getOpponent(player) {
            return player === 'W' ? 'B' : 'W';
        }

        function isAiPlayer(player) {
            return player === 'B';
        }

        function registerScoreGain(player, amount) {
            const previousScore = roundScoreGain[player] || 0;
            roundScoreGain[player] = previousScore + amount;
            const newScore = roundScoreGain[player];

            // Track score for statistics
            trackScore(player, amount);

            // Check if warcry threshold was just reached
            if (previousScore < HONOUR_THRESHOLD && newScore >= HONOUR_THRESHOLD && !warcryAchievedThisRound[player]) {
                warcryAchievedThisRound[player] = true;
                queueWarcryCelebration(player);
            }
        }

        function queueWarcryCelebration(player) {
            pendingWarcryCelebrations.push(player);
            if (pendingWarcryCelebrations.length === 1) {
                scheduleNextWarcryPopup();
            }
        }

        function scheduleNextWarcryPopup() {
            if (!pendingWarcryCelebrations.length) {
                if (warcryPopupTimeoutId) {
                    clearTimeout(warcryPopupTimeoutId);
                    warcryPopupTimeoutId = null;
                }
                return;
            }
            if (warcryPopupTimeoutId) {
                clearTimeout(warcryPopupTimeoutId);
            }
            const now = Date.now();
            const captureDelay = Math.max(0, captureEffectActiveUntil - now);
            const delay = Math.max(WARCRY_POPUP_DELAY_MS, captureDelay);
            warcryPopupTimeoutId = setTimeout(() => {
                warcryPopupTimeoutId = null;
                const nextPlayer = pendingWarcryCelebrations.shift();
                if (nextPlayer === undefined) {
                    scheduleNextWarcryPopup();
                    return;
                }
                if (captureEffectActiveUntil > Date.now()) {
                    pendingWarcryCelebrations.unshift(nextPlayer);
                    scheduleNextWarcryPopup();
                    return;
                }
                showWarcryAchievementPopup(nextPlayer);
                if (pendingWarcryCelebrations.length) {
                    scheduleNextWarcryPopup();
                }
            }, delay);
        }

        function registerPieceLoss(player, type) {
            if (type === 'Huntsman') {
                huntsmenOnBoard[player] = Math.max(0, (huntsmenOnBoard[player] || 0) - 1);
            }
            if (DESPAIR_EXCLUDED.has(type)) return;
            if (!roundLosses[player]) roundLosses[player] = {};
            roundLosses[player][type] = (roundLosses[player][type] || 0) + 1;
        }

        function registerReinforcement(player, type) {
            reinforcementTotals[player] = (reinforcementTotals[player] || 0) + 1;
            gameStats.reinforcementCount[player]++; // Track reinforcement for statistics
            if (type !== 'Infantry') {
                return false;
            }
            infantryReinforcements[player] = (infantryReinforcements[player] || 0) + 1;
            const opponent = getOpponent(player);
            if (infantryReinforcements[player] >= RELENTLESS_THRESHOLD && (reinforcementTotals[opponent] || 0) === 0) {
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} achieved Relentless victory!`);
                updateGameLog();
                endGame(player, 'Relentless');
                return true;
            }
            return false;
        }

        function isSupremacyPosition(player) {
            const opponentBackRow = player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);
            if (championsOnBackRow[player] && championsOnBackRow[player].some(([r]) => r === opponentBackRow)) {
                return true;
            }
            for (let c = 0; c < COLS; c++) {
                if (board[opponentBackRow] && board[opponentBackRow][c] && board[opponentBackRow][c].player === player && board[opponentBackRow][c].type === 'King') {
                    return true;
                }
            }
            return false;
        }

        function checkSupremacy(player) {
            const opponent = getOpponent(player);
            if (!championCaptured[opponent]) return;
            if (scores[opponent] > 1) return;
            if (!isSupremacyPosition(player)) return;
            gameLog.push(`${player === 'W' ? 'Player' : 'AI'} achieved Supremacy victory!`);
            updateGameLog();
            endGame(player);
        }

        const pieceInfo = {
            'Archer': {
                points: '1 point to move 1 square vertically/horizontally, shoot 2 squares in facing direction, or turn; 2 points to turn+shoot or use a special.',
                extra: 'Specials: Move then shoot diagonally 1 square (2 uses per game); or shoot diagonally 2 squares without moving (2 uses per game). Can turn 90° left or right per action.'
            },
            'Ballista': {
                points: '1 point to move 1 square vertically/horizontally or shoot 3 (or 4 with Extend Range) squares based on facing; 2 points to turn or activate specials.',
                extra: 'Specials: Extend Range (+1 shoot range this round, 2 points, once per round); Double Time (move +1 extra square, 2 points, 2 uses per game). Shoots without moving. Can turn 90° left or right per action.'
            },
            'Cavalry': {
                points: '1 point to move up to 5 squares vertically or horizontally. Special Moves: Charge - once per game, move unlimited squares horizontally or vertically for 2 move points; Diagonal Rush - on rounds 1 and 2 only, move up to 3 squares diagonally for 2 move points.',
                extra: 'Stops at the first piece in its path.'
            },
            'Champion': {
                points: '1 point to move 1 square in any direction; 2 points for 2 squares in any direction.',
                extra: 'Cannot move through own pieces. Reduces opponent’s move points by 1 when on their back row. Can activate reinforcements.'
            },
            'Dragon': {
                points: '1 point to move 1 square diagonally or jump 2 squares diagonally + 1 square in any diagonal direction. Special Moves: Inferno - once per game, move 1 square in any direction for 2 move points, capturing all adjacent opponent pieces (except Dragons); Strafe - twice per game, move 1 square horizontally or vertically for 2 move points (cannot capture).',
                extra: 'Can change diagonal direction after 2-square jump.'
            },
            'Elephantry': {
                points: '1 point to move 1 square any direction, shoot 1 square, or turn; 2 points to move+shoot.',
                extra: 'Special Moves: Charge - once per piece per game, move forward (straight or diagonal) 3 squares, capturing anything except Spectre; stops on Elephantry/Ogre/Troll/Dragon. Triple Shot - 2 points for 3 shots at 2-square range with coin flip each (stays in position, can retarget). Can turn 90° left or right per action.'
            },
            'Fusilier': {
                points: '1 point to move 2 squares diagonally or shoot forward/diagonally up to 3 squares. Cannot move and shoot in same round.',
                extra: 'Can move through own pieces. After shooting, cannot shoot next round (can still move). Only captures by shooting. Special Moves: Crack Shot - increase range by +1 for next shot (2 points, 3 uses per piece; success determined by coin flip); Strafe - move 1 square vertically/horizontally without capturing (2 points, 2 uses per piece).'
            },
            'Guard': {
                points: '1 point to move 1 square in any direction.',
                extra: 'Versatile movement in all directions.'
            },
            'Infantry': {
                points: '1 point to move 1 square forward or diagonally forward; 1 point to turn.',
                extra: 'Round 1 only: can move up to 3 squares forward. Turn (1 point) or Turn and Move (2 points) via buttons. Both finalize action. Cannot move then turn. Can turn 90° left or right per action.'
            },
            'King': {
                points: '1 point to move 1 square vertically or horizontally.',
                extra: 'Cannot move into check. Capture ends the game. Can activate reinforcements. Special Move: Guard of Honour - once per game, swap positions with an adjacent Guard for 2 move points.'
            },
            'Mercenary': {
                points: '1 point to move 1 square in any direction; 2 points for 2 squares in any direction.',
                extra: 'Can move or capture in any direction. Special Move: After a successful capture, triggers a coin flip - if successful, the mercenary continues its round instantly without move point costs (once per round).'
            },
            'Necromancer': {
                points: '1 point to move 1 square in any direction. Special actions cost 2 points: summon Zombie or Spectre (coin flip) or channel a 2-range shot.',
                extra: 'Max 2 per player, arrives via Champion summoning. Shoots require a 1-round cooldown and always resolve captures with coin flips. Teleport twice per game.'
            },
            'Huntsman': {
                points: '1 point to move 1 square in any direction.',
                extra: '36’s (Supreme) exclusive. Special Move: Stalking Burst (2 move points) performs 4 coin flips—each success grants 1 chained step of movement (up to 4) that round. Huntsmen require a coin flip to be captured by shooting, but automatically capture Zombies without coin flips.'
            },
            'Ogre': {
                points: '1 point to move 1 square vertically/horizontally or jump 2 squares; 2 points for both.',
                extra: 'Captures by jumping over or landing. Cannot jump over other Ogres.'
            },
            'Pistolier': {
                points: '1 point to move diagonally up to 3 squares or shoot diagonally up to 2 squares; 2 points to move+shoot (1 square shoot range).',
                extra: 'Capturing by landing (not shooting) requires coin flip (50/50). Does not turn - shoots and moves diagonally only.'
            },
            'Spectre': {
                points: '1 point to move in knight-diagonal pattern (2 diagonal + 1 perpendicular). Summoned by Wizard.',
                extra: 'Can move through all pieces. Capturing requires 50/50 coin toss (except vs Wizards/Spectres). Cannot trigger reinforcements. Max 2 per player.'
            },
            'Troll': {
                points: '1 point to move up to 2 squares vertically/horizontally or 1 square diagonally; +1 point for 1 extra square in same vertical/horizontal direction (total 2 points).',
                extra: 'On first round, can move up to 4 squares vertically/horizontally or 2 squares diagonally at normal cost. No extra move on first round.'
            },
            'Wizard': {
                points: '1 point to move up to 4 squares diagonally; 2 points to move up to 5 squares and/or through own pieces. Special Moves: Teleport - twice per game, move to any unoccupied square of the same color for 2 move points; Teleport Swap - once per game, swap with an opponent Wizard on the same color square for 2 move points; Strafe - twice per game, move 1 square horizontally or vertically for 2 move points (cannot capture); Summon Spectre - twice per game, costs 2 points, requires 5+ captured pieces, 50/50 chance, wizard cannot move next round.',
                extra: 'Cannot move through opponent pieces.'
            },
            'Zombie': {
                points: 'Automatically shambles forward each round without spending move points.',
                extra: 'Summoned to the back row. Moves forward, attempting diagonal detours if blocked, and resolves captures (including defending) via coin flip. Converts opposing Zombies on successful clashes.'
            }
        };
        const turnablePieces = ['Archer', 'Ballista', 'Elephantry', 'Fusilier', 'Infantry'];
        const turnCosts = {
            'Archer': 1,
            'Ballista': 2,
            'Elephantry': 1,
            'Fusilier': 1,
            'Infantry': 1
        };
        const pieceTypes = {
            'Cavalry': { move: (r, c, board, player) => {
                let moves = [];
                // Standard orthogonal movement (up to 5 squares)
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    for (let i = 1; i <= 5; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                            }
                            break;
                        }
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                // Diagonal Rush on rounds 1 and 2 only (costs 2 points, up to 3 squares)
                if (gameRound <= 2) {
                    for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                        for (let i = 1; i <= 3; i++) {
                            let nr = r + d[0] * i, nc = c + d[1] * i;
                            if (!isValid(nr, nc)) break;
                            if (board[nr][nc]) {
                                if (board[nr][nc].player !== player) {
                                    moves.push({ type: 'move', pos: [nr, nc], cost: 2 });
                                }
                                break;
                            }
                            moves.push({ type: 'move', pos: [nr, nc], cost: 2 });
                        }
                    }
                }
                return moves;
            }},
            'Troll': { move: (r, c, board, player, firstMove, _, movesLeft) => {
                let moves = [];
                let isFirstTurn = firstMove && isFirstPlayerTurn;
                let maxOrtho = isFirstTurn ? 4 : 2;
                let maxDiag = isFirstTurn ? 2 : 1;
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    for (let i = 1; i <= maxOrtho; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                            }
                            break;
                        }
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                if (!isFirstTurn && movesLeft >= 2) {
                    for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                        let nr1 = r + d[0], nc1 = c + d[1];
                        let nr2 = r + d[0] * 2, nc2 = c + d[1] * 2;
                        let nr3 = r + d[0] * 3, nc3 = c + d[1] * 3;
                        if (isValid(nr1, nc1) && isValid(nr2, nc2) && isValid(nr3, nc3) && !board[nr1][nc1] && !board[nr2][nc2] && !board[nr3][nc3]) {
                            moves.push({ type: 'move', pos: [nr3, nc3], cost: 2 });
                        }
                    }
                }
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    for (let i = 1; i <= maxDiag; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                            }
                            break;
                        }
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                return moves;
            }},
            'Dragon': { move: (r, c, board, player) => {
                let moves = [];
                // Normal moves
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                }
                for (let d of [[2,2], [2,-2], [-2,2], [-2,-2]]) {
                    let midr = r + d[0]/2, midc = c + d[1]/2;
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) {
                        for (let d2 of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                            let nnr = nr + d2[0], nnc = nc + d2[1];
                            if (isValid(nnr, nnc)) {
                                moves.push({ type: 'move', pos: [nnr, nnc], cost: 1 });
                            }
                        }
                    }
                }
                return moves;
            }},
            'Wizard': { move: (r, c, board, player, firstMove, facing, movesLeft) => {
                let moves = [];
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    for (let i = 1; i <= 4; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                            }
                            break;
                        }
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                if (movesLeft >= 2) {
                    for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                        let i = 1;
                        while (i <= 5) {
                            let nr = r + d[0] * i, nc = c + d[1] * i;
                            if (!isValid(nr, nc)) break;
                            if (board[nr][nc]) {
                                if (board[nr][nc].player === player) {
                                    i++;
                                    continue;
                                } else {
                                    moves.push({ type: 'move', pos: [nr, nc], cost: 2 });
                                    break;
                                }
                            }
                            moves.push({ type: 'move', pos: [nr, nc], cost: 2 });
                            i++;
                        }
                    }
                }
                return moves;
            }},
            'Guard': { move: (r, c, board, player) => {
                let moves = [];
                for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                }
                return moves;
            }},
            'Huntsman': { move: (r, c, board, player) => {
                let moves = [];
                const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                for (let d of directions) {
                    const nr = r + d[0];
                    const nc = c + d[1];
                    if (!isValid(nr, nc)) continue;
                    const occupant = board[nr]?.[nc];
                    if (!occupant || occupant.player !== player) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                return moves;
            }},
            'King': { move: (r, c, board, player) => {
                let moves = [];
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc) && !isCheckAfterMove(r, c, nr, nc, player)) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                return moves;
            }},
            'Champion': { move: (r, c, board, player) => {
                let moves = [];
                let directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                for (let d of directions) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) {
                        if (!board[nr][nc] || board[nr][nc].player !== player) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        }
                        if (!board[nr][nc]) {
                            for (let d2 of directions) {
                                let nnr = nr + d2[0], nnc = nc + d2[1];
                                if (isValid(nnr, nnc) && (nnr !== r || nnc !== c)) {
                                    if (!board[nnr][nnc] || board[nnr][nnc].player !== player) {
                                        moves.push({ type: 'move', pos: [nnr, nnc], cost: 2 });
                                    }
                                }
                            }
                        }
                    }
                }
                let uniqueMoves = {};
                for (let move of moves) {
                    let key = `${move.pos[0]},${move.pos[1]}`;
                    if (!uniqueMoves[key] || move.cost < uniqueMoves[key].cost) {
                        uniqueMoves[key] = move;
                    }
                }
                return Object.values(uniqueMoves);
            }},
            'Infantry': { move: (r, c, board, player, _, facing) => {
                let moves = [];
                // Round 1 only: can move up to 3 squares forward
                let max = (gameRound === 1) ? 3 : 1;
                let dir, diag1, diag2;
                if (facing === 'U') { dir = [-1,0]; diag1 = [-1,-1]; diag2 = [-1,1]; }
                else if (facing === 'D') { dir = [1,0]; diag1 = [1,-1]; diag2 = [1,1]; }
                else if (facing === 'L') { dir = [0,-1]; diag1 = [-1,-1]; diag2 = [1,-1]; }
                else if (facing === 'R') { dir = [0,1]; diag1 = [-1,1]; diag2 = [1,1]; }
                
                if (!dir) return []; // Safety check if facing is null

                for (let i = 1; i <= max; i++) {
                    let nr = r + dir[0] * i, nc = c + dir[1] * i;
                    if (!isValid(nr, nc)) break;
                    if (board[nr][nc]) {
                        if (board[nr][nc].player !== player) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        }
                        break;
                    }
                    moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                }
                for (let d of [diag1, diag2]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) {
                        if (!board[nr][nc]) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        } else if (board[nr][nc].player !== player) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        }
                    }
                }
                return moves;
            }},
            'Archer': { move: (r, c, board, player, _, facing) => {
                let moves = [];
                // Movement: 1 square vertically or horizontally (only to empty squares - cannot capture by landing)
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                // Shooting: 1 or 2 squares in facing direction
                let dir;
                if (facing === 'U') dir = [-1, 0];
                else if (facing === 'D') dir = [1, 0];
                else if (facing === 'L') dir = [0, -1];
                else if (facing === 'R') dir = [0, 1];

                if (dir) { // Only shoot if facing is set
                    for (let dist = 1; dist <= 2; dist++) {
                        let nr = r + dir[0] * dist, nc = c + dir[1] * dist;
                        if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== player) {
                            moves.push({ type: 'shoot', pos: [nr, nc], cost: 1 });
                        }
                    }
                }
                return moves;
            }},
            'Ballista': { move: (r, c, board, player, _, facing) => {
                let moves = [];
                // Movement: 1 square vertically or horizontally (only to empty squares - cannot capture by landing)
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                // Shooting: 1, 2, or 3 squares in specified directions based on facing
                let dirs;
                if (facing === 'U') dirs = [[-1,0], [-1,-1], [-1,1]];  // Up, Up-Left, Up-Right
                else if (facing === 'D') dirs = [[1,0], [1,-1], [1,1]]; // Down, Down-Left, Down-Right
                else if (facing === 'L') dirs = [[0,-1], [-1,-1], [1,-1]]; // Left, Up-Left, Down-Left
                else if (facing === 'R') dirs = [[0,1], [-1,1], [1,1]]; // Right, Up-Right, Down-Right

                if (dirs) { // Only shoot if facing is set
                    const maxRange = (ballistaRangeBoostActive[player] ? 4 : 3);
                    for (let dir of dirs) {
                        for (let dist = 1; dist <= maxRange; dist++) {
                            let nr = r + dir[0] * dist, nc = c + dir[1] * dist;
                            if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== player) {
                                moves.push({ type: 'shoot', pos: [nr, nc], cost: 1 });
                            }
                        }
                    }
                }
                return moves;
            }},
            'Elephantry': { move: (r, c, board, player, _, facing, movesLeft) => {
                let moves = [];
                // 1 point: move 1 square any direction (can capture by landing)
                for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) {
                        if (board[nr][nc] && board[nr][nc].type === 'Zombie') continue;
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                // 1 point: shoot 1 square in any direction (without moving)
                for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== player) {
                        moves.push({ type: 'shoot', pos: [nr, nc], cost: 1 });
                    }
                }
                // 2 points: move+shoot combination (show move positions that have shoot targets available)
                if (movesLeft >= 2) {
                    for (let d1 of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                        let nr = r + d1[0], nc = c + d1[1];
                        if (isValid(nr, nc) && !board[nr][nc]) {
                            // Check if there are any shoot targets from this position
                            let hasShootTargets = false;
                            for (let d2 of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = nr + d2[0], shootC = nc + d2[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== player) {
                                    hasShootTargets = true;
                                    break;
                                }
                            }
                            // Only add this move if there are shoot targets available
                            if (hasShootTargets) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'elephantryMoveShoot' });
                            }
                        }
                    }
                }
                return moves;
            }},
            'Pistolier': { move: (r, c, board, player, _, facing, movesLeft) => {
                let moves = [];
                // 1 point: move diagonally up to 3 squares
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    for (let i = 1; i <= 3; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            // Capturing by landing requires coin flip - handled in handleClick
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 1, special: 'pistolierCapture' });
                            }
                            break;
                        }
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                // 1 point: shoot diagonally up to 2 squares (without moving)
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    for (let i = 1; i <= 2; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'shoot', pos: [nr, nc], cost: 1 });
                            }
                            break;
                        }
                    }
                }
                // 2 points: move+shoot combination (move diagonally, then shoot 1 square diagonally from new position)
                if (movesLeft >= 2) {
                    for (let d1 of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                        for (let i = 1; i <= 3; i++) {
                            let nr = r + d1[0] * i, nc = c + d1[1] * i;
                            if (!isValid(nr, nc)) break;
                            if (board[nr][nc]) break; // Can't move through pieces for move+shoot

                            // Check if there are any shoot targets from this position (1 square diagonal)
                            let hasShootTargets = false;
                            for (let d2 of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = nr + d2[0], shootC = nc + d2[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== player) {
                                    hasShootTargets = true;
                                    break;
                                }
                            }
                            // Only add this move if there are shoot targets available
                            if (hasShootTargets) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'pistolierMoveShoot' });
                            }
                        }
                    }
                }
                return moves;
            }},
            'Fusilier': { move: (r, c, board, player, _, facing, movesLeft) => {
                let moves = [];
                const pieceKey = `${r},${c},${player}`;
                const piece = board[r][c];
                if (!piece) return moves;
                if (!(pieceKey in fusilierCrackShotCount)) {
                    fusilierCrackShotCount[pieceKey] = 3;
                }
                const shotBlocked = piece ? (fusilierShotLastTurn[player].has(piece) || fusilierShotThisTurn[player].has(piece)) : false;

                // 1 point: move up to 2 squares diagonally (1 or 2 squares)
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    // 1 square diagonal movement
                    let nr1 = r + d[0], nc1 = c + d[1];
                    if (isValid(nr1, nc1)) {
                        if (!board[nr1][nc1]) {
                            moves.push({ type: 'move', pos: [nr1, nc1], cost: 1 });
                        }
                    }

                    // 2 squares diagonal movement (can move through own pieces)
                    let intermediateR = r + d[0], intermediateC = c + d[1];
                    let nr2 = r + d[0] * 2, nc2 = c + d[1] * 2;

                    if (!isValid(nr2, nc2)) continue;

                    // Can move through own pieces on intermediate square
                    const intermediateBlocked = board[intermediateR] && board[intermediateR][intermediateC] && board[intermediateR][intermediateC].player !== player;

                    if (!intermediateBlocked) {
                        if (!board[nr2][nc2]) {
                            moves.push({ type: 'move', pos: [nr2, nc2], cost: 1 });
                        }
                    }
                }

                // 1 point: shoot forward and diagonally up to 3 squares (only if didn't shoot last turn)
                // Crack Shot increases range to 4 squares
                if (!shotBlocked) {
                    let directions = [];
                    if (facing === 'U') {
                        directions = [[-1,0], [-1,-1], [-1,1]]; // Up, Up-Left, Up-Right
                    } else if (facing === 'D') {
                        directions = [[1,0], [1,-1], [1,1]]; // Down, Down-Left, Down-Right
                    } else if (facing === 'L') {
                        directions = [[0,-1], [-1,-1], [1,-1]]; // Left, Up-Left, Down-Left
                    } else if (facing === 'R') {
                        directions = [[0,1], [-1,1], [1,1]]; // Right, Up-Right, Down-Right
                    }

                    const crackShotActive = fusilierCrackShotActive === piece;
                    const crackShotsRemaining = fusilierCrackShotCount[pieceKey] || 0;
                    const canAutoCrackShot = !crackShotActive && crackShotsRemaining > 0 && movesLeft >= 3;

                    const maxRange = crackShotActive ? 4 : 3;
                    for (let d of directions) {
                        for (let i = 1; i <= 4; i++) {
                            let shootR = r + d[0] * i, shootC = c + d[1] * i;
                            if (!isValid(shootR, shootC)) break;
                            if (board[shootR][shootC]) {
                                if (board[shootR][shootC].player !== player) {
                                    if (i <= maxRange) {
                                        moves.push({ type: 'shoot', pos: [shootR, shootC], cost: 1 });
                                    } else if (i === 4 && canAutoCrackShot) {
                                        moves.push({ type: 'shoot', pos: [shootR, shootC], cost: 3, special: 'fusilierCrackShotAuto' });
                                    }
                                }
                                break;
                            }
                        }
                    }
                }

                return moves;
            }},
            'Mercenary': { move: (r, c, board, player, _, facing) => {
                let moves = [];
                // All 8 directions: orthogonal and diagonal
                const allDirections = [
                    [-1, 0],  // Up
                    [1, 0],   // Down
                    [0, -1],  // Left
                    [0, 1],   // Right
                    [-1, -1], // Up-Left
                    [-1, 1],  // Up-Right
                    [1, -1],  // Down-Left
                    [1, 1]    // Down-Right
                ];

                // 1 square in any direction for 1 point
                for (let dir of allDirections) {
                    let newPos = [r + dir[0], c + dir[1]];
                    if (isValid(newPos[0], newPos[1])) {
                        if (!board[newPos[0]][newPos[1]]) {
                            moves.push({ type: 'move', pos: newPos, cost: 1 });
                        } else if (board[newPos[0]][newPos[1]].player !== player) {
                            moves.push({ type: 'move', pos: newPos, cost: 1 });
                        }
                    }
                }

                // 2 squares in any direction for 2 points
                for (let dir of allDirections) {
                    let midPos = [r + dir[0], c + dir[1]];
                    let twoPos = [r + 2*dir[0], c + 2*dir[1]];

                    // Path must be clear
                    if (isValid(midPos[0], midPos[1]) && !board[midPos[0]][midPos[1]] &&
                        isValid(twoPos[0], twoPos[1])) {
                        if (!board[twoPos[0]][twoPos[1]]) {
                            moves.push({ type: 'move', pos: twoPos, cost: 2 });
                        } else if (board[twoPos[0]][twoPos[1]].player !== player) {
                            moves.push({ type: 'move', pos: twoPos, cost: 2 });
                        }
                    }
                }
                return moves;
            }},
            'Ogre': { move: (r, c, board, player) => {
                let moves = [];
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                }
                for (let d of [[0,2], [0,-2], [2,0], [-2,0], [2,2], [2,-2], [-2,2], [-2,-2]]) {
                    let nr = r + d[0], nc = c + d[1];
                    let midr = r + d[0]/2, midc = c + d[1]/2;
                    if (isValid(nr, nc) && (!board[midr][midc] || (board[midr][midc].type !== 'Ogre' && board[midr][midc].player !== player))) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1, jump: [midr, midc] });
                    }
                }
                return moves;
            }},
            'Spectre': { move: (r, c, board, player) => {
                let moves = [];
                // Knight-like diagonal movement: 2 diagonal + 1 perpendicular
                // Moves through pieces
                const knightDiagMoves = [
                    [2, 2, [[3, 2], [2, 3]]], // NE diagonal +perpendicular
                    [2, -2, [[3, -2], [2, -3]]], // NW diagonal
                    [-2, 2, [[-3, 2], [-2, 3]]], // SE diagonal
                    [-2, -2, [[-3, -2], [-2, -3]]] // SW diagonal
                ];
                for (let [dr, dc, perps] of knightDiagMoves) {
                    for (let [pr, pc] of perps) {
                        let nr = r + pr, nc = c + pc;
                        if (isValid(nr, nc) && (!board[nr][nc] || board[nr][nc].player !== player)) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        }
                    }
                }
                return moves;
            }}
        };

        pieceTypes['Necromancer'] = {
            move: (r, c, board, player, firstMove, facing, movesLeft = 0) => {
                let moves = [];
                const piece = board[r][c];
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const nr = r + dr;
                        const nc = c + dc;
                        if (!isValid(nr, nc)) continue;
                        if (!board[nr][nc] || board[nr][nc].player !== player) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        }
                    }
                }
                const cooldown = necromancerShootCooldown.get(piece) || 0;
                if (movesLeft >= 2 && cooldown === 0) {
                    const directions = [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]];
                    for (const [dr, dc] of directions) {
                        for (let dist = 1; dist <= 2; dist++) {
                            const nr = r + dr * dist;
                            const nc = c + dc * dist;
                            if (!isValid(nr, nc)) break;
                            if (board[nr][nc]) {
                                if (board[nr][nc].player !== player) {
                                    moves.push({ type: 'shoot', pos: [nr, nc], cost: 2, special: 'necromancerShoot' });
                                }
                                break;
                            }
                        }
                    }
                }
                return moves;
            }
        };

        pieceTypes['Zombie'] = {
            move: () => []
        };

        let board = [];
        let currentPlayer = 'W';
        let selectedPiece = null;
        let validMoves = [];
        let movesLeft = 3;
        let movedPieces = new Set();
        let capturedPieces = { 'W': [], 'B': [] };
        let championCaptured = { 'W': false, 'B': false };
        let championsOnBackRow = { 'W': [], 'B': [] };
        let scores = { 'W': 0, 'B': 0 };
        let firstMoves = new Set();
        let reinforcementPending = null;
        let gameLog = [];

        function setDifficulty(level, element) {
            aiDifficulty = level;
            const buttons = document.querySelectorAll('#difficulty-selector button');
            buttons.forEach(btn => btn.classList.remove('selected-diff'));
            element.classList.add('selected-diff');

            if (level === 'Easy') {
                baseAiDepth = 25; // Increased by 60% intelligence + 30% general difficulty (12 * 1.6 * 1.3 ≈ 25) - plans 3+ moves ahead
                pieceValueScale = 8.0031744; // Increased by 60% intelligence + 30% general difficulty (3.84768 * 1.6 * 1.3)
            } else if (level === 'Medium') {
                baseAiDepth = 44; // Increased by 80% intelligence + 30% general difficulty (19 * 1.8 * 1.3 ≈ 44) - plans 3+ moves ahead
                pieceValueScale = 11.74238208; // Increased by 80% intelligence + 30% general difficulty (5.018112 * 1.8 * 1.3)
            } else if (level === 'Hard') {
                baseAiDepth = 65; // Increased by 100% intelligence + 30% general difficulty (25 * 2.0 * 1.3 = 65) - plans 3+ moves ahead
                pieceValueScale = 16.6053888; // Increased by 100% intelligence + 30% general difficulty (6.386688 * 2.0 * 1.3)
            }
            applyAiDepthForVariant();
        }

        function setOpponent(opponent, element) {
            selectedOpponent = opponent;
            const buttons = document.querySelectorAll('#opponent-selector button');
            buttons.forEach(btn => btn.classList.remove('selected-opponent'));
            element.classList.add('selected-opponent');
        }

        function setHintMode(mode, element) {
            hintModeEnabled = (mode === 'On');
            const buttons = document.querySelectorAll('#hint-selector button');
            buttons.forEach(btn => btn.classList.remove('selected-hint'));
            element.classList.add('selected-hint');
        }

        function getOpponentDisplayName() {
            return currentAiProfile ? currentAiProfile.displayName : 'AI';
        }

        function applyAiDepthForVariant() {
            // Apply difficulty-based depth limits that scale with selected difficulty level
            // Caps are now proportional to allow difficulty settings to apply properly
            if (gameVariant === '24s' || gameVariant === 'ccb') {
                // Cap at 70% of base depth for medium-sized variants
                aiMaxDepth = Math.max(3, Math.min(baseAiDepth, Math.floor(baseAiDepth * 0.7)));
            } else if (isLargeBoardVariant()) {
                // Cap at 30% of base depth for large variants (performance consideration)
                aiMaxDepth = Math.max(2, Math.min(baseAiDepth, Math.floor(baseAiDepth * 0.3)));
            } else {
                // Default variants can use full depth
                aiMaxDepth = Math.max(2, baseAiDepth);
            }
            updateAiPieceValues();
        }

        function startGame(variant) {
            gameVariant = variant;

            // Select AI profile based on player's choice
            if (selectedOpponent === 'Random') {
                const profileNames = Object.keys(AI_PROFILES);
                const randomIndex = Math.floor(Math.random() * profileNames.length);
                currentAiProfile = AI_PROFILES[profileNames[randomIndex]];
            } else {
                currentAiProfile = AI_PROFILES[selectedOpponent];
            }
            console.log(`AI Profile: ${currentAiProfile.name} - ${currentAiProfile.description}`);

            if (variant === '24s') {
                ROWS = 10;
                COLS = 14;
            } else if (variant === '36s') {
                ROWS = 10;
                COLS = 14;
            } else if (variant === '36s-expert') {
                ROWS = 10;
                COLS = 14;
            } else if (variant === '36s-elite') {
                ROWS = 10;
                COLS = 14;
            } else if (variant === '36s-supreme') {
                ROWS = 10;
                COLS = 14;
            } else if (variant === 'ccb') {
                ROWS = 8;
                COLS = 12;
            }
            applyAiDepthForVariant();
            document.getElementById('start-menu').style.display = 'none';
            const landingHeader = document.getElementById('landing-header');
            if (landingHeader) landingHeader.style.display = 'none';
            const landingFooter = document.getElementById('landing-footer');
            if (landingFooter) landingFooter.style.display = 'none';
            document.getElementById('game-container').style.display = 'flex';
            const boardDiv = document.getElementById('board');
            boardDiv.style.gridTemplateColumns = `repeat(${COLS}, 50px)`;
            boardDiv.style.gridTemplateRows = `repeat(${ROWS}, 50px)`;
            // Start aggressive watchdog to ensure AI turn always triggers when needed (especially for 36s variants)
            if (!window.aiTurnWatch) {
                window.aiTurnWatch = setInterval(() => {
                    try {
                        // Don't trigger AI turn if game is paused
                        if (gamePaused) return;

                        // Aggressively check turn transition
                        if (currentPlayer === 'W' && !reinforcementPending && !aiPending && movesLeft <= 0) {
                            triggerAiTurn();
                        } else {
                            ensureAITurnIfNeeded();
                        }
                    } catch (e) {
                        // Silently ignore watchdog errors
                    }
                }, 200); // Check every 200ms for faster response
            }
            resetGame();
        }

        function initBoard() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(null));
            firstMoves.clear();
            championsOnBackRow = { 'W': [], 'B': [] };
            if (gameVariant === '24s') {
                const backRowW = ['Cavalry', 'Troll', 'Dragon', 'Wizard', 'Guard', 'Champion', 'King', 'Guard', 'Wizard', 'Dragon', 'Troll', 'Cavalry'];
                const backRowB = ['Cavalry', 'Troll', 'Dragon', 'Wizard', 'Guard', 'King', 'Champion', 'Guard', 'Wizard', 'Dragon', 'Troll', 'Cavalry']; // King and Champion swapped for AI
                // Place pieces in columns 1-12, leaving columns 0 and 13 empty
                for (let c = 1; c <= 12; c++) {
                    const idx = c - 1; // Index into the piece arrays (0-11)
                    board[8][c] = { type: 'Infantry', player: 'W', facing: 'U' };
                    board[9][c] = { type: backRowW[idx], player: 'W', facing: turnablePieces.includes(backRowW[idx]) ? 'U' : null };
                    board[0][c] = { type: backRowB[idx], player: 'B', facing: turnablePieces.includes(backRowB[idx]) ? 'D' : null };
                    board[1][c] = { type: 'Infantry', player: 'B', facing: 'D' };
                    if (backRowW[idx] === 'Troll') {
                        firstMoves.add(`9,${c},W`);
                    }
                    if (backRowB[idx] === 'Troll') {
                        firstMoves.add(`0,${c},B`);
                    }
                }
            } else if (gameVariant === '36s') {
                const backRowW = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'Champion', 'King', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry'];
                const backRowB = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'King', 'Champion', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry']; // King and Champion swapped for AI
                const secondRow = ['Cavalry', 'Troll', 'Dragon', 'Archer', 'Archer', 'Guard', 'Guard', 'Archer', 'Archer', 'Dragon', 'Troll', 'Cavalry'];
                // Place pieces in columns 1-12, leaving columns 0 and 13 empty
                for (let c = 1; c <= 12; c++) {
                    const idx = c - 1; // Index into the piece arrays (0-11)
                    board[7][c] = { type: 'Infantry', player: 'W', facing: 'U' };
                    board[8][c] = { type: secondRow[idx], player: 'W', facing: turnablePieces.includes(secondRow[idx]) ? 'U' : null };
                    board[9][c] = { type: backRowW[idx], player: 'W', facing: turnablePieces.includes(backRowW[idx]) ? 'U' : null };
                    board[0][c] = { type: backRowB[idx], player: 'B', facing: turnablePieces.includes(backRowB[idx]) ? 'D' : null };
                    board[1][c] = { type: secondRow[idx], player: 'B', facing: turnablePieces.includes(secondRow[idx]) ? 'D' : null };
                    board[2][c] = { type: 'Infantry', player: 'B', facing: 'D' };
                    if (secondRow[idx] === 'Troll') {
                        firstMoves.add(`8,${c},W`);
                        firstMoves.add(`1,${c},B`);
                    }
                }
            } else if (gameVariant === '36s-expert') {
                const backRowW = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'Champion', 'King', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry'];
                const backRowB = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'King', 'Champion', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry']; // King and Champion swapped for AI
                const secondRow = ['Cavalry', 'Troll', 'Dragon', 'Archer', 'Archer', 'Guard', 'Guard', 'Archer', 'Archer', 'Dragon', 'Troll', 'Cavalry'];
                const infantryRow = ['Infantry', 'Infantry', 'Mercenary', 'Infantry', 'Elephantry', 'Infantry', 'Infantry', 'Elephantry', 'Infantry', 'Mercenary', 'Infantry', 'Infantry'];
                // Place pieces in columns 1-12, leaving columns 0 and 13 empty
                for (let c = 1; c <= 12; c++) {
                    const idx = c - 1; // Index into the piece arrays (0-11)
                    board[7][c] = { type: infantryRow[idx], player: 'W', facing: turnablePieces.includes(infantryRow[idx]) ? 'U' : null };
                    board[8][c] = { type: secondRow[idx], player: 'W', facing: turnablePieces.includes(secondRow[idx]) ? 'U' : null };
                    board[9][c] = { type: backRowW[idx], player: 'W', facing: turnablePieces.includes(backRowW[idx]) ? 'U' : null };
                    board[0][c] = { type: backRowB[idx], player: 'B', facing: turnablePieces.includes(backRowB[idx]) ? 'D' : null };
                    board[1][c] = { type: secondRow[idx], player: 'B', facing: turnablePieces.includes(secondRow[idx]) ? 'D' : null };
                    board[2][c] = { type: infantryRow[idx], player: 'B', facing: turnablePieces.includes(infantryRow[idx]) ? 'D' : null };
                    if (secondRow[idx] === 'Troll') {
                        firstMoves.add(`8,${c},W`);
                        firstMoves.add(`1,${c},B`);
                    }
                }
            } else if (gameVariant === '36s-elite' || gameVariant === '36s-supreme') {
                const backRowW = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'Champion', 'King', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry'];
                const backRowB = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'King', 'Champion', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry']; // King and Champion swapped for AI
                const secondRow = ['Cavalry', 'Troll', 'Dragon', 'Archer', 'Archer', 'Guard', 'Guard', 'Archer', 'Archer', 'Dragon', 'Troll', 'Cavalry'];
                const infantryRow = ['Infantry', 'Infantry', 'Mercenary', 'Infantry', 'Elephantry', 'Infantry', 'Infantry', 'Elephantry', 'Infantry', 'Mercenary', 'Infantry', 'Infantry'];
                for (let c = 1; c <= 12; c++) {
                    const idx = c - 1;
                    board[7][c] = { type: infantryRow[idx], player: 'W', facing: turnablePieces.includes(infantryRow[idx]) ? 'U' : null };
                    board[8][c] = { type: secondRow[idx], player: 'W', facing: turnablePieces.includes(secondRow[idx]) ? 'U' : null };
                    board[9][c] = { type: backRowW[idx], player: 'W', facing: turnablePieces.includes(backRowW[idx]) ? 'U' : null };
                    board[0][c] = { type: backRowB[idx], player: 'B', facing: turnablePieces.includes(backRowB[idx]) ? 'D' : null };
                    board[1][c] = { type: secondRow[idx], player: 'B', facing: turnablePieces.includes(secondRow[idx]) ? 'D' : null };
                    board[2][c] = { type: infantryRow[idx], player: 'B', facing: turnablePieces.includes(infantryRow[idx]) ? 'D' : null };
                    if (secondRow[idx] === 'Troll') {
                        firstMoves.add(`8,${c},W`);
                        firstMoves.add(`1,${c},B`);
                    }
                }
            } else if (gameVariant === 'ccb') {
                const backRowW = ['Cavalry', 'Troll', 'Dragon', 'Wizard', 'Guard', 'Champion', 'King', 'Guard', 'Wizard', 'Dragon', 'Troll', 'Cavalry'];
                const backRowB = ['Cavalry', 'Troll', 'Dragon', 'Wizard', 'Guard', 'King', 'Champion', 'Guard', 'Wizard', 'Dragon', 'Troll', 'Cavalry']; // King and Champion swapped for AI
                const infantryRow = Array(COLS).fill('Infantry');
                for (let c = 0; c < COLS; c++) {
                    board[6][c] = { type: infantryRow[c], player: 'W', facing: 'U' };
                    board[7][c] = { type: backRowW[c], player: 'W', facing: turnablePieces.includes(backRowW[c]) ? 'U' : null };
                    board[0][c] = { type: backRowB[c], player: 'B', facing: turnablePieces.includes(backRowB[c]) ? 'D' : null };
                    board[1][c] = { type: infantryRow[c], player: 'B', facing: 'D' };
                    if (backRowW[c] === 'Troll') {
                        firstMoves.add(`7,${c},W`);
                    }
                    if (backRowB[c] === 'Troll') {
                        firstMoves.add(`0,${c},B`);
                    }
                }
            }
            // Don't render board here - wait until coin toss determines starting player
        }

        function applyCoinFlipSuccessEffect(theme = null) {
            const boardDiv = document.getElementById('board');
            if (!boardDiv) return;
            const effectClass = theme === 'energy-blast' ? 'coin-flip-success-energy' : 'coin-flip-success';
            boardDiv.classList.remove('coin-flip-success', 'coin-flip-success-energy');
            boardDiv.classList.add(effectClass);

            // Apply purple body overlay for energy blast theme
            const body = document.body;
            if (theme === 'energy-blast' && body) {
                body.classList.add('energy-blast-overlay');
            }

            let cleanupApplied = false;
            let cleanupScheduled = false;
            const handleEffectCleanup = () => {
                if (cleanupApplied) return;
                cleanupApplied = true;
                boardDiv.classList.remove(effectClass);
                // For energy blast, only remove overlay if energy blast glow is not active
                // This allows seamless transition from activation to energy blast mode
                if (theme === 'energy-blast' && body && !energyBlastGlowActive) {
                    body.classList.remove('energy-blast-overlay');
                }
            };

            if (theme === 'energy-blast') {
                const settleDelay = 400;
                const pollInterval = 120;
                const minDuration = 3400;
                const maxDuration = 6500;
                const startTime = Date.now();
                const waitForTransition = () => {
                    if (cleanupApplied) return;
                    const elapsed = Date.now() - startTime;
                    if (energyBlastGlowActive && elapsed >= minDuration) {
                        if (!cleanupScheduled) {
                            cleanupScheduled = true;
                            setTimeout(handleEffectCleanup, settleDelay);
                        }
                        return;
                    }
                    if (elapsed >= maxDuration) {
                        cleanupScheduled = true;
                        handleEffectCleanup();
                        return;
                    }
                    setTimeout(waitForTransition, pollInterval);
                };
                waitForTransition();
            } else {
                setTimeout(handleEffectCleanup, 1500);
            }
        }

        function applyCoinFlipFailureEffect() {
            const body = document.body;
            // Add game background color change immediately
            if (!body.classList.contains('coinflip-failure-game-background')) {
                body.classList.add('coinflip-failure-game-background');
                // Remove game background after 2 seconds
                setTimeout(() => {
                    body.classList.remove('coinflip-failure-game-background');
                }, 2000);
            }
        }

        function showWarcryAchievementPopup(player, options = {}) {
            const { title = 'WARCRY', subtitle = 'Bonus Granted' } = options;
            // Pause the game
            gamePaused = true;
            pausedTimers.game = gameTimerInterval;
            pausedTimers.turn = turnTimerInterval;
            pausedTimers.turnPlayer = currentTurnTimerPlayer;

            // Stop timers
            if (gameTimerInterval) {
                clearInterval(gameTimerInterval);
                gameTimerInterval = null;
            }
            if (turnTimerInterval) {
                clearInterval(turnTimerInterval);
                turnTimerInterval = null;
            }

            // Apply visual effects
            const boardDiv = document.getElementById('board');
            const body = document.body;

            // Add gold glow to board
            if (boardDiv) {
                boardDiv.classList.add('warcry-achievement');
            }

            // Add black background
            if (!body.classList.contains('warcry-achievement-background')) {
                body.classList.add('warcry-achievement-background');
            }

            // Show modal
            const modal = document.getElementById('warcry-achievement-modal');
            if (modal) {
                const titleEl = modal.querySelector('h1');
                const subtitleEl = modal.querySelector('p');
                if (titleEl) titleEl.textContent = title;
                if (subtitleEl) subtitleEl.textContent = subtitle;
                modal.style.display = 'block';
            }

            // Auto-close after 2.6 seconds
            setTimeout(() => {
                closeWarcryAchievementPopup();
            }, 2600);
        }

        function closeWarcryAchievementPopup() {
            // Hide modal
            const modal = document.getElementById('warcry-achievement-modal');
            if (modal) {
                modal.style.display = 'none';
            }

            // Remove visual effects
            const boardDiv = document.getElementById('board');
            const body = document.body;

            if (boardDiv) {
                boardDiv.classList.remove('warcry-achievement');
            }

            if (body) {
                body.classList.remove('warcry-achievement-background');
            }

            // Resume game
            gamePaused = false;
            if (pausedTimers.game && gameTimeRemaining > 0) {
                startGameTimer();
            }
            if (pausedTimers.turn && pausedTimers.turnPlayer) {
                if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                    startTurnTimer('W', { reset: false });
                } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                    startTurnTimer('B', { reset: false });
                }
            }
            pausedTimers = { game: null, turn: null, turnPlayer: null };
        }

        function applyEnergyBlastGlow() {
            const board = document.getElementById('board');
            if (board) {
                board.classList.add('energy-blast-glow');
            }
            const body = document.body;
            if (body) {
                body.classList.add('energy-blast-overlay');
            }
            energyBlastGlowActive = true;
        }

        function removeEnergyBlastGlow() {
            if (!energyBlastGlowActive) return;
            const board = document.getElementById('board');
            if (board) {
                board.classList.remove('energy-blast-glow');
            }
            const body = document.body;
            if (body) {
                body.classList.remove('energy-blast-overlay');
            }
            energyBlastGlowActive = false;
        }

        function showEnergyBlastPopup(callback = () => {}) {
            const modal = document.getElementById('energy-blast-popup');
            if (!modal) {
                callback();
                return;
            }
            pausedTimers.game = gameTimerInterval;
            pausedTimers.turn = turnTimerInterval;
            pausedTimers.turnPlayer = currentTurnTimerPlayer;
            stopGameTimer();
            stopTurnTimer();
            gamePaused = true;
            modal.style.display = 'block';
            setTimeout(() => {
                modal.style.display = 'none';
                if (pausedTimers.game && gameTimeRemaining > 0) {
                    startGameTimer();
                }
                if (pausedTimers.turn && pausedTimers.turnPlayer) {
                    if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                        startTurnTimer('W', { reset: false });
                    } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                        startTurnTimer('B', { reset: false });
                    }
                }
                pausedTimers = { game: null, turn: null, turnPlayer: null };
                gamePaused = false;
                callback();
            }, 2000);
        }

        function pauseGameForEnergyBlastFlips() {
            if (!energyBlastFlipPauseState) {
                energyBlastFlipPauseState = {
                    wasPaused: gamePaused,
                    gameRunning: !!gameTimerInterval,
                    turnRunning: !!turnTimerInterval,
                    turnPlayer: currentTurnTimerPlayer
                };
            }
            stopGameTimer();
            stopTurnTimer();
            gamePaused = true;
        }

        function resumeGameForEnergyBlastFlips() {
            if (!energyBlastFlipPauseState) return;
            if (!energyBlastFlipPauseState.wasPaused) {
                if (energyBlastFlipPauseState.gameRunning && gameTimeRemaining > 0) {
                    startGameTimer();
                }
                if (energyBlastFlipPauseState.turnRunning && energyBlastFlipPauseState.turnPlayer) {
                    if (energyBlastFlipPauseState.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                        startTurnTimer('W', { reset: false });
                    } else if (energyBlastFlipPauseState.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                        startTurnTimer('B', { reset: false });
                    }
                }
                gamePaused = false;
            }
            energyBlastFlipPauseState = null;
        }

        function pauseGameForHuntsmanBurst() {
            if (!huntsmanBurstPauseState) {
                huntsmanBurstPauseState = {
                    wasPaused: gamePaused,
                    gameRunning: !!gameTimerInterval,
                    turnRunning: !!turnTimerInterval,
                    turnPlayer: currentTurnTimerPlayer
                };
            }
            stopGameTimer();
            stopTurnTimer();
            gamePaused = true;
        }

        function resumeGameAfterHuntsmanBurst() {
            if (!huntsmanBurstPauseState) return;
            if (!huntsmanBurstPauseState.wasPaused) {
                if (huntsmanBurstPauseState.gameRunning && gameTimeRemaining > 0) {
                    startGameTimer();
                }
                if (huntsmanBurstPauseState.turnRunning && huntsmanBurstPauseState.turnPlayer) {
                    if (huntsmanBurstPauseState.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                        startTurnTimer('W', { reset: false });
                    } else if (huntsmanBurstPauseState.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                        startTurnTimer('B', { reset: false });
                    }
                }
                gamePaused = false;
            }
            huntsmanBurstPauseState = null;
        }

        function updateCoinTossEnergyBlastProgress() {
            const progressEl = document.getElementById('coin-toss-progress');
            const continueBtn = document.getElementById('coin-toss-continue');
            if (!progressEl) return;
            if (coinTossEnergyBlastMode && coinTossEnergyBlastMode.type === 'range') {
                const successes = coinTossEnergyBlastMode.successes || 0;
                const total = coinTossEnergyBlastMode.total || ENERGY_BLAST_FLIP_COUNT;
                progressEl.style.display = 'inline-block';
                progressEl.textContent = `Successes: ${successes}/${total}`;
                if (continueBtn) {
                    continueBtn.style.display = 'none';
                }
            } else {
                progressEl.style.display = 'none';
            }
        }

        function addEnergyBlastResidualSquares(squares) {
            if (!squares || !squares.length) return;
            squares.forEach(({ row, col }) => {
                const key = `${row},${col}`;
                energyBlastResidualSquares.set(key, ENERGY_BLAST_RESIDUAL_DURATION);
            });
            refreshEnergyBlastResidualHighlights();
        }

        function decayEnergyBlastResiduals(player) {
            if (!energyBlastResidualSquares.size) return;
            if (player && player !== 'W') return;
            let changed = false;
            const updated = new Map();
            energyBlastResidualSquares.forEach((value, key) => {
                const next = value - 1;
                if (next > 0) {
                    updated.set(key, next);
                    if (next !== value) changed = true;
                } else {
                    changed = true;
                }
            });
            energyBlastResidualSquares = updated;
            if (changed) {
                refreshEnergyBlastResidualHighlights();
            }
        }

        function refreshEnergyBlastResidualHighlights() {
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                const key = `${square.dataset.row},${square.dataset.col}`;
                if (energyBlastResidualSquares.has(key)) {
                    square.classList.add('energy-blast-residual');
                } else {
                    square.classList.remove('energy-blast-residual');
                }
            });
        }

        function animateEnergyBlastPath(pathSquares, callback) {
            if (!pathSquares || !pathSquares.length) {
                callback();
                return;
            }
            const wasPaused = gamePaused;
            const savedTurnPlayer = currentTurnTimerPlayer;
            if (!wasPaused) {
                stopGameTimer();
                stopTurnTimer();
                gamePaused = true;
            }
            const highlighted = [];
            const stepDuration = 220;

            const removeHighlights = () => {
                highlighted.forEach(el => el.classList.remove('energy-blast-path'));
                highlighted.length = 0;
            };

            const finishAnimation = () => {
                removeHighlights();
                if (!wasPaused) {
                    gamePaused = false;
                    if (gameTimeRemaining > 0) {
                        startGameTimer();
                    }
                    if (savedTurnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                        startTurnTimer('W', { reset: false });
                    } else if (savedTurnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                        startTurnTimer('B', { reset: false });
                    }
                }
                callback();
            };

            const highlightStep = (index) => {
                if (index >= pathSquares.length) {
                    setTimeout(() => finishAnimation(), stepDuration);
                    return;
                }
                const { row, col } = pathSquares[index];
                const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                if (square) {
                    square.classList.add('energy-blast-path');
                    highlighted.push(square);
                }
                setTimeout(() => highlightStep(index + 1), stepDuration);
            };

            highlightStep(0);
        }

        function applyWarcryActiveBackground() {
            const body = document.body;
            const boardDiv = document.getElementById('board');
            if (!body.classList.contains('warcry-active-background')) {
                body.classList.add('warcry-active-background');
            }
            if (boardDiv && !boardDiv.classList.contains('warcry-active-border')) {
                boardDiv.classList.add('warcry-active-border');
            }
        }

        function removeWarcryActiveBackground() {
            const body = document.body;
            const boardDiv = document.getElementById('board');
            if (body.classList.contains('warcry-active-background')) {
                body.classList.remove('warcry-active-background');
            }
            if (boardDiv && boardDiv.classList.contains('warcry-active-border')) {
                boardDiv.classList.remove('warcry-active-border');
            }
        }

        function closeGameStats() {
            // Hide modal
            const modal = document.getElementById('game-stats-modal');
            if (modal) {
                modal.style.display = 'none';
            }
            const endgameOverlay = document.getElementById('endgame-overlay');
            if (endgameOverlay) {
                endgameOverlay.style.display = 'none';
            }

            // Return to main menu
            document.getElementById('start-menu').style.display = 'flex';
            document.getElementById('game-container').style.display = 'none';
            const landingHeader = document.getElementById('landing-header');
            if (landingHeader) landingHeader.style.display = 'block';
            const landingFooter = document.getElementById('landing-footer');
            if (landingFooter) landingFooter.style.display = 'block';
            resetVariantSelections();

            // Reset game stats
            gameStats.warcryBonusCount = { 'W': 0, 'B': 0 };
            gameStats.despairPenaltyCount = { 'W': 0, 'B': 0 };
            gameStats.gameStartTime = null;
            gameStats.gameDuration = 0;
            gameStats.capturesThisRound = { 'W': 0, 'B': 0 };
            gameStats.mostCapturesInRound = { 'W': 0, 'B': 0 };
            gameStats.scoreThisRound = { 'W': 0, 'B': 0 };
            gameStats.highestScoreInRound = { 'W': 0, 'B': 0 };
            gameStats.summonCount = { 'W': 0, 'B': 0 };
            gameStats.reinforcementCount = { 'W': 0, 'B': 0 };
        }

        function renderBoard() {
            const boardDiv = document.getElementById('board');
            boardDiv.innerHTML = '';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const square = document.createElement('div');
                    square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = r;
                    square.dataset.col = c;
                    if (board[r][c]) {
                        const pieceSpan = document.createElement('span');
                        pieceSpan.className = `piece ${board[r][c].player === 'W' ? 'white' : 'black'}`;
                        pieceSpan.textContent = pieceIcons[board[r][c].type];
                        pieceSpan.style.color = board[r][c].player === 'W' ? 'black' : 'white';
                        square.appendChild(pieceSpan);
                        if (board[r][c].facing) {
                            const arrow = document.createElement('span');
                            arrow.className = 'piece-arrow';
                            arrow.textContent = facingIcons[board[r][c].facing];
                            arrow.style.color = board[r][c].player === 'W' ? 'white' : 'black';
                            square.appendChild(arrow);
                        }
                    }
                    const squareKey = `${r},${c}`;
                    if (energyBlastResidualSquares.has(squareKey)) {
                        square.classList.add('energy-blast-residual');
                    }
                    square.addEventListener('click', () => handleClick(r, c));
                    boardDiv.appendChild(square);
                    if (currentPlayer === 'B' && highlightSquares.some(([hr, hc]) => hr == r && hc == c)) {
                        square.classList.add('ai-move-highlight');
                    }
                }
            }
            updateControlButtons();
            highlightValidMoves();
            updateScoreDisplay();
            updateEndTurnButton();
            refreshEnergyBlastResidualHighlights();
            // Apply capture effects after rendering
            capturedSquares.forEach(([r, c]) => addCaptureEffect(r, c));
            capturedSquares = [];
            // Extra safety: ensure AI begins if needed (e.g., 36's edge cases)
            ensureAITurnIfNeeded();
        }

        function opponentHasWizards(player) {
            const opponent = player === 'W' ? 'B' : 'W';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] && board[r][c].type === 'Wizard' && board[r][c].player === opponent) {
                        return true;
                    }
                }
            }
            return false;
        }

        function updateControlButtons() {
            const turnButton = document.getElementById('turn-button');
            const turnMoveButton = document.getElementById('turn-move-button');
            const turnShootButton = document.getElementById('turn-shoot-button');
            const archerMoveDiagShootButton = document.getElementById('archer-move-diag-shoot-button');
            const archerDiag2ShootButton = document.getElementById('archer-diag2-shoot-button');
            const guardHonourButton = document.getElementById('guard-honour-button');
            const teleportButton = document.getElementById('teleport-button');
            const teleportSwapButton = document.getElementById('teleport-swap-button');
            const chargeButton = document.getElementById('charge-button');
            const infernoButton = document.getElementById('inferno-button'); // Get Inferno button
            const strafeButton = document.getElementById('strafe-button'); // Get Strafe button
            const summonSpectreButton = document.getElementById('summon-spectre-button'); // Get Summon Spectre button
            const energyBlastButton = document.getElementById('energy-blast-button');
            const sacrificeButton = document.getElementById('sacrifice-button');
            let huntsmanBurstButton = document.getElementById('huntsman-burst-button');
            // Ballista special buttons
            let ballistaRangeButton = document.getElementById('ballista-range-button');
            let ballistaDoubleButton = document.getElementById('ballista-double-button');
            if (!ballistaRangeButton) {
                ballistaRangeButton = document.createElement('button');
                ballistaRangeButton.id = 'ballista-range-button';
                ballistaRangeButton.textContent = 'Extend Range';
                ballistaRangeButton.style.display = 'none';
                ballistaRangeButton.onclick = activateBallistaRange;
                document.getElementById('controls').insertBefore(ballistaRangeButton, document.getElementById('guard-honour-button'));
            }
            if (!ballistaDoubleButton) {
                ballistaDoubleButton = document.createElement('button');
                ballistaDoubleButton.id = 'ballista-double-button';
                ballistaDoubleButton.textContent = 'Double Time';
                ballistaDoubleButton.style.display = 'none';
                ballistaDoubleButton.onclick = activateBallistaDoubleTime;
                document.getElementById('controls').insertBefore(ballistaDoubleButton, document.getElementById('guard-honour-button'));
            }
            // Elephantry special buttons
            let elephantryChargeButton = document.getElementById('elephantry-charge-button');
            let elephantryExtendedButton = document.getElementById('elephantry-extended-button');
            let elephantryMoveShootButton = document.getElementById('elephantry-moveshoot-button');
            if (!elephantryChargeButton) {
                elephantryChargeButton = document.createElement('button');
                elephantryChargeButton.id = 'elephantry-charge-button';
                elephantryChargeButton.textContent = 'Charge';
                elephantryChargeButton.style.display = 'none';
                elephantryChargeButton.onclick = activateElephantryCharge;
                document.getElementById('controls').insertBefore(elephantryChargeButton, document.getElementById('guard-honour-button'));
            }
            if (!elephantryExtendedButton) {
                elephantryExtendedButton = document.createElement('button');
                elephantryExtendedButton.id = 'elephantry-extended-button';
                elephantryExtendedButton.textContent = 'Triple Shot';
                elephantryExtendedButton.style.display = 'none';
                elephantryExtendedButton.onclick = activateElephantryExtendedRange;
                document.getElementById('controls').insertBefore(elephantryExtendedButton, document.getElementById('guard-honour-button'));
            }
            if (!elephantryMoveShootButton) {
                elephantryMoveShootButton = document.createElement('button');
                elephantryMoveShootButton.id = 'elephantry-moveshoot-button';
                elephantryMoveShootButton.textContent = 'Move+Shoot';
                elephantryMoveShootButton.style.display = 'none';
                elephantryMoveShootButton.onclick = activateElephantryMoveShoot;
                document.getElementById('controls').insertBefore(elephantryMoveShootButton, document.getElementById('guard-honour-button'));
            }
            // Pistolier special buttons
            let pistolierMoveShootButton = document.getElementById('pistolier-moveshoot-button');
            if (!pistolierMoveShootButton) {
                pistolierMoveShootButton = document.createElement('button');
                pistolierMoveShootButton.id = 'pistolier-moveshoot-button';
                pistolierMoveShootButton.textContent = 'Move+Shoot';
                pistolierMoveShootButton.style.display = 'none';
                pistolierMoveShootButton.onclick = activatePistolierMoveShoot;
                document.getElementById('controls').insertBefore(pistolierMoveShootButton, document.getElementById('guard-honour-button'));
            }
            // Fusilier special buttons
            let fusilierCrackShotButton = document.getElementById('fusilier-crackshot-button');
            let fusilierStrafeButton = document.getElementById('fusilier-strafe-button');
            if (!fusilierCrackShotButton) {
                fusilierCrackShotButton = document.createElement('button');
                fusilierCrackShotButton.id = 'fusilier-crackshot-button';
                fusilierCrackShotButton.textContent = 'Crack Shot';
                fusilierCrackShotButton.style.display = 'none';
                fusilierCrackShotButton.onclick = activateFusilierCrackShot;
                document.getElementById('controls').insertBefore(fusilierCrackShotButton, document.getElementById('guard-honour-button'));
            }
            if (!fusilierStrafeButton) {
                fusilierStrafeButton = document.createElement('button');
                fusilierStrafeButton.id = 'fusilier-strafe-button';
                fusilierStrafeButton.textContent = 'Strafe';
                fusilierStrafeButton.style.display = 'none';
                fusilierStrafeButton.onclick = activateFusilierStrafe;
                document.getElementById('controls').insertBefore(fusilierStrafeButton, document.getElementById('guard-honour-button'));
            }
            // King summoning button
            let kingSummonButton = document.getElementById('king-summon-button');
            if (!kingSummonButton) {
                kingSummonButton = document.createElement('button');
                kingSummonButton.id = 'king-summon-button';
                kingSummonButton.textContent = 'Summon Unit';
                kingSummonButton.style.display = 'none';
                kingSummonButton.onclick = openKingSummonModal;
                document.getElementById('controls').insertBefore(kingSummonButton, document.getElementById('guard-honour-button'));
            }
            let moralBoostButton = document.getElementById('moral-boost-button');
            if (!moralBoostButton) {
                moralBoostButton = document.createElement('button');
                moralBoostButton.id = 'moral-boost-button';
                moralBoostButton.textContent = 'Moral Boost';
                moralBoostButton.style.display = 'none';
                moralBoostButton.onclick = activateMoralBoost;
                document.getElementById('controls').insertBefore(moralBoostButton, document.getElementById('guard-honour-button'));
            }
            let kingShotButton = document.getElementById('king-shot-button');
            if (!kingShotButton) {
                kingShotButton = document.createElement('button');
                kingShotButton.id = 'king-shot-button';
                kingShotButton.textContent = 'King Shot';
                kingShotButton.style.display = 'none';
                kingShotButton.onclick = activateKingShot;
                document.getElementById('controls').insertBefore(kingShotButton, document.getElementById('guard-honour-button'));
            }
            let kingEvadeButton = document.getElementById('king-evade-button');
            if (!kingEvadeButton) {
                kingEvadeButton = document.createElement('button');
                kingEvadeButton.id = 'king-evade-button';
                kingEvadeButton.textContent = 'Evade';
                kingEvadeButton.style.display = 'none';
                kingEvadeButton.onclick = activateKingEvade;
                document.getElementById('controls').insertBefore(kingEvadeButton, document.getElementById('guard-honour-button'));
            }
            let necromancerZombieButton = document.getElementById('necromancer-summon-zombie-button');
            if (!necromancerZombieButton) {
                necromancerZombieButton = document.createElement('button');
                necromancerZombieButton.id = 'necromancer-summon-zombie-button';
                necromancerZombieButton.textContent = 'Summon Zombie';
                necromancerZombieButton.style.display = 'none';
                necromancerZombieButton.onclick = () => activateNecromancerSummon('zombie');
                document.getElementById('controls').insertBefore(necromancerZombieButton, document.getElementById('guard-honour-button'));
            }
            let necromancerSpectreButton = document.getElementById('necromancer-summon-spectre-button');
            if (!necromancerSpectreButton) {
                necromancerSpectreButton = document.createElement('button');
                necromancerSpectreButton.id = 'necromancer-summon-spectre-button';
                necromancerSpectreButton.textContent = 'Summon Spectre';
                necromancerSpectreButton.style.display = 'none';
                necromancerSpectreButton.onclick = () => activateNecromancerSummon('spectre');
                document.getElementById('controls').insertBefore(necromancerSpectreButton, document.getElementById('guard-honour-button'));
            }
            let necromancerTeleportButton = document.getElementById('necromancer-teleport-button');
            if (!necromancerTeleportButton) {
                necromancerTeleportButton = document.createElement('button');
                necromancerTeleportButton.id = 'necromancer-teleport-button';
                necromancerTeleportButton.textContent = 'Necro Teleport';
                necromancerTeleportButton.style.display = 'none';
                necromancerTeleportButton.onclick = activateTeleport;
                document.getElementById('controls').insertBefore(necromancerTeleportButton, document.getElementById('guard-honour-button'));
            }
            let championSummonNecroButton = document.getElementById('champion-summon-necro-button');
            if (!championSummonNecroButton) {
                championSummonNecroButton = document.createElement('button');
                championSummonNecroButton.id = 'champion-summon-necro-button';
                championSummonNecroButton.textContent = 'Summon Necromancer';
                championSummonNecroButton.style.display = 'none';
                championSummonNecroButton.onclick = () => activateChampionSummon('Necromancer');
                document.getElementById('controls').insertBefore(championSummonNecroButton, document.getElementById('guard-honour-button'));
            }
            let championSummonHuntsmanButton = document.getElementById('champion-summon-huntsman-button');
            if (!championSummonHuntsmanButton) {
                championSummonHuntsmanButton = document.createElement('button');
                championSummonHuntsmanButton.id = 'champion-summon-huntsman-button';
                championSummonHuntsmanButton.textContent = 'Summon Huntsman';
                championSummonHuntsmanButton.style.display = 'none';
                championSummonHuntsmanButton.onclick = () => activateChampionSummon('Huntsman');
                document.getElementById('controls').insertBefore(championSummonHuntsmanButton, document.getElementById('guard-honour-button'));
            }
            if (!huntsmanBurstButton) {
                huntsmanBurstButton = document.createElement('button');
                huntsmanBurstButton.id = 'huntsman-burst-button';
                huntsmanBurstButton.textContent = 'Stalking Burst';
                huntsmanBurstButton.style.display = 'none';
                huntsmanBurstButton.onclick = activateHuntsmanBurst;
                document.getElementById('controls').insertBefore(huntsmanBurstButton, document.getElementById('guard-honour-button'));
            }

            turnButton.style.display = 'none';
            turnMoveButton.style.display = 'none';
            turnShootButton.style.display = 'none';
            archerMoveDiagShootButton.style.display = 'none';
            archerDiag2ShootButton.style.display = 'none';
            guardHonourButton.style.display = 'none';
            if (moralBoostButton) moralBoostButton.style.display = 'none';
            if (kingShotButton) kingShotButton.style.display = 'none';
            if (kingEvadeButton) kingEvadeButton.style.display = 'none';
            teleportButton.style.display = 'none';
            teleportSwapButton.style.display = 'none';
            chargeButton.style.display = 'none';
            infernoButton.style.display = 'none'; // Hide Inferno button by default
            strafeButton.style.display = 'none'; // Hide Strafe button by default
            summonSpectreButton.style.display = 'none'; // Hide Summon Spectre button by default
            if (energyBlastButton) {
                energyBlastButton.style.display = 'none';
                energyBlastButton.disabled = true;
            }
            if (sacrificeButton) {
                sacrificeButton.style.display = 'none';
                sacrificeButton.disabled = true;
            }
            if (ballistaRangeButton) ballistaRangeButton.style.display = 'none';
            if (ballistaDoubleButton) ballistaDoubleButton.style.display = 'none';
            if (elephantryChargeButton) elephantryChargeButton.style.display = 'none';
            if (elephantryExtendedButton) elephantryExtendedButton.style.display = 'none';
            if (elephantryMoveShootButton) elephantryMoveShootButton.style.display = 'none';
            if (pistolierMoveShootButton) pistolierMoveShootButton.style.display = 'none';
            if (fusilierCrackShotButton) fusilierCrackShotButton.style.display = 'none';
            if (fusilierStrafeButton) fusilierStrafeButton.style.display = 'none';
            if (kingSummonButton) kingSummonButton.style.display = 'none';
            if (necromancerZombieButton) necromancerZombieButton.style.display = 'none';
            if (necromancerSpectreButton) necromancerSpectreButton.style.display = 'none';
            if (necromancerTeleportButton) necromancerTeleportButton.style.display = 'none';
            if (championSummonNecroButton) championSummonNecroButton.style.display = 'none';
            if (championSummonHuntsmanButton) championSummonHuntsmanButton.style.display = 'none';
            if (huntsmanBurstButton) huntsmanBurstButton.style.display = 'none';

            if (selectedPiece) {
                const piece = board[selectedPiece.row][selectedPiece.col];
                if (piece && piece.player === currentPlayer && !movedPieces.has(`${selectedPiece.row},${selectedPiece.col}`) && !lastAction?.move) {
                    if (turnablePieces.includes(piece.type)) {
                        turnButton.style.display = 'inline';
                        turnButton.disabled = movesLeft < turnCosts[piece.type];
                        if (piece.type === 'Infantry') {
                            turnMoveButton.style.display = 'inline';
                            turnMoveButton.disabled = movesLeft < 2;
                        }
                        if (piece.type === 'Archer') {
                            turnShootButton.style.display = 'inline';
                            turnShootButton.disabled = movesLeft < 2;
                        }
                    }
                    if (piece.type === 'Archer' && movesLeft >= 2) {
                        if (archerMoveDiagShootUsed[currentPlayer] < 2) {
                            archerMoveDiagShootButton.style.display = 'inline';
                            archerMoveDiagShootButton.disabled = false;
                        }
                        if (archerDiag2ShootUsed[currentPlayer] < 2) {
                            archerDiag2ShootButton.style.display = 'inline';
                            archerDiag2ShootButton.disabled = false;
                        }
                    }
                    if (piece.type === 'King' && !kingSpecialUsed[currentPlayer] && movesLeft >= 2) {
                        guardHonourButton.style.display = 'inline';
                        guardHonourButton.disabled = false;
                    }
                    if (piece.type === 'King') {
                        const kingPiece = piece;
                        const canUseKingShot = hasKingShotAvailableForPiece(kingPiece);
                        if (moralBoostButton && moralBoostUses[currentPlayer] < MORAL_BOOST_LIMIT && movesLeft === 1) {
                            moralBoostButton.style.display = 'inline';
                            moralBoostButton.disabled = false;
                        }
                        if (kingShotButton && canUseKingShot && movesLeft >= 1 && isKingAdjacentToGuard(selectedPiece.row, selectedPiece.col, currentPlayer)) {
                            const targets = getKingShotTargets(selectedPiece.row, selectedPiece.col, currentPlayer);
                            if (targets.length) {
                                kingShotButton.style.display = 'inline';
                                kingShotButton.disabled = false;
                            }
                        }
                        if (kingEvadeButton && !kingEvadeUsed[currentPlayer] && isKingThreatened(currentPlayer)) {
                            kingEvadeButton.style.display = 'inline';
                            kingEvadeButton.disabled = false;
                        }
                    }
                    // Show King summon button in Expert-tier modes
                    if (piece.type === 'King' && (gameVariant === '36s-expert' || gameVariant === '36s-elite' || gameVariant === '36s-supreme') && movesLeft >= 2 && hasBackRowSpawnSlot(currentPlayer)) {
                        const canSummonPistolier = pistoliersSummoned[currentPlayer] < 2;
                        const canSummonFusilier = fusiliersSummoned[currentPlayer] < 2;
                        if (canSummonPistolier || canSummonFusilier) {
                            kingSummonButton.style.display = 'inline';
                            kingSummonButton.disabled = false;
                        }
                    }
                    if (piece.type === 'Champion' && (gameVariant === '36s-elite' || gameVariant === '36s-supreme')) {
                        const hasSlot = hasBackRowSpawnSlot(currentPlayer);
                        if (championSummonNecroButton) {
                            const canSummonNecro = canChampionSummonNecromancer(currentPlayer) && hasSlot;
                            if (canSummonNecro) {
                                championSummonNecroButton.style.display = 'inline';
                                championSummonNecroButton.disabled = movesLeft < 2;
                            }
                        }
                        if (championSummonHuntsmanButton) {
                            const canSummonHuntsman = canChampionSummonHuntsman(currentPlayer) && hasSlot;
                            if (canSummonHuntsman) {
                                championSummonHuntsmanButton.style.display = 'inline';
                                championSummonHuntsmanButton.disabled = movesLeft < 2;
                            }
                        }
                    }
                    if (piece.type === 'Necromancer' && (gameVariant === '36s-elite' || gameVariant === '36s-supreme')) {
                        const pieceKey = board[selectedPiece.row][selectedPiece.col];
                        const teleportsUsed = getNecromancerTeleportCount(pieceKey);
                        if (movesLeft >= 2) {
                            const backRow = currentPlayer === 'W' ? ROWS - 1 : 0;
                            const availableBackRow = Array.from({ length: COLS }, (_, c) => c).some(c => !board[backRow][c]);
                            const maxZombies = getMaxZombies(currentPlayer);
                            if (zombiesSummoned[currentPlayer] < maxZombies && availableBackRow) {
                                necromancerZombieButton.style.display = 'inline';
                                necromancerZombieButton.disabled = false;
                            }
                            if (spectresSummoned[currentPlayer] < 2 && availableBackRow) {
                                necromancerSpectreButton.style.display = 'inline';
                                necromancerSpectreButton.disabled = false;
                            }
                            if (teleportsUsed < 2) {
                                necromancerTeleportButton.style.display = 'inline';
                                necromancerTeleportButton.disabled = false;
                            }
                        }
                    }
                    if (piece.type === 'Wizard' && wizardTeleportUsed[currentPlayer] < 2 && movesLeft >= 2) {
                        teleportButton.style.display = 'inline';
                        teleportButton.disabled = false;
                    }
                    if (piece.type === 'Wizard' && !wizardTeleportSwapUsed[currentPlayer] && movesLeft >= 2 && opponentHasWizards(currentPlayer)) {
                        teleportSwapButton.style.display = 'inline';
                        teleportSwapButton.disabled = false;
                    }
                    if (piece.type === 'Cavalry' && !cavalryChargeUsed[currentPlayer] && movesLeft >= 2) {
                        chargeButton.style.display = 'inline';
                        chargeButton.disabled = false;
                    }
                    // Show Inferno button
                    if (piece.type === 'Dragon' && !dragonInfernoUsed[currentPlayer] && movesLeft >= 2) {
                        infernoButton.style.display = 'inline';
                        infernoButton.disabled = false;
                    }
                    // Show Strafe button for Wizard or Dragon
                    if ((piece.type === 'Wizard' && wizardStrafeUsed[currentPlayer] < 2 && movesLeft >= 2) ||
                        (piece.type === 'Dragon' && dragonStrafeUsed[currentPlayer] < 2 && movesLeft >= 2)) {
                        strafeButton.style.display = 'inline';
                        strafeButton.disabled = false;
                    }
                    // Show Summon Spectre button for Wizard
                    if (piece.type === 'Wizard' && movesLeft >= 2 && spectresSummoned[currentPlayer] < 2 && !wizardSummonedThisTurn[currentPlayer]) {
                        const totalCaptured = capturedPieces['W'].length + capturedPieces['B'].length;
                        if (totalCaptured >= 5) {
                            summonSpectreButton.style.display = 'inline';
                            summonSpectreButton.disabled = false;
                        }
                    }
                    if (isSpellVariant() && isSpellCasterPiece(piece)) {
                        if (energyBlastButton) {
                            const totalUses = energyBlastUses[currentPlayer] || 0;
                            const uses = energyBlastUsage.get(piece) || 0;
                            if (totalUses < 2 && uses < 2) {
                                const blastCost = uses === 0 ? 2 : 3;
                                energyBlastButton.style.display = 'inline';
                                energyBlastButton.disabled = movesLeft < blastCost;
                            } else {
                                energyBlastButton.style.display = 'none';
                                energyBlastButton.disabled = true;
                            }
                        }
                        if (sacrificeButton) {
                            sacrificeButton.style.display = 'inline';
                            sacrificeButton.disabled = movesLeft < 3 || sacrificeAttemptedPieces.has(piece);
                        }
                    }
                    if (huntsmanBurstButton && piece.type === 'Huntsman' && gameVariant === '36s-supreme') {
                        const pieceKey = `${selectedPiece.row},${selectedPiece.col}`;
                        huntsmanBurstButton.style.display = 'inline';
                        huntsmanBurstButton.disabled = movesLeft < 2 || pendingHuntsmanBurst !== null || movedPieces.has(pieceKey);
                    }
                    if (piece.type === 'Ballista' && movesLeft >= 2) {
                        if (!ballistaRangeBoostUsedThisTurn[currentPlayer]) {
                            ballistaRangeButton.style.display = 'inline';
                            ballistaRangeButton.disabled = false;
                        }
                        if (ballistaDoubleTimeUsed[currentPlayer] < 2) {
                            ballistaDoubleButton.style.display = 'inline';
                            ballistaDoubleButton.disabled = false;
                        }
                    }
                    if (piece.type === 'Elephantry' && movesLeft >= 2) {
                        const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
                        if (!elephantryChargeUsed.has(pieceKey)) {
                            elephantryChargeButton.style.display = 'inline';
                            elephantryChargeButton.disabled = false;
                        }
                        // Initialize shots remaining if not set
                        if (!(pieceKey in elephantryExtendedRangeShotsRemaining)) {
                            elephantryExtendedRangeShotsRemaining[pieceKey] = 3;
                        }
                        if (elephantryExtendedRangeShotsRemaining[pieceKey] > 0) {
                            elephantryExtendedButton.style.display = 'inline';
                            elephantryExtendedButton.disabled = false;
                            elephantryExtendedButton.textContent = `Triple Shot (${elephantryExtendedRangeShotsRemaining[pieceKey]})`;
                        }
                        // Show Move+Shoot button if there are valid move+shoot positions
                        const moveShootMoves = validMoves.filter(m => m.special === 'elephantryMoveShoot');
                        if (moveShootMoves.length > 0) {
                            elephantryMoveShootButton.style.display = 'inline';
                            elephantryMoveShootButton.disabled = false;
                        }
                    }
                    if (piece.type === 'Pistolier' && movesLeft >= 2) {
                        // Show Move+Shoot button if there are valid move+shoot positions
                        const moveShootMoves = validMoves.filter(m => m.special === 'pistolierMoveShoot');
                        if (moveShootMoves.length > 0) {
                            pistolierMoveShootButton.style.display = 'inline';
                            pistolierMoveShootButton.disabled = false;
                        }
                    }
                    if (piece.type === 'Fusilier' && movesLeft >= 2) {
                        const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
                        // Initialize counts if not set
                        if (!(pieceKey in fusilierCrackShotCount)) {
                            fusilierCrackShotCount[pieceKey] = 3;
                        }
                        if (!(pieceKey in fusilierStrafeCount)) {
                            fusilierStrafeCount[pieceKey] = 2;
                        }
                        const fusilierPiece = piece;
                        const fusilierOnCooldown = fusilierShotLastTurn[currentPlayer].has(fusilierPiece) ||
                            fusilierShotThisTurn[currentPlayer].has(fusilierPiece);
                        // Show Crack Shot button if uses remaining and not on cooldown
                        if (fusilierCrackShotCount[pieceKey] > 0 && !fusilierOnCooldown) {
                            fusilierCrackShotButton.style.display = 'inline';
                            fusilierCrackShotButton.disabled = false;
                            fusilierCrackShotButton.textContent = `Crack Shot (${fusilierCrackShotCount[pieceKey]})`;
                        } else {
                            fusilierCrackShotButton.style.display = 'none';
                        }
                        // Show Strafe button if uses remaining
                        if (fusilierStrafeCount[pieceKey] > 0) {
                            fusilierStrafeButton.style.display = 'inline';
                            fusilierStrafeButton.disabled = false;
                            fusilierStrafeButton.textContent = `Strafe (${fusilierStrafeCount[pieceKey]})`;
                        }
                    }
                }
            }
        }

        function updateScoreDisplay() {
            const playerScoreEl = document.getElementById('player-score-value');
            const aiScoreEl = document.getElementById('ai-score-value');
            const aiNameEl = document.getElementById('ai-name-label');
            if (playerScoreEl) {
                playerScoreEl.textContent = `Score: ${scores['W']}`;
            }
            if (aiScoreEl) {
                aiScoreEl.textContent = `Score: ${scores['B']}`;
            }
            if (aiNameEl) {
                aiNameEl.textContent = getOpponentDisplayName();
            }
        }

        function showPieceInfo(piece, player) {
            const infoBox = document.getElementById('info-box');
            if (!piece) {
                infoBox.style.display = 'none';
                infoBox.innerHTML = '';
                return;
            }
            const info = pieceInfo[piece.type];
            infoBox.style.display = 'block';
            infoBox.innerHTML = `
                <strong>${player === 'W' ? 'White' : 'Black'} ${piece.type}</strong><br>
                <strong>Move Points:</strong> ${info.points}<br>
                <strong>Score Value:</strong> ${pieceValues[piece.type]} points<br>
                <strong>Extra Info:</strong> ${info.extra}${piece.facing ? `<br><strong>Facing:</strong> ${piece.facing} (${facingIcons[piece.facing]})` : ''}
            `;
            constrainElementToBoardBounds(infoBox, getBoardAnchorRect());
        }

        function updateGameLog() {
            const logDiv = document.getElementById('game-log');
            logDiv.innerHTML = gameLog.join('<br>');
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function getValidTurnDirections(currentFacing) {
            const validDirections = {
                'U': ['L', 'R'],
                'D': ['L', 'R'],
                'L': ['U', 'D'],
                'R': ['U', 'D']
            };
            return validDirections[currentFacing] || [];
        }

        function isSpellVariant() {
            return gameVariant === '36s-supreme';
        }

        function isSpellCasterPiece(piece) {
            return !!piece && (piece.type === 'Wizard' || piece.type === 'Necromancer');
        }

        function getSpellDirectionOptions(player) {
            const forwardStep = player === 'W' ? -1 : 1;
            return [
                { id: 'forward', label: 'Forward', dr: forwardStep, dc: 0 },
                { id: 'diagLeft', label: 'Forward-Left', dr: forwardStep, dc: player === 'W' ? -1 : 1 },
                { id: 'diagRight', label: 'Forward-Right', dr: forwardStep, dc: player === 'W' ? 1 : -1 }
            ];
        }

        function openSpellDirectionModal(action) {
            const modal = document.getElementById('spell-direction-modal');
            const select = document.getElementById('spell-direction-select');
            if (!modal || !select) return;
            const piece = board[action.row]?.[action.col];
            if (!piece) return;
            const options = getSpellDirectionOptions(piece.player);
            if (!options.length) return;
            select.innerHTML = options.map(opt => `<option value="${opt.id}">${opt.label}</option>`).join('');
            document.getElementById('spell-direction-title').textContent = action.type === 'energyBlast'
                ? 'Select Energy Blast Direction'
                : 'Select Direction';
            pendingSpellAction = { ...action, directions: options, player: piece.player };
            modal.style.display = 'block';
        }

        function closeSpellDirectionModal(options = {}) {
            const { keepGlow = false } = options;
            const modal = document.getElementById('spell-direction-modal');
            if (modal) {
                modal.style.display = 'none';
            }
            pendingSpellAction = null;
            if (!keepGlow) {
                activeEnergyBlastCost = null;
                removeEnergyBlastGlow();
            }
        }

        function confirmSpellDirection() {
            if (!pendingSpellAction) {
                closeSpellDirectionModal();
                return;
            }
            const select = document.getElementById('spell-direction-select');
            const directionId = select ? select.value : null;
            const direction = pendingSpellAction.directions.find(opt => opt.id === directionId) || pendingSpellAction.directions[0];
            const action = { ...pendingSpellAction };
            closeSpellDirectionModal({ keepGlow: true });
            if (action.type === 'energyBlast' && direction) {
                performEnergyBlast(action.row, action.col, direction);
            }
        }

        function startEnergyBlastFlipSequence(context) {
            energyBlastFlipContext = {
                context,
                flips: [],
                successes: 0
            };
            pauseGameForEnergyBlastFlips();
            runNextEnergyBlastFlip();
        }

        function runNextEnergyBlastFlip() {
            const ctx = energyBlastFlipContext;
            if (!ctx) return;
            if (ctx.flips.length >= ENERGY_BLAST_FLIP_COUNT) {
                coinTossEnergyBlastMode = null;
                updateCoinTossEnergyBlastProgress();
                energyBlastFlipContext = null;
                resumeGameForEnergyBlastFlips();
                completeEnergyBlastAfterRange(ctx.context, ctx.successes, ctx.flips);
                return;
            }
            const flipNumber = ctx.flips.length + 1;
            coinTossEnergyBlastMode = { successes: ctx.successes, total: ENERGY_BLAST_FLIP_COUNT };
            updateCoinTossEnergyBlastProgress();
            pauseGameForEnergyBlastFlips();
            performCoinToss(
                'Energy Blast',
                `Flip ${flipNumber} of ${ENERGY_BLAST_FLIP_COUNT}`,
                (result) => {
                    if (!energyBlastFlipContext) {
                        return;
                    }
                    ctx.flips.push(result);
                    if (result) ctx.successes++;
                    if (coinTossEnergyBlastMode) {
                        coinTossEnergyBlastMode.successes = ctx.successes;
                        updateCoinTossEnergyBlastProgress();
                    }
                    pauseGameForEnergyBlastFlips();
                    runNextEnergyBlastFlip();
                },
                true,
                false
            );
        }

        function evaluateEnergyBlastDirection(row, col, direction, piece) {
            if (!direction) return 0;
            let expected = 0;
            let targetRow = row;
            let targetCol = col;
            for (let step = 1; step <= ENERGY_BLAST_FLIP_COUNT; step++) {
                targetRow += direction.dr;
                targetCol += direction.dc;
                if (!isValid(targetRow, targetCol)) break;
                const occupant = board[targetRow][targetCol];
                if (!occupant || occupant.player === piece.player) continue;
                const baseValue = aiPieceValues[occupant.type] !== undefined
                    ? aiPieceValues[occupant.type]
                    : (pieceValues[occupant.type] || 0);
                let value = baseValue;
                if (occupant.type === 'King') {
                    value += baseValue * 50;
                } else if (occupant.type === 'Champion') {
                    value += 6;
                }
                expected += value * (ENERGY_BLAST_STEP_PROBABILITIES[step] || 0);
            }
            return expected;
        }

        function findAiEnergyBlastOpportunity(player, availableMoves, movedSet) {
            if (player !== 'B' || !isSpellVariant() || availableMoves < 2) return null;
            if ((energyBlastUses[player] || 0) >= 2) return null;
            const opportunities = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player) continue;
                    if (!isSpellCasterPiece(piece)) continue;
                    if (movedSet.has(`${r},${c}`)) continue;
                    const uses = energyBlastUsage.get(piece) || 0;
                    if (uses >= 2) continue;
                    const cost = uses === 0 ? 2 : 3;
                    if (availableMoves < cost) continue;
                    const directions = getSpellDirectionOptions(player);
                    for (const direction of directions) {
                        const expected = evaluateEnergyBlastDirection(r, c, direction, piece);
                        if (expected <= 0) continue;
                        const score = expected - cost * 1.5;
                        opportunities.push({ score, from: [r, c], direction, cost });
                    }
                }
            }
            if (!opportunities.length) return null;
            opportunities.sort((a, b) => b.score - a.score);
            const best = opportunities[0];
            if (best.score < ENERGY_BLAST_AI_THRESHOLD) return null;
            return {
                type: 'energyBlast',
                from: best.from,
                direction: best.direction,
                cost: best.cost,
                prepaid: Math.min(2, best.cost)
            };
        }

        function listSacrificeTargets(row, col, player) {
            const enemy = getOpponent(player);
            const targets = [];
            const orthogonal = [[1, 0], [-1, 0], [0, 1], [0, -1]];
            for (const [dr, dc] of orthogonal) {
                for (let step = 1; step <= 2; step++) {
                    const targetRow = row + dr * step;
                    const targetCol = col + dc * step;
                    if (!isValid(targetRow, targetCol)) break;
                    const occupant = board[targetRow]?.[targetCol];
                    if (occupant && occupant.player === enemy) {
                        targets.push({ row: targetRow, col: targetCol, piece: occupant });
                    }
                }
            }
            const diagonals = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (const [dr, dc] of diagonals) {
                const targetRow = row + dr;
                const targetCol = col + dc;
                if (!isValid(targetRow, targetCol)) continue;
                const occupant = board[targetRow]?.[targetCol];
                if (occupant && occupant.player === enemy) {
                    targets.push({ row: targetRow, col: targetCol, piece: occupant });
                }
            }
            return targets;
        }

        function evaluateSacrificeTargets(player, piece, targets) {
            if (!targets.length) return -Infinity;
            let captureValue = 0;
            let kingBonus = 0;
            for (const target of targets) {
                const value = aiPieceValues[target.piece.type] !== undefined
                    ? aiPieceValues[target.piece.type]
                    : (pieceValues[target.piece.type] || 0);
                captureValue += value;
                if (target.piece.type === 'King') {
                    kingBonus = Math.max(kingBonus, value * 80);
                } else if (target.piece.type === 'Champion') {
                    captureValue += 6;
                }
            }
            const expectedCapture = captureValue * SACRIFICE_SUCCESS_PROBABILITY + kingBonus;
            const selfValue = (aiPieceValues[piece.type] || pieceValues[piece.type] || 0) * SACRIFICE_SUCCESS_PROBABILITY;
            const movePenalty = 3 * 1.1;
            return expectedCapture - selfValue - movePenalty;
        }

        function findAiSacrificeOpportunity(player, availableMoves, movedSet) {
            if (player !== 'B' || !isSpellVariant() || availableMoves < 3) return null;
            let best = null;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player) continue;
                    if (!isSpellCasterPiece(piece)) continue;
                    if (movedSet.has(`${r},${c}`)) continue;
                    if (sacrificeAttemptedPieces.has(piece)) continue;
                    const targets = listSacrificeTargets(r, c, player);
                    if (!targets.length) continue;
                    const score = evaluateSacrificeTargets(player, piece, targets);
                    if (!best || score > best.score) {
                        best = { score, from: [r, c] };
                    }
                }
            }
            if (best && best.score > SACRIFICE_AI_THRESHOLD) {
                return { type: 'sacrifice', from: best.from, cost: 3 };
            }
            return null;
        }

        function findAiZombieSummonOpportunity(player, availableMoves, movedSet) {
            if (player !== 'B' || availableMoves < 2) return null;
            if (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme') return null;
            const maxZombies = getMaxZombies(player);
            if ((zombiesSummoned[player] || 0) >= maxZombies) return null;
            const candidates = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player || piece.type !== 'Necromancer') continue;
                    if (movedSet.has(`${r},${c}`)) continue;
                    candidates.push({ row: r, col: c });
                }
            }
            if (!candidates.length || !hasBackRowSpawnSlot(player)) return null;
            const spawnCol = findBackRowSpawnColumn(player);
            if (spawnCol === null) return null;
            const chosen = candidates[Math.floor(Math.random() * candidates.length)];
            return {
                type: 'summon',
                special: 'summonZombie',
                from: [chosen.row, chosen.col],
                pos: [getBackRow(player), spawnCol],
                cost: 2
            };
        }

        function findAiChampionSummonOpportunity(player, availableMoves, movedSet) {
            if (player !== 'B' || availableMoves < 2) return null;
            if (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme') return null;
            if (!hasBackRowSpawnSlot(player)) return null;
            const canSummonNecro = canChampionSummonNecromancer(player);
            const canSummonHuntsman = canChampionSummonHuntsman(player);
            if (!canSummonNecro && !canSummonHuntsman) return null;
            let champion = null;
            for (let r = 0; r < ROWS && !champion; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player || piece.type !== 'Champion') continue;
                    if (movedSet.has(`${r},${c}`)) continue;
                    champion = { row: r, col: c };
                    break;
                }
            }
            if (!champion) return null;
            const spawnCol = findBackRowSpawnColumn(player);
            if (spawnCol === null) return null;
            let summonType = 'Necromancer';
            if (!canSummonNecro && canSummonHuntsman) {
                summonType = 'Huntsman';
            } else if (canSummonNecro && canSummonHuntsman) {
                summonType = necromancersSummoned[player] < 2 ? 'Necromancer' : 'Huntsman';
            } else if (!canSummonNecro) {
                return null;
            }
            return {
                type: 'summon',
                special: 'championSummon',
                from: [champion.row, champion.col],
                pos: [getBackRow(player), spawnCol],
                cost: 2,
                summonType
            };
        }

        function findKingSummonOpportunity(player, availableMoves, movedSet) {
            if (player !== 'B' || availableMoves < 2) return null;
            if (!['36s-expert', '36s-elite', '36s-supreme'].includes(gameVariant)) return null;
            if (!hasBackRowSpawnSlot(player)) return null;
            let king = null;
            for (let r = 0; r < ROWS && !king; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece && piece.player === player && piece.type === 'King' && !movedSet.has(`${r},${c}`)) {
                        king = { row: r, col: c };
                        break;
                    }
                }
            }
            if (!king) return null;
            const spawnCol = findBackRowSpawnColumn(player);
            if (spawnCol === null) return null;
            const options = [];
            if ((pistoliersSummoned[player] || 0) < 2) {
                const value = (aiPieceValues['Pistolier'] || pieceValues['Pistolier'] || 3) + 2;
                options.push({ summonType: 'Pistolier', score: value });
            }
            if ((fusiliersSummoned[player] || 0) < 2) {
                const value = (aiPieceValues['Fusilier'] || pieceValues['Fusilier'] || 4) + 1.5;
                options.push({ summonType: 'Fusilier', score: value });
            }
            if (!options.length) return null;
            options.sort((a, b) => b.score - a.score);
            const best = options[0];
            if (best.score < KING_SUMMON_AI_THRESHOLD) return null;
            return {
                type: 'summon',
                special: 'kingSummon',
                from: [king.row, king.col],
                pos: [getBackRow(player), spawnCol],
                cost: 2,
                summonType: best.summonType
            };
        }

        function findAiHuntsmanBurstOpportunity(player, availableMoves, movedSet) {
            if (player !== 'B' || !isSpellVariant() || availableMoves < 2) return null;
            let best = null;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player || piece.type !== 'Huntsman') continue;
                    if (movedSet.has(`${r},${c}`)) continue;
                    const targets = getHuntsmanBurstReach(r, c, HUNTSMAN_BURST_FLIP_COUNT);
                    if (!targets.length) continue;
                    let bestLocal = -Infinity;
                    for (const target of targets) {
                        const prob = HUNTSMAN_BURST_SUCCESS_PROBS[target.steps] || 0;
                        if (prob <= 0) continue;
                        const value = evaluateHuntsmanDestinationValue(target.row, target.col, player, target.occupant);
                        const score = prob * value - 2;
                        if (score > bestLocal) {
                            bestLocal = score;
                        }
                    }
                    if (bestLocal > HUNTSMAN_BURST_AI_THRESHOLD) {
                        if (!best || bestLocal > best.score) {
                            best = { score: bestLocal, from: [r, c] };
                        }
                    }
                }
            }
            if (best) {
                return { type: 'huntsmanBurst', from: best.from, cost: 2 };
            }
            return null;
        }

        function findKingPosition(player) {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece && piece.player === player && piece.type === 'King') {
                        return { row: r, col: c };
                    }
                }
            }
            return null;
        }

        function isSpectreShootImmuneTarget(row, col, attackerPlayer) {
            const target = board[row]?.[col];
            return !!(target && target.player !== attackerPlayer && target.type === 'Spectre');
        }

        function filterShootMovesForPlayer(options, player) {
            return options.filter(option => option.type !== 'shoot' || !isSpectreShootImmuneTarget(option.pos[0], option.pos[1], player));
        }

        function hasKingShotAvailableForPiece(piece) {
            return piece && piece.type === 'King' && !piece.kingShotFired && !kingShotUsed[piece.player];
        }

        function markKingShotUsed(piece) {
            if (!piece || piece.type !== 'King') return;
            piece.kingShotFired = true;
            kingShotUsed[piece.player] = true;
            if (piece.player === 'W') {
                const kingShotButton = document.getElementById('king-shot-button');
                if (kingShotButton) {
                    kingShotButton.style.display = 'none';
                    kingShotButton.disabled = true;
                }
            }
        }

        function resetKingShotFlags() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r]?.[c];
                    if (piece && piece.type === 'King' && piece.kingShotFired) {
                        delete piece.kingShotFired;
                    }
                }
            }
            const kingShotButton = document.getElementById('king-shot-button');
            if (kingShotButton) {
                kingShotButton.disabled = false;
                kingShotButton.style.display = 'none';
            }
        }

        function teleportOntoSquare(fromRow, fromCol, toRow, toCol, player, abilityLabel) {
            const teleportPiece = board[fromRow]?.[fromCol];
            if (!teleportPiece || teleportPiece.player !== player) return { success: false };
            const targetPiece = board[toRow]?.[toCol];
            if (targetPiece) {
                if (targetPiece.player === player || targetPiece.type !== 'Spectre') {
                    if (player === 'W') {
                        gameLog.push(`${abilityLabel} can only target empty squares or enemy Spectres.`);
                        updateGameLog();
                    }
                    return { success: false };
                }
            }
            let capturedPieceType = null;
            if (targetPiece) {
                capturedPieceType = targetPiece.type;
                const actorLabel = player === 'W' ? 'Player' : getOpponentDisplayName();
                const logMessage = `${actorLabel} used ${abilityLabel} to capture ${targetPiece.type} at (${toRow},${toCol}).`;
                if (!applySpellCapture(player, toRow, toCol, { logMessage, ability: abilityLabel })) {
                    return { success: false };
                }
                updateScoreDisplay();
                updateCapturedPiecesDisplay();
                updateGameLog();
            }
            board[toRow][toCol] = teleportPiece;
            board[fromRow][fromCol] = null;
            checkSupremacy(player);
            return { success: true, capturedPieceType };
        }

        function isKingAdjacentToGuard(row, col, player) {
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = row + dr;
                    const nc = col + dc;
                    if (!isValid(nr, nc)) continue;
                    const occupant = board[nr]?.[nc];
                    if (occupant && occupant.player === player && occupant.type === 'Guard') {
                        return true;
                    }
                }
            }
            return false;
        }

        function getKingShotTargets(row, col, player) {
            const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
            const targets = [];
            for (const [dr, dc] of directions) {
                for (let dist = 1; dist <= KING_SHOT_RANGE; dist++) {
                    const nr = row + dr * dist;
                    const nc = col + dc * dist;
                    if (!isValid(nr, nc)) break;
                    const occupant = board[nr][nc];
                    if (!occupant) {
                        continue;
                    }
                    if (occupant.player === player) {
                        break;
                    }
                    if (occupant.type !== 'Spectre') {
                        targets.push([nr, nc]);
                    }
                    break;
                }
            }
            return targets;
        }

        function getKingEvadeMoves(row, col, player) {
            const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
            const visited = new Set([`${row},${col}`]);
            const queue = [{ row, col, steps: 0 }];
            const moves = [];

            while (queue.length) {
                const current = queue.shift();
                if (current.steps >= KING_EVADE_RANGE) continue;
                for (const [dr, dc] of directions) {
                    const nr = current.row + dr;
                    const nc = current.col + dc;
                    if (!isValid(nr, nc)) continue;
                    const key = `${nr},${nc}`;
                    if (visited.has(key)) continue;
                    visited.add(key);
                    const occupant = board[nr]?.[nc];
                    if (!occupant) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 0, special: 'kingEvade' });
                        queue.push({ row: nr, col: nc, steps: current.steps + 1 });
                    } else if (occupant.player !== player) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 0, special: 'kingEvade' });
                        // Cannot move past enemies
                    } else {
                        // Can phase through friendly pieces but cannot end on them
                        queue.push({ row: nr, col: nc, steps: current.steps + 1 });
                    }
                }
            }
            return moves;
        }

        function isKingEvadeDestinationSafe(player, fromRow, fromCol, toRow, toCol) {
            const kingPiece = board[fromRow]?.[fromCol];
            if (!kingPiece || kingPiece.type !== 'King') return false;
            const capturedPiece = board[toRow][toCol];
            board[toRow][toCol] = kingPiece;
            board[fromRow][fromCol] = null;
            const safe = !isKingThreatened(player);
            board[fromRow][fromCol] = kingPiece;
            board[toRow][toCol] = capturedPiece;
            return safe;
        }

        function getBestKingEvadePlan(player, movedSet) {
            if (kingEvadeUsed[player] || !isKingThreatened(player)) return null;
            const kingPos = findKingPosition(player);
            if (!kingPos) return null;
            if (movedSet.has(`${kingPos.row},${kingPos.col}`)) return null;
            const moves = getKingEvadeMoves(kingPos.row, kingPos.col, player);
            let best = null;
            for (const move of moves) {
                const [nr, nc] = move.pos;
                if (!isKingEvadeDestinationSafe(player, kingPos.row, kingPos.col, nr, nc)) continue;
                const occupant = board[nr]?.[nc];
                let score = 0;
                if (occupant && occupant.player !== player) {
                    score += (aiPieceValues[occupant.type] || pieceValues[occupant.type] || 0) * KING_EVADE_CAPTURE_BONUS;
                }
                const distance = Math.abs(nr - kingPos.row) + Math.abs(nc - kingPos.col);
                score += distance * KING_EVADE_DISTANCE_BONUS;
                if (!best || score > best.score) {
                    best = { pos: [nr, nc], score };
                }
            }
            return best ? { from: [kingPos.row, kingPos.col], to: best.pos } : null;
        }

        function getBestKingShotPlan(player, movedSet, availableMoves) {
            if (kingShotUsed[player] || availableMoves < 1 || reinforcementPending) return null;
            const kingPos = findKingPosition(player);
            if (!kingPos) return null;
            if (movedSet.has(`${kingPos.row},${kingPos.col}`)) return null;
            const kingPiece = board[kingPos.row]?.[kingPos.col];
            if (!hasKingShotAvailableForPiece(kingPiece)) return null;
            if (!isKingAdjacentToGuard(kingPos.row, kingPos.col, player)) return null;
            const targets = getKingShotTargets(kingPos.row, kingPos.col, player);
            let best = null;
            for (const [tr, tc] of targets) {
                const targetPiece = board[tr]?.[tc];
                if (!targetPiece || targetPiece.player === player) continue;
                let value = aiPieceValues[targetPiece.type] ?? pieceValues[targetPiece.type] ?? 0;
                if (targetPiece.type === 'King') value += 100;
                if (targetPiece.type === 'Champion') value += 25;
                if (!best || value > best.value) {
                    best = { pos: [tr, tc], value };
                }
            }
            if (!best || best.value < KING_SHOT_AI_THRESHOLD) return null;
            return { from: [kingPos.row, kingPos.col], target: best.pos };
        }

        function getAiMoralBoostTarget(player, movedSet, availableMoves) {
            if (moralBoostUses[player] >= MORAL_BOOST_LIMIT) return null;
            if (availableMoves !== 1 || reinforcementPending) return null;
            const kingPos = findKingPosition(player);
            if (!kingPos) return null;
            if (movedSet.has(`${kingPos.row},${kingPos.col}`)) return null;
            return [kingPos.row, kingPos.col];
        }

        function isKingThreatened(player) {
            const kingPos = findKingPosition(player);
            if (!kingPos) return false;
            const opponent = getOpponent(player);
            const savedCurrentPlayer = currentPlayer;
            const savedMovesLeft = movesLeft;
            let threatened = false;
            currentPlayer = opponent;
            movesLeft = Math.max(savedMovesLeft, 4);
            outer:
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== opponent) continue;
                    const moves = getValidMoves(r, c);
                    for (const move of moves) {
                        if (move.pos[0] === kingPos.row && move.pos[1] === kingPos.col && (move.type === 'move' || move.type === 'shoot')) {
                            threatened = true;
                            break outer;
                        }
                    }
                }
            }
            currentPlayer = savedCurrentPlayer;
            movesLeft = savedMovesLeft;
            return threatened;
        }

        function getProtectionCandidates(player) {
            const types = new Set(['Wizard', 'Necromancer', 'Champion']);
            const candidates = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece && piece.player === player && types.has(piece.type)) {
                        candidates.push({ row: r, col: c, piece });
                    }
                }
            }
            return candidates;
        }

        function chooseAiProtectionCandidate(candidates) {
            if (!candidates.length) return null;
            const sorted = candidates.slice().sort((a, b) => {
                const valueDiff = (pieceValues[a.piece.type] || 0) - (pieceValues[b.piece.type] || 0);
                if (valueDiff !== 0) return valueDiff;
                return (a.row + a.col) - (b.row + b.col);
            });
            return sorted[0];
        }

        function applyProtectionSacrifice(player, row, col) {
            const piece = board[row]?.[col];
            if (!piece) return null;
            registerPieceLoss(player, piece.type);
            if (piece.type === 'Champion') {
                championCaptured[player] = true;
                championsOnBackRow[player] = championsOnBackRow[player].filter(([r, c]) => !(r === row && c === col));
            }
            cleanupNecromancerTracking(piece);
            board[row][col] = null;
            return piece;
        }

        function requestSpellProtection({ attacker, defender, targetRow, targetCol, ability, logMessage, onResolve }) {
            if (!isSpellVariant() || !ability) {
                onResolve(true);
                return 'resolved';
            }
            const targetPiece = board[targetRow]?.[targetCol];
            if (!targetPiece || targetPiece.type !== 'King') {
                onResolve(true);
                return 'resolved';
            }
            if (protectionUsed[defender]) {
                onResolve(true);
                return 'resolved';
            }
            const candidates = getProtectionCandidates(defender);
            const defenderIsAi = isAiPlayer(defender);
            if (!candidates.length) {
                if (defenderIsAi) {
                    gameLog.push(`${getOpponentDisplayName()} could not activate Protection against ${ability}; no Wizards, Necromancers, or Champions remain.`);
                    updateGameLog();
                }
                onResolve(true);
                return 'resolved';
            }
            if (defenderIsAi) {
                const choice = chooseAiProtectionCandidate(candidates);
                if (!choice) {
                    onResolve(true);
                    return 'resolved';
                }
                applyProtectionSacrifice(defender, choice.row, choice.col);
                protectionUsed[defender] = true;
                nextRoundModifier[defender] = (nextRoundModifier[defender] || 0) - 2;
                gameLog.push(`${getOpponentDisplayName()} activated Protection against ${ability}, sacrificing ${choice.piece.type} at (${choice.row},${choice.col}). They will start their next round with 2 fewer move points.`);
                renderBoard();
                updateScoreDisplay();
                updateGameLog();
                onResolve(false);
                return 'resolved';
            }
            openProtectionModal({ attacker, defender, targetRow, targetCol, ability, candidates, logMessage, onResolve });
            return 'pending';
        }

        function openProtectionModal(context) {
            const modal = document.getElementById('protection-modal');
            const select = document.getElementById('protection-select');
            const message = document.getElementById('protection-message');
            if (!modal || !select || !message) {
                context.onResolve(true);
                return;
            }
            pendingProtection = context;
            message.textContent = `Your King is targeted by ${context.ability}. Sacrifice a spellcaster or Champion to activate Protection? (Costs 2 move points at the start of your next round)`;
            select.innerHTML = context.candidates.map(candidate => {
                return `<option value="${candidate.row},${candidate.col}">${candidate.piece.type} at (${candidate.row},${candidate.col})</option>`;
            }).join('');
            pausedTimers.game = gameTimerInterval;
            pausedTimers.turn = turnTimerInterval;
            pausedTimers.turnPlayer = currentTurnTimerPlayer;
            stopGameTimer();
            stopTurnTimer();
            gamePaused = true;
            modal.style.display = 'block';
        }

        function finalizeProtectionModal() {
            const modal = document.getElementById('protection-modal');
            if (modal) modal.style.display = 'none';
            if (pausedTimers.game && gameTimeRemaining > 0) {
                startGameTimer();
            }
            if (pausedTimers.turn && pausedTimers.turnPlayer) {
                if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                    startTurnTimer('W', { reset: false });
                } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                    startTurnTimer('B', { reset: false });
                }
            }
            pausedTimers = { game: null, turn: null, turnPlayer: null };
            gamePaused = false;
        }

        function confirmProtection() {
            if (!pendingProtection) {
                finalizeProtectionModal();
                return;
            }
            const select = document.getElementById('protection-select');
            let value = select ? select.value : '';
            if (!value && pendingProtection.candidates.length) {
                value = `${pendingProtection.candidates[0].row},${pendingProtection.candidates[0].col}`;
            }
            if (!value) {
                finalizeProtectionModal();
                pendingProtection.onResolve(true);
                pendingProtection = null;
                return;
            }
            const [rowStr, colStr] = value.split(',');
            const row = parseInt(rowStr, 10);
            const col = parseInt(colStr, 10);
            const sacrificed = applyProtectionSacrifice(pendingProtection.defender, row, col);
            protectionUsed[pendingProtection.defender] = true;
            nextRoundModifier[pendingProtection.defender] = (nextRoundModifier[pendingProtection.defender] || 0) - 2;
            const sacrificedName = sacrificed ? sacrificed.type : 'a unit';
            gameLog.push(`Player activated Protection against ${pendingProtection.ability}, sacrificing ${sacrificedName} at (${row},${col}). They will start their next round with 2 fewer move points.`);
            renderBoard();
            updateScoreDisplay();
            updateGameLog();
            finalizeProtectionModal();
            pendingProtection.onResolve(false);
            pendingProtection = null;
        }

        function declineProtection() {
            if (!pendingProtection) {
                finalizeProtectionModal();
                return;
            }
            gameLog.push(`Player declined Protection against ${pendingProtection.ability}.`);
            updateGameLog();
            finalizeProtectionModal();
            pendingProtection.onResolve(true);
            pendingProtection = null;
        }

        function resolveSpellTargetsSequentially(targets, attackerPlayer, ability, onComplete) {
            let captureCount = 0;
            const processNext = (index) => {
                if (index >= targets.length) {
                    onComplete(captureCount);
                    return;
                }
                const target = targets[index];
                const occupant = board[target.row]?.[target.col];
                if (!occupant || occupant.player !== target.defender) {
                    processNext(index + 1);
                    return;
                }
                const logMessage = target.logMessage;
                const result = requestSpellProtection({
                    attacker: attackerPlayer,
                    defender: occupant.player,
                    targetRow: target.row,
                    targetCol: target.col,
                    ability,
                    logMessage,
                    onResolve: (shouldCapture) => {
                        if (shouldCapture) {
                            const captured = applySpellCapture(attackerPlayer, target.row, target.col, { logMessage, ability });
                            if (captured) captureCount++;
                        }
                        processNext(index + 1);
                    }
                });
                if (result === 'pending') {
                    return;
                }
            };
            processNext(0);
        }

        function activateGuardOfHonour() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'King' && !kingSpecialUsed[currentPlayer]) {
                guardOfHonourMode = true;
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
            }
        }

        function activateTeleport() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece) return;
            let canTeleport = false;
            if (piece.type === 'Wizard' && wizardTeleportUsed[currentPlayer] < 2) {
                canTeleport = true;
            } else if (piece.type === 'Necromancer' && (gameVariant === '36s-elite' || gameVariant === '36s-supreme')) {
                if (getNecromancerTeleportCount(piece) < 2) {
                    canTeleport = true;
                }
            }
            if (canTeleport) {
                teleportMode = true;
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
            }
        }

        function activateTeleportSwap() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || wizardTeleportSwapUsed[currentPlayer]) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Wizard' && opponentHasWizards(currentPlayer)) {
                teleportSwapMode = true;
                validMoves = getValidTeleportSwapMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
            }
        }

        function activateCharge() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || cavalryChargeUsed[currentPlayer]) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Cavalry') {
                chargeMode = true;
                validMoves = getValidChargeMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
            }
        }

        function activateInferno() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || dragonInfernoUsed[currentPlayer]) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Dragon') {
                infernoMode = true;
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col); // This will now get Inferno moves
                renderBoard();
            }
        }

        function activateElephantryCharge() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
            if (piece.type === 'Elephantry' && !elephantryChargeUsed.has(pieceKey)) {
                elephantryChargeMode = true;
                validMoves = getElephantryChargeMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
            }
        }

        function activateElephantryExtendedRange() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
            if (piece.type === 'Elephantry') {
                if (!(pieceKey in elephantryExtendedRangeShotsRemaining)) {
                    elephantryExtendedRangeShotsRemaining[pieceKey] = 3;
                }
                if (elephantryExtendedRangeShotsRemaining[pieceKey] > 0) {
                    // Deduct the 2 points immediately when activating Triple Shot
                    movesLeft -= 2;
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    elephantryExtendedRangeActive = true;
                    validMoves = getElephantryExtendedRangeMoves(selectedPiece.row, selectedPiece.col);
                    if (!validMoves.length) {
                        elephantryExtendedRangeActive = false;
                        gameLog.push('No valid targets for Elephantry Triple Shot.');
                        showPieceInfo(null);
                        renderBoard();
                        updateStatus();
                        updateEndTurnButton();
                        updateGameLog();
                        return;
                    }
                    updateStatus();
                    updateEndTurnButton();
                    renderBoard();
                }
            }
        }

        function activateElephantryMoveShoot() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Elephantry') {
                // Filter valid moves to only show move+shoot positions
                validMoves = validMoves.filter(m => m.special === 'elephantryMoveShoot');
                renderBoard();
            }
        }

        function activatePistolierMoveShoot() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Pistolier') {
                // Filter valid moves to only show move+shoot positions
                validMoves = validMoves.filter(m => m.special === 'pistolierMoveShoot');
                renderBoard();
            }
        }

        function activateFusilierCrackShot() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
            if (piece.type === 'Fusilier' && fusilierCrackShotCount[pieceKey] > 0) {
                // Deduct points and usage
                movesLeft -= 2;
                fusilierCrackShotCount[pieceKey]--;
                lastAction = { move: true };
                movedPieces.add(pieceKey);

                // Activate extended range shooting (temporarily increase range by +1)
                fusilierCrackShotActive = piece;
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);

                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier activated Crack Shot (+1 range)`);
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                renderBoard();
                checkGameOver();
                if (movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                }
            }
        }

        function activateFusilierStrafe() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
            if (piece.type === 'Fusilier' && fusilierStrafeCount[pieceKey] > 0) {
                // Deduct points and usage
                movesLeft -= 2;
                fusilierStrafeCount[pieceKey]--;
                lastAction = { move: true };
                movedPieces.add(pieceKey);

                // Show strafe move options (1 square orthogonal, no capture)
                fusilierStrafeActive = true;
                validMoves = getFusilierStrafeMoves(selectedPiece.row, selectedPiece.col);

                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier activated Strafe`);
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                renderBoard();
            }
        }

        function getFusilierStrafeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            let moves = [];
            // Move 1 square orthogonally without capturing
            for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                let nr = row + d[0], nc = col + d[1];
                if (isValid(nr, nc) && !board[nr][nc]) {
                    moves.push({ type: 'move', pos: [nr, nc], cost: 0, special: 'fusilierStrafe' });
                }
            }
            return moves;
        }

        function activateEnergyBlast() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            if (!isSpellVariant()) return;
            const row = selectedPiece.row;
            const col = selectedPiece.col;
            const piece = board[row]?.[col];
            if (!isSpellCasterPiece(piece)) return;
            if ((energyBlastUses[currentPlayer] || 0) >= 2) {
                gameLog.push('Energy Blast has already been used twice this game.');
                updateGameLog();
                const btn = document.getElementById('energy-blast-button');
                if (btn) {
                    btn.style.display = 'none';
                    btn.disabled = true;
                }
                return;
            }
            const uses = energyBlastUsage.get(piece) || 0;
            if (uses >= 2) {
                gameLog.push('Energy Blast already used twice by this spellcaster.');
                updateGameLog();
                return;
            }
            const cost = uses === 0 ? 2 : 3;
            if (movesLeft < cost) {
                gameLog.push('Not enough move points to cast Energy Blast.');
                updateGameLog();
                return;
            }
            if (pendingEnergyBlast) return;
            const prepaid = Math.min(2, cost);
            pendingEnergyBlast = { row, col, prepaid, cost };
            movesLeft -= prepaid;
            updateStatus();
            updateEndTurnButton();
            gameLog.push('Channeling Energy Blast (2 move points spent to attempt spellcasting).');
            updateGameLog();
            coinTossSpecialEffect = 'energy-blast';
            performCoinToss(
                'Energy Blast',
                'Attempting to channel spell energy...',
                (success) => {
                    if (!pendingEnergyBlast || pendingEnergyBlast.row !== row || pendingEnergyBlast.col !== col) {
                        return;
                    }
                    const attemptData = pendingEnergyBlast;
                    pendingEnergyBlast = null;
                    if (!success) {
                        gameLog.push('Energy Blast spellcasting failed.');
                        updateGameLog();
                        removeEnergyBlastGlow();
                        return;
                    }
                    const currentPiece = board[row]?.[col];
                    if (!currentPiece || currentPiece.player !== currentPlayer) {
                        removeEnergyBlastGlow();
                        return;
                    }
                    selectedPiece = { row, col };
                    validMoves = getValidMoves(row, col);
                    showPieceInfo(currentPiece, currentPlayer);
                    updateEndTurnButton();
                    activeEnergyBlastCost = { row, col, prepaid: attemptData.prepaid, cost: attemptData.cost };
                    applyEnergyBlastGlow();
                    gameLog.push('Energy Blast spellcasting succeeded!');
                    updateGameLog();
                    showEnergyBlastPopup(() => {
                        openSpellDirectionModal({ type: 'energyBlast', row, col });
                    });
                },
                false,
                false
            );
        }

        function performEnergyBlast(row, col, direction) {
            const piece = board[row]?.[col];
            if (!piece || !isSpellCasterPiece(piece) || !isSpellVariant()) return;
            if ((energyBlastUses[piece.player] || 0) >= 2) {
                if (piece.player === 'W') {
                    gameLog.push('Energy Blast has already been used twice this game.');
                    updateGameLog();
                }
                removeEnergyBlastGlow();
                return;
            }
            const uses = energyBlastUsage.get(piece) || 0;
            if (uses >= 2) {
                gameLog.push('Energy Blast already used twice by this spellcaster.');
                updateGameLog();
                return;
            }
            const cost = uses === 0 ? 2 : 3;
            let prepaid = 0;
            if (activeEnergyBlastCost && activeEnergyBlastCost.row === row && activeEnergyBlastCost.col === col) {
                prepaid = activeEnergyBlastCost.prepaid || 0;
                activeEnergyBlastCost = null;
            }
            const additionalCost = Math.max(0, cost - prepaid);
            if (movesLeft < additionalCost) {
                gameLog.push('Not enough move points to sustain Energy Blast after spellcasting.');
                updateGameLog();
                removeEnergyBlastGlow();
                return;
            }
            if (additionalCost > 0) {
                movesLeft -= additionalCost;
                updateStatus();
                updateEndTurnButton();
            }
            const prevUses = energyBlastUses[piece.player] || 0;
            energyBlastUses[piece.player] = Math.min(2, prevUses + 1);
            if (piece.player === 'W' && energyBlastUses['W'] >= 2) {
                const btn = document.getElementById('energy-blast-button');
                if (btn) {
                    btn.style.display = 'none';
                    btn.disabled = true;
                }
            }
            energyBlastUsage.set(piece, uses + 1);
            lastAction = { move: true };
            movedPieces.add(`${row},${col}`);
            const context = { piece, row, col, direction };
            if (piece.player === 'W') {
                startEnergyBlastFlipSequence(context);
            } else {
                const flips = [];
                let successes = 0;
                for (let i = 0; i < ENERGY_BLAST_FLIP_COUNT; i++) {
                    const success = randomCoinFlip();
                    flips.push(success);
                    if (success) successes++;
                }
                completeEnergyBlastAfterRange(context, successes, flips);
            }
        }

        function completeEnergyBlastAfterRange(context, successes, flips) {
            const { piece, row, col, direction } = context;
            if (!piece) return;
            const playerLabel = piece.player === 'W' ? 'Player' : getOpponentDisplayName();
            const flipSummary = flips.map(result => result ? 'Hit' : 'Miss').join(' ');
            gameLog.push(`${playerLabel} cast Energy Blast (${successes} range) [${flipSummary}]`);

            const finishEnergyBlast = () => {
                selectedPiece = null;
                validMoves = [];
                showPieceInfo(null);
                renderBoard();
                updateScoreDisplay();
                updateCapturedPiecesDisplay();
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                checkGameOver();
                removeEnergyBlastGlow();
                if (movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                } else {
                    ensureAITurnIfNeeded();
                }
            };
            const finalizeEnergyBlast = () => {
                finishEnergyBlast();
                resumeGameForEnergyBlastFlips();
                if (typeof pendingAiEnergyBlastResume === 'function') {
                    const resume = pendingAiEnergyBlastResume;
                    pendingAiEnergyBlastResume = null;
                    resume();
                }
            };

            if (successes === 0) {
                gameLog.push('The blast fizzled before leaving the caster.');
                finalizeEnergyBlast();
                return;
            }

            const targets = [];
            const pathSquares = [];
            let targetRow = row;
            let targetCol = col;
            for (let step = 1; step <= successes; step++) {
                targetRow += direction.dr;
                targetCol += direction.dc;
                if (!isValid(targetRow, targetCol)) {
                    break;
                }
                pathSquares.push({ row: targetRow, col: targetCol });
                const occupant = board[targetRow][targetCol];
                if (!occupant || occupant.player === piece.player) {
                    continue;
                }
                targets.push({
                    row: targetRow,
                    col: targetCol,
                    defender: occupant.player,
                    logMessage: `${playerLabel} vaporized ${occupant.type} with Energy Blast at (${targetRow},${targetCol})`
                });
            }

            const processTargets = () => {
                if (!targets.length) {
                    gameLog.push('Energy Blast hit no enemy pieces along its path.');
                    addEnergyBlastResidualSquares(pathSquares);
                    finalizeEnergyBlast();
                    return;
                }
                resolveSpellTargetsSequentially(targets, piece.player, 'Energy Blast', (capturesHit) => {
                    if (capturesHit === 0) {
                        gameLog.push('Energy Blast was negated or all targets were protected.');
                    }
                    addEnergyBlastResidualSquares(pathSquares);
                    finalizeEnergyBlast();
                });
            };

            animateEnergyBlastPath(pathSquares, processTargets);
        }

        function activateSacrifice() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            if (!isSpellVariant()) return;
            const row = selectedPiece.row;
            const col = selectedPiece.col;
            const piece = board[row]?.[col];
            if (!isSpellCasterPiece(piece)) return;
            if (movesLeft < 3) {
                gameLog.push('Not enough move points to perform Sacrifice.');
                updateGameLog();
                return;
            }
            if (sacrificeAttemptedPieces.has(piece)) {
                gameLog.push('This spellcaster has already attempted Sacrifice.');
                updateGameLog();
                return;
            }
            sacrificeAttemptedPieces.add(piece);
            const playerLabel = 'Player';
            performCoinToss('Sacrifice', 'Attempting Sacrifice...', (success) => {
                if (!success) {
                    gameLog.push(`${playerLabel} failed the Sacrifice coin flip.`);
                    updateGameLog();
                    return;
                }
                if (movesLeft < 3) {
                    gameLog.push('Not enough move points remaining to complete Sacrifice.');
                    updateGameLog();
                    return;
                }
                executeSacrifice(row, col);
            }, false, false);
        }

        function executeSacrifice(row, col, options = {}) {
            const piece = board[row]?.[col];
            if (!piece || !isSpellCasterPiece(piece) || !isSpellVariant()) return;
            if (movesLeft < 3) {
                gameLog.push('Not enough move points to perform Sacrifice.');
                updateGameLog();
                return;
            }
            const player = piece.player;
            const playerLabel = player === 'W' ? 'Player' : getOpponentDisplayName();
            movesLeft -= 3;
            lastAction = { move: true };
            movedPieces.add(`${row},${col}`);
            registerPieceLoss(player, piece.type);

            if (piece.type === 'Champion') {
                championCaptured[player] = true;
                championsOnBackRow[player] = championsOnBackRow[player].filter(([r, c]) => !(r === row && c === col));
            }
            cleanupNecromancerTracking(piece);
            board[row][col] = null;

            const enemy = getOpponent(player);
            const targetInfo = listSacrificeTargets(row, col, player);
            const targets = targetInfo.map(({ row: targetRow, col: targetCol, piece: occupant }) => ({
                row: targetRow,
                col: targetCol,
                defender: occupant.player,
                logMessage: `${playerLabel}'s Sacrifice blast engulfed ${occupant.type} at (${targetRow},${targetCol})`
            }));

            const finishSacrifice = (capturesHit) => {
                gameLog.push(`${playerLabel} performed Sacrifice, removing their ${piece.type} and striking ${capturesHit} target${capturesHit === 1 ? '' : 's'}.`);
                selectedPiece = null;
                validMoves = [];
                showPieceInfo(null);
                renderBoard();
                updateScoreDisplay();
                updateCapturedPiecesDisplay();
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                checkGameOver();
                if (movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                } else {
                    ensureAITurnIfNeeded();
                }
                if (typeof options.onComplete === 'function') {
                    options.onComplete(capturesHit);
                }
            };

            resolveSpellTargetsSequentially(targets, player, 'Sacrifice', (capturesHit) => {
                finishSacrifice(capturesHit);
            });
        }

        function beginHuntsmanBurstSequence(row, col, player, options = {}) {
            pendingHuntsmanBurst = {
                row,
                col,
                player,
                successes: 0,
                flips: 0,
                automated: !!options.automated,
                onComplete: typeof options.onComplete === 'function' ? options.onComplete : null
            };
            pauseGameForHuntsmanBurst();
            runHuntsmanBurstFlip();
        }

        function activateHuntsmanBurst() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            const row = selectedPiece.row;
            const col = selectedPiece.col;
            const piece = board[row]?.[col];
            if (!piece || piece.type !== 'Huntsman' || gameVariant !== '36s-supreme') return;
            if (movedPieces.has(`${row},${col}`)) {
                gameLog.push('This Huntsman has already acted this round.');
                updateGameLog();
                return;
            }
            if (movesLeft < 2 || pendingHuntsmanBurst) {
                if (movesLeft < 2) {
                    gameLog.push('Not enough move points to activate Stalking Burst.');
                    updateGameLog();
                }
                return;
            }
            movesLeft -= 2;
            updateStatus();
            updateEndTurnButton();
            gameLog.push('Player Huntsman is attempting a Stalking Burst (2 move points spent).');
            updateGameLog();
            beginHuntsmanBurstSequence(row, col, currentPlayer);
        }

        function runHuntsmanBurstFlip() {
            if (!pendingHuntsmanBurst) return;
            if (pendingHuntsmanBurst.flips >= HUNTSMAN_BURST_FLIP_COUNT) {
                finalizeHuntsmanBurst();
                return;
            }
            const flipNumber = pendingHuntsmanBurst.flips + 1;
            const successesSoFar = pendingHuntsmanBurst.successes;
            pauseGameForHuntsmanBurst();
            performCoinToss(
                'Stalking Burst',
                `Flip ${flipNumber} of ${HUNTSMAN_BURST_FLIP_COUNT} (successes: ${successesSoFar})`,
                (success) => {
                    if (!pendingHuntsmanBurst) {
                        resumeGameAfterHuntsmanBurst();
                        return;
                    }
                    if (success) pendingHuntsmanBurst.successes++;
                    pendingHuntsmanBurst.flips++;
                    pauseGameForHuntsmanBurst();
                    runHuntsmanBurstFlip();
                },
                true,
                true
            );
        }

        function finalizeHuntsmanBurst() {
            const ctx = pendingHuntsmanBurst;
            pendingHuntsmanBurst = null;
            if (!ctx) {
                resumeGameAfterHuntsmanBurst();
                return;
            }
            const finish = () => {
                resumeGameAfterHuntsmanBurst();
                if (typeof ctx.onComplete === 'function') ctx.onComplete();
            };
            const piece = board[ctx.row]?.[ctx.col];
            if (!piece || piece.type !== 'Huntsman' || piece.player !== ctx.player) {
                gameLog.push('Huntsman Burst fizzled because the piece is no longer available.');
                updateGameLog();
                finish();
                return;
            }
            if (ctx.successes <= 0) {
                gameLog.push('Huntsman failed to gain extra movement from Stalking Burst.');
                updateGameLog();
                lastAction = { move: true };
                movedPieces.add(`${ctx.row},${ctx.col}`);
                selectedPiece = null;
                validMoves = [];
                showPieceInfo(null);
                renderBoard();
                updateStatus();
                updateEndTurnButton();
                checkGameOver();
                if (movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                }
                finish();
                return;
            }
            if (ctx.player === 'B' && ctx.automated) {
                const destination = chooseBestHuntsmanBurstDestination(ctx.row, ctx.col, ctx.successes, ctx.player);
                if (destination) {
                    movePiece(ctx.row, ctx.col, destination.row, destination.col);
                    lastAction = { move: true };
                    movedPieces.add(`${destination.row},${destination.col}`);
                    gameLog.push(`${getOpponentDisplayName()} Huntsman blitzed to (${destination.row},${destination.col}) after a successful Stalking Burst.`);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                } else {
                    gameLog.push(`${getOpponentDisplayName()} Huntsman could not find a viable burst destination.`);
                    updateGameLog();
                    lastAction = { move: true };
                    movedPieces.add(`${ctx.row},${ctx.col}`);
                }
                finish();
                return;
            }
            huntsmanBurstMode = { row: ctx.row, col: ctx.col, steps: ctx.successes, player: ctx.player, onComplete: ctx.onComplete };
            const playerLabel = ctx.player === 'W' ? 'Player' : getOpponentDisplayName();
            gameLog.push(`${playerLabel} Huntsman gained ${ctx.successes} burst step${ctx.successes === 1 ? '' : 's'}. Select a destination.`);
            updateGameLog();
            selectedPiece = { row: ctx.row, col: ctx.col };
            validMoves = getHuntsmanBurstMoves(ctx.row, ctx.col, ctx.successes);
            if (!validMoves.length) {
                huntsmanBurstMode = null;
                lastAction = { move: true };
                movedPieces.add(`${ctx.row},${ctx.col}`);
                selectedPiece = null;
                showPieceInfo(null);
                renderBoard();
                updateStatus();
                updateEndTurnButton();
                checkGameOver();
                if (movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                }
                finish();
                return;
            }
            showPieceInfo(piece, ctx.player);
            renderBoard();
            updateStatus();
            updateEndTurnButton();
        }

        function getHuntsmanBurstReach(row, col, steps) {
            const originPiece = board[row]?.[col];
            if (!originPiece || originPiece.type !== 'Huntsman') return [];
            const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(Infinity));
            const queue = [{ row, col, used: 0 }];
            visited[row][col] = 0;
            const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
            const targets = [];
            while (queue.length) {
                const current = queue.shift();
                for (const [dr, dc] of directions) {
                    const nr = current.row + dr;
                    const nc = current.col + dc;
                    const nextUsed = current.used + 1;
                    if (!isValid(nr, nc) || nextUsed > steps) continue;
                    if (visited[nr][nc] <= nextUsed) continue;
                    const occupant = board[nr]?.[nc];
                    const isFriendly = occupant && occupant.player === originPiece.player;
                    visited[nr][nc] = nextUsed;
                    if (!isFriendly) {
                        targets.push({ row: nr, col: nc, steps: nextUsed, occupant });
                    }
                    if (!occupant || isFriendly) {
                        queue.push({ row: nr, col: nc, used: nextUsed });
                    }
                }
            }
            return targets;
        }

        function getHuntsmanBurstMoves(row, col, steps) {
            const targets = getHuntsmanBurstReach(row, col, steps);
            return targets.map(target => ({
                type: 'move',
                pos: [target.row, target.col],
                cost: 0,
                special: 'huntsmanBurst'
            }));
        }

        function evaluateHuntsmanDestinationValue(row, col, player, occupant = board[row]?.[col]) {
            if (occupant && occupant.player !== player) {
                let value = aiPieceValues[occupant.type] !== undefined ? aiPieceValues[occupant.type] : (pieceValues[occupant.type] || 0);
                if (occupant.type === 'King') {
                    value += 500;
                } else if (occupant.type === 'Champion') {
                    value += 6;
                } else if (occupant.type === 'Necromancer' || occupant.type === 'Wizard') {
                    value += 4;
                }
                return value + 2;
            }
            const opponentBackRow = getOpponentBackRow(player);
            const advancement = Math.max(0, 4 - Math.abs(row - opponentBackRow));
            return 1 + advancement * 0.75;
        }

        function chooseBestHuntsmanBurstDestination(row, col, steps, player) {
            if (steps <= 0) return null;
            const targets = getHuntsmanBurstReach(row, col, steps);
            let best = null;
            for (const target of targets) {
                if (target.steps > steps) continue;
                const score = evaluateHuntsmanDestinationValue(target.row, target.col, player, target.occupant);
                if (!best || score > best.score) {
                    best = { row: target.row, col: target.col, score };
                }
            }
            return best;
        }

        function getValidTeleportSwapMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            const opponent = player === 'W' ? 'B' : 'W';
            const color = (row + col) % 2;
            let moves = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] && board[r][c].type === 'Wizard' && board[r][c].player === opponent && (r + c) % 2 === color) {
                        moves.push({ type: 'teleportSwap', pos: [r, c], cost: 2 });
                    }
                }
            }
            return moves;
        }

        function getValidChargeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            let moves = [];
            for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                let r = row, c = col;
                while (true) {
                    r += d[0];
                    c += d[1];
                    if (!isValid(r, c)) break;
                    if (board[r][c]) {
                        if (board[r][c].player !== player) {
                            moves.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                        }
                        break;
                    }
                    moves.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                }
            }
            return moves;
        }

        function getElephantryChargeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            const facing = piece.facing;
            const pieceKey = `${row},${col},${player}`;
            let moves = [];

            if (elephantryChargeUsed.has(pieceKey)) return moves;

            // Determine forward directions based on facing
            let directions = [];
            if (facing === 'U') {
                directions = [[-1,0], [-1,-1], [-1,1]]; // Up, Up-Left, Up-Right
            } else if (facing === 'D') {
                directions = [[1,0], [1,-1], [1,1]]; // Down, Down-Left, Down-Right
            } else if (facing === 'L') {
                directions = [[0,-1], [-1,-1], [1,-1]]; // Left, Up-Left, Down-Left
            } else if (facing === 'R') {
                directions = [[0,1], [-1,1], [1,1]]; // Right, Up-Right, Down-Right
            }

            for (let d of directions) {
                let capturesInPath = [];
                let canCharge = true;
                let finalPos = null;

                // Check all 3 squares in this direction
                for (let dist = 1; dist <= 3; dist++) {
                    let r = row + d[0] * dist;
                    let c = col + d[1] * dist;

                    if (!isValid(r, c)) {
                        canCharge = false;
                        break;
                    }

                    const target = board[r][c];
                    if (target) {
                        // Cannot charge through Spectre or Zombies
                        if (target.type === 'Spectre' || target.type === 'Zombie') {
                            canCharge = false;
                            break;
                        }

                        // Can capture enemy pieces
                        if (target.player !== player) {
                            capturesInPath.push([r, c, target.type]);
                            // Stop on Elephantry, Ogre, Troll, or Dragon (but still capture them)
                            if (target.type === 'Elephantry' || target.type === 'Ogre' || target.type === 'Troll' || target.type === 'Dragon') {
                                finalPos = [r, c];
                                break;
                            }
                        } else {
                            // Cannot charge through own pieces
                            canCharge = false;
                            break;
                        }
                    }

                    // If we've gone 3 squares without stopping, this is the final position
                    if (dist === 3) {
                        finalPos = [r, c];
                    }
                }

                if (canCharge && finalPos) {
                    moves.push({
                        type: 'move',
                        pos: finalPos,
                        cost: 2,
                        special: 'elephantryCharge',
                        captures: capturesInPath
                    });
                }
            }

            return moves;
        }

        function getElephantryExtendedRangeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            const pieceKey = `${row},${col},${player}`;
            let moves = [];

            // Initialize if not set
            if (!(pieceKey in elephantryExtendedRangeShotsRemaining)) {
                elephantryExtendedRangeShotsRemaining[pieceKey] = 3;
            }

            if (elephantryExtendedRangeShotsRemaining[pieceKey] <= 0) return moves;

            // Can shoot 2 squares in any direction
            for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                for (let dist = 1; dist <= 2; dist++) {
                    let nr = row + d[0] * dist;
                    let nc = col + d[1] * dist;
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== player) {
                        moves.push({
                            type: 'shoot',
                            pos: [nr, nc],
                            cost: 0, // No additional cost per shot - already paid 2 points on activation
                            special: 'elephantryExtendedRange',
                            shotsRemaining: elephantryExtendedRangeShotsRemaining[pieceKey]
                        });
                    }
                }
            }

            return filterShootMovesForPlayer(moves, player);
        }

        function handleClick(row, col) {
            const huntsmanSelectionActive = !!(huntsmanBurstMode && selectedPiece && selectedPiece.row === huntsmanBurstMode.row && selectedPiece.col === huntsmanBurstMode.col);
            if (gameOver || currentPlayer !== 'W' || reinforcementPending || zombieAutoAdvanceInProgress) return;
            if (gamePaused && !huntsmanSelectionActive) return;
            const piece = board[row][col];

            if (isAnySpecialModeActive() && !huntsmanSelectionActive) {
                if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                    cancelSpecialModes({ resetSelection: false });
                    return;
                }
                if (!selectedPiece) {
                    cancelSpecialModes();
                    return;
                }
                // Don't auto-cancel when clicking different squares - let mode handlers decide
                // if (selectedPiece && (selectedPiece.row !== row || selectedPiece.col !== col)) {
                //     cancelSpecialModes();
                // }
            }

            // Handle Inferno Mode
            if (infernoMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'inferno');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const toRow = move.pos[0];
                    const toCol = move.pos[1];

                    // 1. Perform the initial 1-square move (handles landing capture)
                    movePiece(fromRow, fromCol, toRow, toCol, null);
                    
                    // 2. Perform the adjacent Inferno captures
                    performInfernoCapture(toRow, toCol, currentPlayer);

                    // 3. Update state
                    dragonInfernoUsed[currentPlayer] = true;
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    movedPieces.add(`${toRow},${toCol}`);
                    
                    selectedPiece = null;
                    validMoves = [];
                    infernoMode = false;
                    
                    // 4. Re-render and check game state
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
                else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            
            // Handle Archer Turn+Shoot mode (after confirming turn)
            if (turnAndShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'shoot');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    shootPiece(fromRow, fromCol, row, col);
                    movesLeft -= move.cost; // spend second point
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    selectedPiece = null;
                    validMoves = [];
                    turnAndShootMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Archer Move + Diagonal (1) Shoot special
            if (archerMoveDiagMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'move');
                if (move && movesLeft >= 1) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    // Perform the 1-point move first
                    movePiece(fromRow, fromCol, row, col, move.jump);
                    movesLeft -= 1;
                    // Prepare diagonal 1-square shoot options from new position
                    selectedPiece = { row, col };
                    const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                    let options = [];
                    for (let d of dirs) {
                        const nr = row + d[0], nc = col + d[1];
                        if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== currentPlayer) {
                            options.push({ type: 'shoot', pos: [nr, nc], cost: 1, special: 'archerDiag1' });
                        }
                    }
                    options = filterShootMovesForPlayer(options, currentPlayer);
                    if (!options.length) {
                        archerMoveDiagMode = false;
                        archerDiagShootSelectMode = false;
                        selectedPiece = null;
                        validMoves = [];
                        showPieceInfo(null);
                        renderBoard();
                        updateStatus();
                        updateEndTurnButton();
                        gameLog.push('No valid targets for Archer diagonal shot.');
                        updateGameLog();
                        return;
                    }
                    validMoves = options;
                    // Switch to the second phase: select diagonal shot
                    archerMoveDiagMode = false;
                    archerDiagShootSelectMode = true;
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle second phase of Archer Move + Diagonal (1) Shoot
            if (archerDiagShootSelectMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'shoot');
                if (move && movesLeft >= move.cost) {
                    const currentRow = selectedPiece.row;
                    const currentCol = selectedPiece.col;
                    shootPiece(currentRow, currentCol, row, col);
                    movesLeft -= move.cost; // spend second point
                    lastAction = { move: true };
                    // Mark both original and current squares as moved if we have the original
                    if (archerMoveDiagStart) {
                        movedPieces.add(`${archerMoveDiagStart.row},${archerMoveDiagStart.col}`);
                    }
                    movedPieces.add(`${currentRow},${currentCol}`);
                    archerMoveDiagShootUsed[currentPlayer]++;
                    selectedPiece = null;
                    validMoves = [];
                    archerDiagShootSelectMode = false;
                    archerMoveDiagStart = null;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Archer Diagonal 2-square Shot special
            if (archerDiag2ShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'shoot');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    shootPiece(fromRow, fromCol, row, col);
                    movesLeft -= move.cost; // cost 2
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    archerDiag2ShootUsed[currentPlayer]++;
                    selectedPiece = null;
                    validMoves = [];
                    archerDiag2ShootMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Strafe special move
            if (summonSpectreMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'summonSpectre');
                if (move && movesLeft >= move.cost) {
                    const wizardRow = selectedPiece.row;
                    const wizardCol = selectedPiece.col;
                    const wizardPiece = board[wizardRow][wizardCol];

                    // Store placement info for callback
                    const summonRow = row;
                    const summonCol = col;

                    // Deduct points immediately
                    movesLeft -= move.cost; // cost 2

                    // Trigger coin toss
                    performCoinToss(
                        'Summon Spectre',
                        'Attempting to summon a Spectre...',
                        (success) => {
                            if (success) {
                                // Place Spectre at selected location
                                board[summonRow][summonCol] = { type: 'Spectre', player: currentPlayer };
                                spectresSummoned[currentPlayer]++;
                                wizardSummonedThisTurn[currentPlayer] = true;

                                // Mark wizard as unable to move next turn
                                wizardCannotMoveNextTurn[currentPlayer].add(`${wizardRow},${wizardCol}`);

                                // Award 3 bonus points for successful summoning
                                scores[currentPlayer] += 3;
                                registerScoreGain(currentPlayer, 3);
                                updateScoreDisplay();

                                gameStats.summonCount[currentPlayer]++; // Track summon for statistics
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} summoned a Spectre! (+3 bonus points)`);
                            } else {
                                // Failed summoning
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} failed to summon a Spectre.`);
                            }

                            selectedPiece = null;
                            validMoves = [];
                            summonSpectreMode = false;
                            showPieceInfo(null);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            checkGameOver();
                            if (movesLeft === 0 && !reinforcementPending) {
                                triggerAiTurn();
                            }
                        },
                        false, // automated
                        false  // showOverlay
                    );
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            if (strafeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'strafe');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const piece = board[fromRow][fromCol];

                    // Perform the move
                    movePiece(fromRow, fromCol, row, col);
                    movesLeft -= move.cost; // cost 2
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    movedPieces.add(`${row},${col}`); // Mark destination as moved so piece can't move again

                    // Increment usage counter based on piece type
                    if (piece.type === 'Wizard') {
                        wizardStrafeUsed[currentPlayer]++;
                    } else if (piece.type === 'Dragon') {
                        dragonStrafeUsed[currentPlayer]++;
                    }

                    selectedPiece = null;
                    validMoves = [];
                    strafeMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Fusilier Strafe special move
            if (fusilierStrafeActive && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'fusilierStrafe');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;

                    // Perform the move (no capture)
                    board[row][col] = board[fromRow][fromCol];
                    board[fromRow][fromCol] = null;

                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier strafed to (${row},${col})`);

                    selectedPiece = null;
                    validMoves = [];
                    fusilierStrafeActive = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            if (turnAndMoveMode && selectedPiece && board[selectedPiece.row][selectedPiece.col]?.type === 'Infantry') {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col);
                if (move && move.type === 'move' && movesLeft >= 1) {
                    movePiece(selectedPiece.row, selectedPiece.col, row, col, move.jump);
                    movesLeft -= 1;
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    turnAndMoveMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (guardOfHonourMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'swap');
                if (move && movesLeft >= move.cost) {
                    const guardRow = move.pos[0];
                    const guardCol = move.pos[1];
                    const guard = board[guardRow][guardCol];
                    board[guardRow][guardCol] = board[selectedPiece.row][selectedPiece.col];
                    board[selectedPiece.row][selectedPiece.col] = guard;
                    kingSpecialUsed[currentPlayer] = true;
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Guard of Honour to swap King and Guard at (${selectedPiece.row},${selectedPiece.col}) and (${guardRow},${guardCol})`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${guardRow},${guardCol}`);
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    selectedPiece = null;
                    validMoves = [];
                    guardOfHonourMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    checkSupremacy(currentPlayer);
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (teleportMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'teleport');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const teleportPiece = board[fromRow][fromCol];
                    board[move.pos[0]][move.pos[1]] = teleportPiece;
                    board[fromRow][fromCol] = null;
                    if (teleportPiece.type === 'Wizard') {
                        wizardTeleportUsed[currentPlayer]++;
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Wizard from (${fromRow},${fromCol}) to (${move.pos[0]},${move.pos[1]})`);
                    } else if (teleportPiece.type === 'Necromancer') {
                        incrementNecromancerTeleportCount(teleportPiece);
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Necromancer from (${fromRow},${fromCol}) to (${move.pos[0]},${move.pos[1]})`);
                    } else {
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported ${teleportPiece.type} from (${fromRow},${fromCol}) to (${move.pos[0]},${move.pos[1]})`);
                    }
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                    selectedPiece = null;
                    validMoves = [];
                    teleportMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (teleportSwapMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'teleportSwap');
                if (move && movesLeft >= move.cost) {
                    const opponentWizardRow = move.pos[0];
                    const opponentWizardCol = move.pos[1];
                    const playerWizard = board[selectedPiece.row][selectedPiece.col];
                    const opponentWizard = board[opponentWizardRow][opponentWizardCol];
                    board[opponentWizardRow][opponentWizardCol] = playerWizard;
                    board[selectedPiece.row][selectedPiece.col] = opponentWizard;
                    wizardTeleportSwapUsed[currentPlayer] = true;
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Teleport Swap to swap Wizard at (${selectedPiece.row},${selectedPiece.col}) with opponent's Wizard at (${opponentWizardRow},${opponentWizardCol})`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    movedPieces.add(`${opponentWizardRow},${opponentWizardCol}`);
                    selectedPiece = null;
                    validMoves = [];
                    teleportSwapMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (chargeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'move');
                if (move && movesLeft >= move.cost) {
                    movePiece(selectedPiece.row, selectedPiece.col, row, col, move.jump);
                    cavalryChargeUsed[currentPlayer] = true;
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Charge to move Cavalry from (${selectedPiece.row},${selectedPiece.col}) to (${row},${col})`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    chargeMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Elephantry Charge
            if (elephantryChargeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'elephantryCharge');
                if (move && movesLeft >= move.cost) {
                    const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;

                    // Process all captures along the path
                    if (move.captures && move.captures.length > 0) {
                        for (let [captureRow, captureCol, captureType] of move.captures) {
                            const capturedPiece = board[captureRow][captureCol];
                            if (capturedPiece) {
                                capturedSquares.push([captureRow, captureCol]);
                                capturedPieces[currentPlayer].push(capturedPiece);
                                const captureValue = pieceValues[capturedPiece.type];
                                scores[currentPlayer] += captureValue;
                                registerScoreGain(currentPlayer, captureValue);
                                registerPieceLoss(capturedPiece.player, capturedPiece.type);
                                trackCapture(currentPlayer); // Track capture for statistics
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry charged and captured ${capturedPiece.type} (+${captureValue} points) at (${captureRow},${captureCol})`);

                                if (capturedPiece.type === 'Champion') {
                                    championCaptured[capturedPiece.player] = true;
                                }
                                if (capturedPiece.type === 'King') {
                                    endGame(currentPlayer);
                                    return;
                                }
                                board[captureRow][captureCol] = null;
                            }
                        }
                    }

                    // Move the Elephantry to final position
                    movePiece(fromRow, fromCol, row, col, null);
                    elephantryChargeUsed.add(pieceKey);
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Elephantry Charge from (${fromRow},${fromCol}) to (${row},${col})`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    elephantryChargeMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    updateCapturedPiecesDisplay();
                    updateScoreDisplay();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Pistolier move+shoot final shot selection
            if (pistolierMoveShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'pistolierMoveShootFinal');
                if (move) {
                    // Execute the shoot
                    shootPiece(selectedPiece.row, selectedPiece.col, row, col);
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier shot at (${row},${col})`);

                    // Clean up
                    pistolierMoveShootMode = false;
                    pistolierMoveShootPosition = null;
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Elephantry move+shoot final shot selection
            if (elephantryMoveShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'elephantryMoveShootFinal');
                if (move) {
                    // Execute the shoot
                    shootPiece(selectedPiece.row, selectedPiece.col, row, col);
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry shot at (${row},${col})`);

                    // Clean up
                    elephantryMoveShootMode = false;
                    elephantryMoveShootPosition = null;
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Elephantry Triple Shot
            if (elephantryExtendedRangeActive && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'elephantryExtendedRange');
                if (move) {
                    const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
                    const targetRow = row;
                    const targetCol = col;
                    const elephantryRow = selectedPiece.row;
                    const elephantryCol = selectedPiece.col;

                    // Trigger coin flip for this shot
                    performCoinToss(
                        'Elephantry Triple Shot',
                        `Shot ${4 - elephantryExtendedRangeShotsRemaining[pieceKey]}/3: Attempting shot at (${targetRow},${targetCol})...`,
                        (success) => {
                            if (success) {
                                // Successful hit - capture the target
                                const targetPiece = board[targetRow][targetCol];
                                if (targetPiece && targetPiece.player !== currentPlayer) {
                                    capturedSquares.push([targetRow, targetCol]);
                                    capturedPieces[currentPlayer].push(targetPiece);
                                    const captureValue = pieceValues[targetPiece.type];
                                    scores[currentPlayer] += captureValue;
                                    registerScoreGain(currentPlayer, captureValue);
                                    registerPieceLoss(targetPiece.player, targetPiece.type);
                                    trackCapture(currentPlayer); // Track capture for statistics
                                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry triple shot hit! Captured ${targetPiece.type} (+${captureValue} points)`);

                                    if (targetPiece.type === 'Champion') {
                                        championCaptured[targetPiece.player] = true;
                                    }
                                    if (targetPiece.type === 'King') {
                                        endGame(currentPlayer);
                                        return;
                                    }
                                    board[targetRow][targetCol] = null;
                                    updateCapturedPiecesDisplay();
                                    updateScoreDisplay();
                                    checkSupremacy(currentPlayer);
                                }
                            } else {
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry triple shot missed at (${targetRow},${targetCol}).`);
                            }

                            // Decrement shots remaining (whether hit or miss)
                            elephantryExtendedRangeShotsRemaining[pieceKey]--;

                            // Update display
                            updateGameLog();
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();

                            // If shots remain in this Triple Shot usage, keep the mode active
                            if (elephantryExtendedRangeShotsRemaining[pieceKey] > 0) {
                                validMoves = getElephantryExtendedRangeMoves(elephantryRow, elephantryCol);
                                if (!validMoves.length) {
                                    elephantryExtendedRangeActive = false;
                                    selectedPiece = null;
                                    showPieceInfo(null);
                                    renderBoard();
                                    gameLog.push('No remaining targets for Elephantry Triple Shot.');
                                    updateGameLog();
                                } else {
                                    renderBoard();
                                }
                            } else {
                                // All 3 shots used, end the Triple Shot mode
                                elephantryExtendedRangeActive = false;
                                selectedPiece = null;
                                validMoves = [];
                                showPieceInfo(null);
                                renderBoard();
                            }

                            checkGameOver();
                            if (movesLeft === 0 && !reinforcementPending) {
                                triggerAiTurn();
                            }
                        },
                        false, // automated
                        false  // showOverlay
                    );
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Huntsman burst destination selection
            if (huntsmanBurstMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'huntsmanBurst');
                if (move) {
                    const context = huntsmanBurstMode;
                    const fromRow = context.row;
                    const fromCol = context.col;
                    movePiece(fromRow, fromCol, row, col, move.jump);
                    lastAction = { move: true };
                    movedPieces.add(`${row},${col}`);
                    huntsmanBurstMode = null;
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    resumeGameAfterHuntsmanBurst();
                    if (context && typeof context.onComplete === 'function') {
                        context.onComplete();
                    }
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
                return;
            }

            // Handle King Shot targeting
            if (kingShotMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'kingShot');
                if (move) {
                    const source = kingShotMode;
                    const fromRow = source.row;
                    const fromCol = source.col;
                    const kingPiece = board[fromRow]?.[fromCol];
                    kingShotMode = null;
                    if (!kingPiece || kingPiece.type !== 'King' || kingPiece.player !== currentPlayer) {
                        validMoves = [];
                        renderBoard();
                        return;
                    }
                    movesLeft = Math.max(0, movesLeft - move.cost);
                    markKingShotUsed(kingPiece);
                    shootPiece(fromRow, fromCol, move.pos[0], move.pos[1]);
                    lastAction = { shoot: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    const actorLabel = currentPlayer === 'W' ? 'Player' : getOpponentDisplayName();
                    gameLog.push(`${actorLabel} executed King Shot.`);
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
                return;
            }

            // Handle King Evade destination
            if (kingEvadeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'kingEvade');
                if (move) {
                    const context = kingEvadeMode;
                    const fromRow = context.row;
                    const fromCol = context.col;
                    const kingPiece = board[fromRow]?.[fromCol];
                    kingEvadeMode = null;
                    if (!kingPiece || kingPiece.type !== 'King' || kingPiece.player !== currentPlayer) {
                        validMoves = [];
                        renderBoard();
                        return;
                    }
                    movePiece(fromRow, fromCol, move.pos[0], move.pos[1]);
                    kingEvadeUsed[currentPlayer] = true;
                    nextRoundModifier[currentPlayer] -= 2;
                    lastAction = { move: true };
                    movedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    const actorLabel = currentPlayer === 'W' ? 'Player' : getOpponentDisplayName();
                    gameLog.push(`${actorLabel} used King Evade (-2 moves next round).`);
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
                return;
            }

            // Handle Champion summon targeting
            if (championSummonMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'championSummon');
                if (move) {
                    const summonType = move.summonType;
                    const source = championSummonMode.source || selectedPiece;
                    const fromRow = source.row;
                    const fromCol = source.col;
                    const champion = board[fromRow]?.[fromCol];
                    championSummonMode = null;
                    if (!champion || champion.type !== 'Champion' || champion.player !== currentPlayer) {
                        validMoves = [];
                        selectedPiece = null;
                        renderBoard();
                        return;
                    }
                    const championOwner = champion.player;
                    movesLeft = Math.max(0, movesLeft - move.cost);
                    updateStatus();
                    updateEndTurnButton();
                    const targetRow = move.pos[0];
                    const targetCol = move.pos[1];
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    const playerLabel = championOwner === 'W' ? 'Player' : getOpponentDisplayName();
                    const attemptLabel = summonType === 'Huntsman' ? 'Summon Huntsman' : 'Summon Necromancer';
                    const attemptMessage = `${playerLabel} attempts to summon a ${summonType}...`;
                    performCoinToss(
                        attemptLabel,
                        attemptMessage,
                        (success) => {
                            if (success) {
                                if (!board[targetRow][targetCol]) {
                                    if (summonType === 'Huntsman') {
                                        board[targetRow][targetCol] = { type: 'Huntsman', player: championOwner };
                                        recordHuntsmanSpawn(championOwner);
                                    } else {
                                        const necromancerPiece = { type: 'Necromancer', player: championOwner, facing: null };
                                        board[targetRow][targetCol] = necromancerPiece;
                                        necromancersSummoned[championOwner] = (necromancersSummoned[championOwner] || 0) + 1;
                                        necromancerTeleportCounts.set(necromancerPiece, 0);
                                        setNecromancerShotCooldown(necromancerPiece, 0);
                                    }
                                    gameStats.summonCount[championOwner]++;
                                    gameLog.push(`${playerLabel} summoned a ${summonType} at (${targetRow},${targetCol}).`);
                                } else {
                                    gameLog.push(`${playerLabel}'s ${summonType} summon succeeded but the chosen square was occupied.`);
                                }
                            } else {
                                gameLog.push(`${playerLabel} failed to summon a ${summonType}.`);
                            }
                            lastAction = { move: true };
                            movedPieces.add(`${fromRow},${fromCol}`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            checkGameOver();
                            if (movesLeft === 0 && !reinforcementPending) {
                                triggerAiTurn();
                            }
                        },
                        false,
                        false
                    );
                }
                return;
            }

            // Handle Necromancer summon targeting
            if (necromancerSummonMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'necromancerSummon');
                if (move) {
                    const summonType = move.summonType;
                    const source = necromancerSummonMode.source || selectedPiece;
                    const fromRow = source.row;
                    const fromCol = source.col;
                    const necromancer = board[fromRow]?.[fromCol];
                    necromancerSummonMode = null;
                    if (!necromancer || necromancer.type !== 'Necromancer' || necromancer.player !== currentPlayer) {
                        validMoves = [];
                        selectedPiece = null;
                        renderBoard();
                        return;
                    }
                    movesLeft = Math.max(0, movesLeft - move.cost);
                    updateStatus();
                    updateEndTurnButton();
                    const targetRow = move.pos[0];
                    const targetCol = move.pos[1];
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    const playerLabel = currentPlayer === 'W' ? 'Player' : getOpponentDisplayName();
                    const label = summonType === 'spectre' ? 'Spectre' : 'Zombie';
                    performCoinToss(
                        `Summon ${label}`,
                        `${playerLabel} attempts to summon a ${label}...`,
                        (success) => {
                            if (success) {
                                if (!board[targetRow][targetCol]) {
                                    if (summonType === 'spectre') {
                                        board[targetRow][targetCol] = { type: 'Spectre', player: currentPlayer };
                                        spectresSummoned[currentPlayer]++;
                                    } else {
                                        const zombiePiece = createZombiePiece(currentPlayer);
                                        board[targetRow][targetCol] = zombiePiece;
                                        zombiesSummoned[currentPlayer] = (zombiesSummoned[currentPlayer] || 0) + 1;
                                    }
                                    gameStats.summonCount[currentPlayer]++;
                                    gameLog.push(`${playerLabel} summoned a ${label} at (${targetRow},${targetCol}).`);
                                } else {
                                    gameLog.push(`${playerLabel}'s ${label} summon succeeded but the chosen square was occupied.`);
                                }
                            } else {
                                gameLog.push(`${playerLabel} failed to summon a ${label}.`);
                            }
                            lastAction = { move: true };
                            movedPieces.add(`${fromRow},${fromCol}`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            checkGameOver();
                            if (movesLeft === 0 && !reinforcementPending) {
                                triggerAiTurn();
                            }
                        },
                        false,
                        false
                    );
                }
                return;
            }

            if (!selectedPiece && piece && piece.player === 'W' && !movedPieces.has(`${row},${col}`)) {
                // During mercenary bonus turn, only allow selecting the specific mercenary
                if (mercenaryBonusTurnActive &&
                    (row !== mercenaryBonusTurnPiece.row || col !== mercenaryBonusTurnPiece.col)) {
                    // Clicked on wrong piece during mercenary bonus turn
                    return;
                }
                selectedPiece = { row, col };
                validMoves = getValidMoves(row, col);
                showPieceInfo(piece, piece.player);
                lastAction = null;
                renderBoard();
                updateEndTurnButton();
            } else if (selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col);
                if (move && movesLeft >= move.cost) {
                    if (move.type === 'move') {
                        // Handle Pistolier capturing by landing - requires coin flip
                        if (move.special === 'pistolierCapture') {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const toRow = row;
                            const toCol = col;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            // Trigger coin toss for capture
                            performCoinToss(
                                'Pistolier Capture',
                                `Attempting to capture at (${toRow},${toCol})...`,
                                (success) => {
                                    if (success) {
                                        // Successfully captured
                                        movePiece(fromRow, fromCol, toRow, toCol, null);
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier successfully captured by landing!`);
                                    } else {
                                        // Failed to capture - still move but don't capture
                                        const targetPiece = board[toRow][toCol];
                                        board[toRow][toCol] = board[fromRow][fromCol];
                                        board[fromRow][fromCol] = null;
                                        // Piece stays in place, no capture
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier failed to capture - move blocked.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    movedPieces.add(`${toRow},${toCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        }

                        // Handle Pistolier move+shoot combination - enter shoot selection mode
                        if (move.special === 'pistolierMoveShoot') {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            // Move to the position first
                            movePiece(fromRow, fromCol, row, col, null);
                            movesLeft -= move.cost;
                            movedPieces.add(`${fromRow},${fromCol}`);
                            movedPieces.add(`${row},${col}`);
                            lastAction = { move: true };

                            // Enter shoot selection mode
                            pistolierMoveShootMode = true;
                            pistolierMoveShootPosition = { row, col };
                            selectedPiece = { row, col };

                            // Generate shoot targets from new position (1 square diagonal only)
                            validMoves = [];
                            for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = row + d[0], shootC = col + d[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== currentPlayer) {
                                    validMoves.push({ type: 'shoot', pos: [shootR, shootC], cost: 0, special: 'pistolierMoveShootFinal' });
                                }
                            }
                            validMoves = filterShootMovesForPlayer(validMoves, currentPlayer);
                            if (!validMoves.length) {
                                pistolierMoveShootMode = false;
                                pistolierMoveShootPosition = null;
                                selectedPiece = null;
                                showPieceInfo(null);
                                renderBoard();
                                updateStatus();
                                updateEndTurnButton();
                                gameLog.push('No valid pistolier targets after moving.');
                                updateGameLog();
                                return;
                            }

                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier moved to (${row},${col}), select shoot target...`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            return;
                        }

                        // Handle Elephantry move+shoot combination - enter shoot selection mode
                        if (move.special === 'elephantryMoveShoot') {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            // Move to the position first
                            movePiece(fromRow, fromCol, row, col, null);
                            movesLeft -= move.cost;
                            movedPieces.add(`${fromRow},${fromCol}`);
                            movedPieces.add(`${row},${col}`);
                            lastAction = { move: true };

                            // Enter shoot selection mode
                            elephantryMoveShootMode = true;
                            elephantryMoveShootPosition = { row, col };
                            selectedPiece = { row, col };

                            // Generate shoot targets from new position
                            validMoves = [];
                            for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = row + d[0], shootC = col + d[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== currentPlayer) {
                                    validMoves.push({ type: 'shoot', pos: [shootR, shootC], cost: 0, special: 'elephantryMoveShootFinal' });
                                }
                            }
                            validMoves = filterShootMovesForPlayer(validMoves, currentPlayer);
                            if (!validMoves.length) {
                                elephantryMoveShootMode = false;
                                elephantryMoveShootPosition = null;
                                selectedPiece = null;
                                showPieceInfo(null);
                                renderBoard();
                                updateStatus();
                                updateEndTurnButton();
                                gameLog.push('No valid elephantry targets after moving.');
                                updateGameLog();
                                return;
                            }

                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry moved to (${row},${col}), select shoot target...`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            return;
                        }

                        // Check if capturing a Spectre - requires coin toss (except for Wizards/Spectres)
                        const targetPiece = board[row][col];
                        const attackingPiece = board[selectedPiece.row][selectedPiece.col];
                        const isCapturingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                        const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';

                        if (isCapturingSpectre && !captureExempt) {
                            // Store move info for callback
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const toRow = row;
                            const toCol = col;
                            const jump = move.jump;
                            const special = move.special;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            // Trigger coin toss
                            performCoinToss(
                                'Capture Spectre',
                                'Attempting to capture the Spectre...',
                                (success) => {
                                    let moveResult = null;
                                    if (success) {
                                        // Successfully captured Spectre
                                        moveResult = movePiece(fromRow, fromCol, toRow, toCol, jump);
                                        if (special === 'charge') {
                                            cavalryChargeUsed[currentPlayer] = true;
                                        }
                                        if (special === 'ballistaDoubleTime') {
                                            ballistaDoubleTimeUsed[currentPlayer]++;
                                        }
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} successfully captured the Spectre!`);
                                    } else {
                                        // Failed to capture Spectre - move not executed
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} failed to capture the Spectre.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);

                                    // Check if mercenary coin flip is needed
                                    if (success && moveResult?.mercenaryFlipNeeded) {
                                        const mercPiece = moveResult.mercenaryPiece;
                                        const mercPos = moveResult.mercenaryPos;

                                        handleMercenaryCoinFlip(mercPiece.player, mercPiece, mercPos.row, mercPos.col, (bonusTurnGranted) => {
                                            selectedPiece = null;
                                            validMoves = [];
                                            showPieceInfo(null);
                                            renderBoard();
                                            updateStatus();
                                            updateEndTurnButton();
                                            updateGameLog();
                                            checkGameOver();

                                            if (bonusTurnGranted) {
                                                return; // Player continues their turn
                                            }

                                            if (mercenaryBonusTurnActive) {
                                                mercenaryBonusTurnActive = false;
                                                mercenaryBonusTurnPiece = null;
                                            }
                                            if (movesLeft === 0 && !reinforcementPending) {
                                                triggerAiTurn();
                                            }
                                        });
                                        return;
                                    }

                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();

                                    // If we were in mercenary bonus turn mode and didn't get another bonus turn, clear the state
                                    if (mercenaryBonusTurnActive) {
                                        mercenaryBonusTurnActive = false;
                                        mercenaryBonusTurnPiece = null;
                                    }
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        } else {
                            // Normal move/capture
                            const moveResult = movePiece(selectedPiece.row, selectedPiece.col, row, col, move.jump);
                            if (move.special === 'charge') {
                                cavalryChargeUsed[currentPlayer] = true;
                            }
                            if (move.special === 'ballistaDoubleTime') {
                                if (board[row][col]?.type === 'Ballista') {
                                    // after moving, board[row][col] is the piece moved
                                }
                                ballistaDoubleTimeUsed[currentPlayer]++;
                            }

                            // Check if mercenary coin flip is needed
                            if (moveResult?.mercenaryFlipNeeded) {
                                const mercPiece = moveResult.mercenaryPiece;
                                const mercPos = moveResult.mercenaryPos;

                                // Show blocking coin flip modal
                                handleMercenaryCoinFlip(mercPiece.player, mercPiece, mercPos.row, mercPos.col, (bonusTurnGranted) => {
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    checkGameOver();

                                    if (bonusTurnGranted) {
                                        return; // Player continues their turn
                                    }

                                    // If we were in mercenary bonus turn mode and didn't get another bonus turn, clear the state
                                    if (mercenaryBonusTurnActive) {
                                        mercenaryBonusTurnActive = false;
                                        mercenaryBonusTurnPiece = null;
                                    }
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                });
                                return; // Exit to wait for coin flip callback
                            }

                            // If we were in mercenary bonus turn mode and didn't get another bonus turn, clear the state
                            if (mercenaryBonusTurnActive) {
                                mercenaryBonusTurnActive = false;
                                mercenaryBonusTurnPiece = null;
                            }
                        }
                    } else if (move.type === 'shoot') {
                        // Check if shooting a Spectre - requires coin toss (except for Wizards/Spectres)
                        const targetPiece = board[row][col];
                        const attackingPiece = board[selectedPiece.row][selectedPiece.col];
                        const isShootingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                        const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';
                        const autoCrackShot = move.special === 'fusilierCrackShotAuto';
                        const usingCrackShot = attackingPiece && attackingPiece.type === 'Fusilier' && fusilierCrackShotActive === attackingPiece;
                        const isNecromancerShot = attackingPiece && attackingPiece.type === 'Necromancer' && move.special === 'necromancerShoot';

                        if (isShootingSpectre && !captureExempt) {
                            gameLog.push('Spectres are immune to standard shooting attacks.');
                            updateGameLog();
                            return;
                        } else if (autoCrackShot) {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const pieceKey = `${fromRow},${fromCol},${currentPlayer}`;

                            movesLeft -= move.cost;

                            if (!(pieceKey in fusilierCrackShotCount)) {
                                fusilierCrackShotCount[pieceKey] = 3;
                            }
                            if (fusilierCrackShotCount[pieceKey] > 0) {
                                fusilierCrackShotCount[pieceKey]--;
                            }

                            performCoinToss(
                                'Crack Shot',
                                'Attempting Crack Shot...',
                                (success) => {
                                    fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                    fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);

                                    if (success) {
                                        shootPiece(fromRow, fromCol, row, col);
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot hit!`);
                                    } else {
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot missed.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        } else if (usingCrackShot) {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            performCoinToss(
                                'Crack Shot',
                                'Attempting Crack Shot...',
                                (success) => {
                                    // Mark the shot attempt for cooldown regardless of outcome
                                    fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                    fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);

                                    fusilierCrackShotActive = null;

                                    if (success) {
                                        shootPiece(fromRow, fromCol, row, col);
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot hit!`);
                                    } else {
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot missed.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        } else {
                            // Normal shoot
                            shootPiece(selectedPiece.row, selectedPiece.col, row, col);
                            if (move.special === 'archerDiag2') {
                                archerDiag2ShootUsed[currentPlayer]++;
                            }
                            if (isNecromancerShot) {
                                setNecromancerShotCooldown(attackingPiece, 2);
                            }
                        }
                    } else if (move.type === 'swap') {
                        const guardRow = move.pos[0];
                        const guardCol = move.pos[1];
                        const guard = board[guardRow][guardCol];
                        board[guardRow][guardCol] = board[selectedPiece.row][selectedPiece.col];
                        board[selectedPiece.row][selectedPiece.col] = guard;
                        kingSpecialUsed[currentPlayer] = true;
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Guard of Honour to swap King and Guard at (${selectedPiece.row},${selectedPiece.col}) and (${guardRow},${guardCol})`);
                        checkSupremacy(currentPlayer);
                        movedPieces.add(`${guardRow},${guardCol}`);
                        movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    } else if (move.type === 'teleport') {
                        const teleportPiece = board[selectedPiece.row][selectedPiece.col];
                        const abilityLabel = `${teleportPiece.type} Teleport`;
                        const result = teleportOntoSquare(selectedPiece.row, selectedPiece.col, move.pos[0], move.pos[1], currentPlayer, abilityLabel);
                        if (!result.success) {
                            cancelSpecialModes({ resetSelection: false });
                            return;
                        }
                        if (teleportPiece.type === 'Wizard') {
                            wizardTeleportUsed[currentPlayer]++;
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Wizard from (${selectedPiece.row},${selectedPiece.col}) to (${move.pos[0]},${move.pos[1]})`);
                        } else if (teleportPiece.type === 'Necromancer') {
                            incrementNecromancerTeleportCount(teleportPiece);
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Necromancer from (${selectedPiece.row},${selectedPiece.col}) to (${move.pos[0]},${move.pos[1]})`);
                        } else {
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported ${teleportPiece.type} from (${selectedPiece.row},${selectedPiece.col}) to (${move.pos[0]},${move.pos[1]})`);
                        }
                        movedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                    } else if (move.type === 'teleportSwap') {
                        const opponentWizardRow = row;
                        const opponentWizardCol = col;
                        const playerWizard = board[selectedPiece.row][selectedPiece.col];
                        const opponentWizard = board[opponentWizardRow][opponentWizardCol];
                        board[opponentWizardRow][opponentWizardCol] = playerWizard;
                        board[selectedPiece.row][selectedPiece.col] = opponentWizard;
                        wizardTeleportSwapUsed[currentPlayer] = true;
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Teleport Swap to swap Wizard at (${selectedPiece.row},${selectedPiece.col}) with opponent's Wizard at (${opponentWizardRow},${opponentWizardCol})`);
                        movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                        movedPieces.add(`${opponentWizardRow},${opponentWizardCol}`);
                    }
                    // Only deduct move cost if not in mercenary bonus turn mode
                    if (!mercenaryBonusTurnActive) {
                        movesLeft -= move.cost;
                    }
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    if (move.type === 'move' || move.type === 'teleport') {
                        movedPieces.add(`${row},${col}`);
                    }
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    // Clear mercenary bonus turn state after move completes
                    if (mercenaryBonusTurnActive) {
                        mercenaryBonusTurnActive = false;
                        mercenaryBonusTurnPiece = null;
                    }
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes();
                }
            }
        }

        function openTurnModal() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (turnablePieces.includes(piece.type) && movesLeft >= turnCosts[piece.type]) {
                const validDirections = getValidTurnDirections(piece.facing);
                const select = document.getElementById('turn-select');
                select.innerHTML = validDirections.map(dir => `<option value="${dir}">${dir} (${facingIcons[dir]})</option>`).join('');
                document.getElementById('turn-modal').style.display = 'block';
            }
        }

        function activateBallistaRange() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || ballistaRangeBoostUsedThisTurn[currentPlayer]) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Ballista') {
                ballistaRangeBoostActive[currentPlayer] = true;
                ballistaRangeBoostUsedThisTurn[currentPlayer] = true;
                movesLeft -= 2;
                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} activated Ballista Extend Range (+1 range this round)`);
                // Keep the piece selected and recalculate valid moves with extended range
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                checkGameOver();
                if (movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                }
            }
        }

        function getBallistaDoubleTimeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            let moves = [];
            for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                const r1 = row + d[0], c1 = col + d[1];
                const r2 = row + d[0]*2, c2 = col + d[1]*2;
                if (!isValid(r1, c1) || board[r1][c1]) continue; // path blocked on first
                if (isValid(r2, c2) && !board[r2][c2]) {
                    // Ballista can only move to empty squares - cannot capture by landing
                    moves.push({ type: 'move', pos: [r2, c2], cost: 2, special: 'ballistaDoubleTime' });
                }
            }
            return filterShootMovesForPlayer(moves, player);
        }

        function activateBallistaDoubleTime() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || ballistaDoubleTimeUsed[currentPlayer] >= 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Ballista') {
                const options = getBallistaDoubleTimeMoves(selectedPiece.row, selectedPiece.col);
                validMoves = options;
                renderBoard();
            }
        }
        function activateArcherMoveDiagShoot() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (archerMoveDiagMode || archerDiagShootSelectMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Archer' && archerMoveDiagShootUsed[currentPlayer] < 2) {
                archerMoveDiagMode = true;
                archerMoveDiagStart = { row: selectedPiece.row, col: selectedPiece.col };
                // Only allow the Archer's basic 1-square orthogonal moves for the first step
                const moves = pieceTypes['Archer'].move(selectedPiece.row, selectedPiece.col, board, currentPlayer, null, piece.facing) || [];
                validMoves = moves.filter(m => m.type === 'move' && m.cost === 1);
                renderBoard();
            }
        }

        function activateArcherDiag2Shoot() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (archerDiag2ShootMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Archer' && archerDiag2ShootUsed[currentPlayer] < 2) {
                archerDiag2ShootMode = true;
                // Compute diagonal 2-square shoot targets
                const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                const row = selectedPiece.row, col = selectedPiece.col;
                let options = [];
                for (let d of dirs) {
                    const nr = row + d[0]*2, nc = col + d[1]*2;
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== currentPlayer) {
                        options.push({ type: 'shoot', pos: [nr, nc], cost: 2, special: 'archerDiag2' });
                    }
                }
                options = filterShootMovesForPlayer(options, currentPlayer);
                if (!options.length) {
                    archerDiag2ShootMode = false;
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    gameLog.push('No valid targets for Archer diagonal double shot.');
                    updateGameLog();
                    return;
                }
                validMoves = options;
                renderBoard();
            }
        }

        function activateStrafe() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (strafeMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            const usedCount = piece.type === 'Wizard' ? wizardStrafeUsed[currentPlayer] : dragonStrafeUsed[currentPlayer];

            if ((piece.type === 'Wizard' || piece.type === 'Dragon') && usedCount < 2) {
                strafeMode = true;
                // Compute orthogonal 1-square moves to empty squares only
                const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                const row = selectedPiece.row, col = selectedPiece.col;
                let options = [];
                for (let d of dirs) {
                    const nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        options.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'strafe' });
                    }
                }
                validMoves = options;
                renderBoard();
            }
        }

        function activateSummonSpectre() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (summonSpectreMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            const totalCaptured = capturedPieces['W'].length + capturedPieces['B'].length;

            if (piece.type === 'Wizard' && spectresSummoned[currentPlayer] < 2 && !wizardSummonedThisTurn[currentPlayer] && totalCaptured >= 5) {
                summonSpectreMode = true;
                // Compute adjacent squares (8 directions) for Spectre placement
                const dirs = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                const row = selectedPiece.row, col = selectedPiece.col;
                let options = [];
                for (let d of dirs) {
                    const nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        options.push({ type: 'summon', pos: [nr, nc], cost: 2, special: 'summonSpectre' });
                    }
                }
                validMoves = options;
                renderBoard();
            }
        }

        function activateChampionSummon(type) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (championSummonMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            if (isAnySpecialModeActive()) {
                cancelSpecialModes({ resetSelection: false });
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || piece.type !== 'Champion' || (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme')) return;
            if (type === 'Necromancer') {
                if (!canChampionSummonNecromancer(currentPlayer)) {
                    gameLog.push('No Necromancer summons remaining.');
                    updateGameLog();
                    return;
                }
            } else if (type === 'Huntsman') {
                if (!canChampionSummonHuntsman(currentPlayer)) {
                    gameLog.push('No Huntsman summons remaining.');
                    updateGameLog();
                    return;
                }
            } else {
                return;
            }
            if (!hasBackRowSpawnSlot(currentPlayer)) {
                gameLog.push('No open squares on the back row to summon a unit.');
                updateGameLog();
                return;
            }
            const backRow = currentPlayer === 'W' ? ROWS - 1 : 0;
            const options = [];
            for (let c = 0; c < COLS; c++) {
                if (!board[backRow][c]) {
                    options.push({ type: 'summon', pos: [backRow, c], cost: 2, special: 'championSummon', summonType: type });
                }
            }
            if (!options.length) {
                gameLog.push('No open squares on the back row to summon a unit.');
                updateGameLog();
                return;
            }
            championSummonMode = { type, source: { row: selectedPiece.row, col: selectedPiece.col } };
            validMoves = options;
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            gameLog.push(`Select a back row square to summon a ${type}.`);
            updateGameLog();
        }

        function activateNecromancerSummon(type) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (necromancerSummonMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            if (isAnySpecialModeActive()) {
                cancelSpecialModes({ resetSelection: false });
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || piece.type !== 'Necromancer' || (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme')) return;
            const isZombieSummon = type === 'zombie';
            const isSpectreSummon = type === 'spectre';
            if (!isZombieSummon && !isSpectreSummon) return;
            if (isZombieSummon) {
                const maxZombies = getMaxZombies(currentPlayer);
                if ((zombiesSummoned[currentPlayer] || 0) >= maxZombies) {
                    gameLog.push('Zombie limit reached. Cannot summon more.');
                    updateGameLog();
                    return;
                }
            } else if (spectresSummoned[currentPlayer] >= 2) {
                gameLog.push('Spectre limit reached. Cannot summon more.');
                updateGameLog();
                return;
            }
            let options = [];
            if (isSpectreSummon) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const nr = selectedPiece.row + dr;
                        const nc = selectedPiece.col + dc;
                        if (!isValid(nr, nc)) continue;
                        if (!board[nr][nc]) {
                            options.push({ type: 'summon', pos: [nr, nc], cost: 2, special: 'necromancerSummon', summonType: type });
                        }
                    }
                }
                if (!options.length) {
                    gameLog.push('No adjacent squares available next to the Necromancer to summon a Spectre.');
                    updateGameLog();
                    return;
                }
            } else {
                if (!hasBackRowSpawnSlot(currentPlayer)) {
                    gameLog.push('No open squares on the back row to place a summon.');
                    updateGameLog();
                    return;
                }
                const backRow = currentPlayer === 'W' ? ROWS - 1 : 0;
                for (let c = 0; c < COLS; c++) {
                    if (!board[backRow][c]) {
                        options.push({ type: 'summon', pos: [backRow, c], cost: 2, special: 'necromancerSummon', summonType: type });
                    }
                }
                if (!options.length) {
                    gameLog.push('No open squares on the back row to place a summon.');
                    updateGameLog();
                    return;
                }
            }
            necromancerSummonMode = { type, source: { row: selectedPiece.row, col: selectedPiece.col } };
            validMoves = options;
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            const label = type === 'spectre' ? 'Spectre' : 'Zombie';
            const placementLabel = isSpectreSummon ? 'an adjacent square' : 'a back row square';
            gameLog.push(`Select ${placementLabel} to summon a ${label}.`);
            updateGameLog();
        }

        function activateMoralBoost() {
            if (!selectedPiece || reinforcementPending || movesLeft !== 1 || lastAction?.move) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || piece.type !== 'King') return;
            if (moralBoostUses[currentPlayer] >= MORAL_BOOST_LIMIT) {
                gameLog.push('Moral Boost already used twice this game.');
                updateGameLog();
                return;
            }
            moralBoostUses[currentPlayer]++;
            movesLeft = Math.max(0, movesLeft - 1);
            updateStatus();
            updateEndTurnButton();
            const fromRow = selectedPiece.row;
            const fromCol = selectedPiece.col;
            const actorLabel = currentPlayer === 'W' ? 'Player' : getOpponentDisplayName();
            performCoinToss(
                'Moral Boost',
                'Attempting to rally the troops...',
                (success) => {
                    if (success) {
                        nextRoundModifier[currentPlayer] += MORAL_BOOST_BONUS;
                        gameLog.push(`${actorLabel} succeeded with Moral Boost! +2 moves next round.`);
                        showWarcryAchievementPopup(currentPlayer, { title: 'MORAL BOOST', subtitle: '+2 Next Round' });
                    } else {
                        gameLog.push(`${actorLabel} failed to inspire a Moral Boost.`);
                    }
                    lastAction = { special: 'moralBoost' };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                },
                false,
                false
            );
        }

        function activateKingShot() {
            if (!selectedPiece || reinforcementPending || lastAction?.move || movesLeft < 1) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!hasKingShotAvailableForPiece(piece)) return;
            if (kingShotMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            if (!isKingAdjacentToGuard(selectedPiece.row, selectedPiece.col, currentPlayer)) {
                gameLog.push('King Shot requires the King to be adjacent to a friendly Guard.');
                updateGameLog();
                return;
            }
            const targets = getKingShotTargets(selectedPiece.row, selectedPiece.col, currentPlayer);
            if (!targets.length) {
                gameLog.push('No valid targets for King Shot within range.');
                updateGameLog();
                return;
            }
            kingShotMode = { row: selectedPiece.row, col: selectedPiece.col };
            validMoves = targets.map(([r, c]) => ({ type: 'shoot', pos: [r, c], cost: 1, special: 'kingShot' }));
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            gameLog.push('Select a target for King Shot (range 3, excludes Spectres).');
            updateGameLog();
        }

        function activateKingEvade() {
            if (!selectedPiece || reinforcementPending) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || piece.type !== 'King' || kingEvadeUsed[currentPlayer]) return;
            if (kingEvadeMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            if (!isKingThreatened(currentPlayer)) {
                gameLog.push('King Evade is only available while the King is in danger.');
                updateGameLog();
                return;
            }
            const moves = getKingEvadeMoves(selectedPiece.row, selectedPiece.col, currentPlayer);
            if (!moves.length) {
                gameLog.push('No available escape route for King Evade.');
                updateGameLog();
                return;
            }
            kingEvadeMode = { row: selectedPiece.row, col: selectedPiece.col, player: currentPlayer };
            validMoves = moves;
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            gameLog.push('Select a destination for Evade (costs 2 moves next round).');
            updateGameLog();
        }

        function confirmTurn() {
            if (!selectedPiece) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const newFacing = document.getElementById('turn-select').value;
            turnPiece(selectedPiece.row, selectedPiece.col, newFacing);
            document.getElementById('turn-modal').style.display = 'none';
            movesLeft -= turnCosts[piece.type];
            movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
            selectedPiece = null;
            validMoves = [];
            showPieceInfo(null);
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
            checkGameOver();
            if (movesLeft === 0 && !reinforcementPending) {
                triggerAiTurn();
            }
        }

        function openTurnAndMoveModal() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Infantry' && movesLeft >= 2) {
                const validDirections = getValidTurnDirections(piece.facing);
                const select = document.getElementById('turn-move-select');
                select.innerHTML = validDirections.map(dir => `<option value="${dir}">${dir} (${facingIcons[dir]})</option>`).join('');
                document.getElementById('turn-move-modal').style.display = 'block';
            }
        }

        function confirmTurnAndMove() {
            if (!selectedPiece) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const newFacing = document.getElementById('turn-move-select').value;
            turnPiece(selectedPiece.row, selectedPiece.col, newFacing);
            document.getElementById('turn-move-modal').style.display = 'none';
            movesLeft -= 1;
            lastAction = { turn: true };
            turnAndMoveMode = true;
            validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
        }

        function closeTurnModal() {
            const modal = document.getElementById('turn-modal');
            if (modal) modal.style.display = 'none';
        }

        function openKingSummonModal() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'King' && (gameVariant === '36s-expert' || gameVariant === '36s-elite' || gameVariant === '36s-supreme')) {
                if (!hasBackRowSpawnSlot(currentPlayer)) {
                    gameLog.push('No open squares on the back row to summon a unit.');
                    updateGameLog();
                    return;
                }
                const select = document.getElementById('king-summon-select');
                select.innerHTML = '';

                // Add available summon options
                if (pistoliersSummoned[currentPlayer] < 2) {
                    const option = document.createElement('option');
                    option.value = 'Pistolier';
                    option.textContent = `Pistolier (${pistoliersSummoned[currentPlayer]}/2 summoned)`;
                    select.appendChild(option);
                }
                if (fusiliersSummoned[currentPlayer] < 2) {
                    const option = document.createElement('option');
                    option.value = 'Fusilier';
                    option.textContent = `Fusilier (${fusiliersSummoned[currentPlayer]}/2 summoned)`;
                    select.appendChild(option);
                }

                if (select.options.length > 0) {
                    document.getElementById('king-summon-modal').style.display = 'block';
                }
            }
        }

        function closeKingSummonModal() {
            const modal = document.getElementById('king-summon-modal');
            if (modal) modal.style.display = 'none';
        }

        function confirmKingSummon() {
            if (!selectedPiece || currentPlayer !== 'W') return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type !== 'King') return;

            const select = document.getElementById('king-summon-select');
            const unitType = select.value;

            if (!unitType) return;

            // Close modal
            closeKingSummonModal();

            // Deduct points immediately
            movesLeft -= 2;

        // Perform coin toss for summon
        performCoinToss(
            'Summon Unit',
            `Attempting to summon ${unitType}...`,
            (success) => {
                    if (success) {
                        // Find empty square in back row
                        const backRow = currentPlayer === 'W' ? ROWS - 1 : 0;
                        let emptySquares = [];
                        for (let c = 0; c < COLS; c++) {
                            if (!board[backRow][c]) {
                                emptySquares.push(c);
                            }
                        }

                        if (emptySquares.length > 0) {
                            // Place unit in first available empty square
                            const col = emptySquares[0];
                            const facing = currentPlayer === 'W' ? 'U' : 'D';
                            board[backRow][col] = { type: unitType, player: currentPlayer, facing: facing };

                            // Update summon counter
                            if (unitType === 'Pistolier') {
                                pistoliersSummoned[currentPlayer]++;
                            } else if (unitType === 'Fusilier') {
                                fusiliersSummoned[currentPlayer]++;
                            }

                            gameStats.summonCount[currentPlayer]++; // Track summon for statistics
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} successfully summoned ${unitType} at (${backRow},${col})!`);
                        } else {
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} succeeded summon but no empty squares in back row!`);
                        }
                    } else {
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} failed to summon ${unitType}.`);
                    }

                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                },
                false, // automated
                false  // showOverlay
            );
        }

        function getValidTeleportSwapMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            const opponent = player === 'W' ? 'B' : 'W';
            const color = (row + col) % 2;
            let moves = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] && board[r][c].type === 'Wizard' && board[r][c].player === opponent && (r + c) % 2 === color) {
                        moves.push({ type: 'teleportSwap', pos: [r, c], cost: 2 });
                    }
                }
            }
            return moves;
        }

        function getValidChargeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            let moves = [];
            for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                let r = row, c = col;
                while (true) {
                    r += d[0];
                    c += d[1];
                    if (!isValid(r, c)) break;
                    if (board[r][c]) {
                        if (board[r][c].player !== player) {
                            moves.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                        }
                        break;
                    }
                    moves.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                }
            }
            return moves;
        }

        function getElephantryChargeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            const facing = piece.facing;
            const pieceKey = `${row},${col},${player}`;
            let moves = [];

            if (elephantryChargeUsed.has(pieceKey)) return moves;

            // Determine forward directions based on facing
            let directions = [];
            if (facing === 'U') {
                directions = [[-1,0], [-1,-1], [-1,1]]; // Up, Up-Left, Up-Right
            } else if (facing === 'D') {
                directions = [[1,0], [1,-1], [1,1]]; // Down, Down-Left, Down-Right
            } else if (facing === 'L') {
                directions = [[0,-1], [-1,-1], [1,-1]]; // Left, Up-Left, Down-Left
            } else if (facing === 'R') {
                directions = [[0,1], [-1,1], [1,1]]; // Right, Up-Right, Down-Right
            }

            for (let d of directions) {
                let capturesInPath = [];
                let canCharge = true;
                let finalPos = null;

                // Check all 3 squares in this direction
                for (let dist = 1; dist <= 3; dist++) {
                    let r = row + d[0] * dist;
                    let c = col + d[1] * dist;

                    if (!isValid(r, c)) {
                        canCharge = false;
                        break;
                    }

                    const target = board[r][c];
                    if (target) {
                        // Cannot charge through Spectre or Zombies
                        if (target.type === 'Spectre' || target.type === 'Zombie') {
                            canCharge = false;
                            break;
                        }

                        // Can capture enemy pieces
                        if (target.player !== player) {
                            capturesInPath.push([r, c, target.type]);
                            // Stop on Elephantry, Ogre, Troll, or Dragon (but still capture them)
                            if (target.type === 'Elephantry' || target.type === 'Ogre' || target.type === 'Troll' || target.type === 'Dragon') {
                                finalPos = [r, c];
                                break;
                            }
                        } else {
                            // Cannot charge through own pieces
                            canCharge = false;
                            break;
                        }
                    }

                    // If we've gone 3 squares without stopping, this is the final position
                    if (dist === 3) {
                        finalPos = [r, c];
                    }
                }

                if (canCharge && finalPos) {
                    moves.push({
                        type: 'move',
                        pos: finalPos,
                        cost: 2,
                        special: 'elephantryCharge',
                        captures: capturesInPath
                    });
                }
            }

            return moves;
        }

        function getElephantryExtendedRangeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            const pieceKey = `${row},${col},${player}`;
            let moves = [];

            // Initialize if not set
            if (!(pieceKey in elephantryExtendedRangeShotsRemaining)) {
                elephantryExtendedRangeShotsRemaining[pieceKey] = 3;
            }

            if (elephantryExtendedRangeShotsRemaining[pieceKey] <= 0) return moves;

            // Can shoot 2 squares in any direction
            for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                for (let dist = 1; dist <= 2; dist++) {
                    let nr = row + d[0] * dist;
                    let nc = col + d[1] * dist;
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== player) {
                        moves.push({
                            type: 'shoot',
                            pos: [nr, nc],
                            cost: 0, // No additional cost per shot - already paid 2 points on activation
                            special: 'elephantryExtendedRange',
                            shotsRemaining: elephantryExtendedRangeShotsRemaining[pieceKey]
                        });
                    }
                }
            }

            return moves;
        }

        function handleClick(row, col) {
            const huntsmanSelectionActive = !!(huntsmanBurstMode && selectedPiece && selectedPiece.row === huntsmanBurstMode.row && selectedPiece.col === huntsmanBurstMode.col);
            if (gameOver || currentPlayer !== 'W' || reinforcementPending || zombieAutoAdvanceInProgress) return;
            if (gamePaused && !huntsmanSelectionActive) return;
            const piece = board[row][col];

            if (isAnySpecialModeActive() && !huntsmanSelectionActive) {
                if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                    cancelSpecialModes({ resetSelection: false });
                    return;
                }
                if (!selectedPiece) {
                    cancelSpecialModes();
                    return;
                }
                // Don't auto-cancel when clicking different squares - let mode handlers decide
                // if (selectedPiece && (selectedPiece.row !== row || selectedPiece.col !== col)) {
                //     cancelSpecialModes();
                // }
            }

            // Handle Inferno Mode
            if (infernoMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'inferno');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const toRow = move.pos[0];
                    const toCol = move.pos[1];

                    // 1. Perform the initial 1-square move (handles landing capture)
                    movePiece(fromRow, fromCol, toRow, toCol, null);
                    
                    // 2. Perform the adjacent Inferno captures
                    performInfernoCapture(toRow, toCol, currentPlayer);

                    // 3. Update state
                    dragonInfernoUsed[currentPlayer] = true;
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    movedPieces.add(`${toRow},${toCol}`);
                    
                    selectedPiece = null;
                    validMoves = [];
                    infernoMode = false;
                    
                    // 4. Re-render and check game state
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
                else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            
            // Handle Archer Turn+Shoot mode (after confirming turn)
            if (turnAndShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'shoot');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    shootPiece(fromRow, fromCol, row, col);
                    movesLeft -= move.cost; // spend second point
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    selectedPiece = null;
                    validMoves = [];
                    turnAndShootMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Archer Move + Diagonal (1) Shoot special
            if (archerMoveDiagMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'move');
                if (move && movesLeft >= 1) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    // Perform the 1-point move first
                    movePiece(fromRow, fromCol, row, col, move.jump);
                    movesLeft -= 1;
                    // Prepare diagonal 1-square shoot options from new position
                    selectedPiece = { row, col };
                    const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                    let options = [];
                    for (let d of dirs) {
                        const nr = row + d[0], nc = col + d[1];
                        if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== currentPlayer) {
                            options.push({ type: 'shoot', pos: [nr, nc], cost: 1, special: 'archerDiag1' });
                        }
                    }
                    options = filterShootMovesForPlayer(options, currentPlayer);
                    if (!options.length) {
                        archerMoveDiagMode = false;
                        archerDiagShootSelectMode = false;
                        selectedPiece = null;
                        validMoves = [];
                        showPieceInfo(null);
                        renderBoard();
                        updateStatus();
                        updateEndTurnButton();
                        gameLog.push('No valid targets for Archer diagonal shot.');
                        updateGameLog();
                        return;
                    }
                    validMoves = options;
                    // Switch to the second phase: select diagonal shot
                    archerMoveDiagMode = false;
                    archerDiagShootSelectMode = true;
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle second phase of Archer Move + Diagonal (1) Shoot
            if (archerDiagShootSelectMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'shoot');
                if (move && movesLeft >= move.cost) {
                    const currentRow = selectedPiece.row;
                    const currentCol = selectedPiece.col;
                    shootPiece(currentRow, currentCol, row, col);
                    movesLeft -= move.cost; // spend second point
                    lastAction = { move: true };
                    // Mark both original and current squares as moved if we have the original
                    if (archerMoveDiagStart) {
                        movedPieces.add(`${archerMoveDiagStart.row},${archerMoveDiagStart.col}`);
                    }
                    movedPieces.add(`${currentRow},${currentCol}`);
                    archerMoveDiagShootUsed[currentPlayer]++;
                    selectedPiece = null;
                    validMoves = [];
                    archerDiagShootSelectMode = false;
                    archerMoveDiagStart = null;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Archer Diagonal 2-square Shot special
            if (archerDiag2ShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'shoot');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    shootPiece(fromRow, fromCol, row, col);
                    movesLeft -= move.cost; // cost 2
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    archerDiag2ShootUsed[currentPlayer]++;
                    selectedPiece = null;
                    validMoves = [];
                    archerDiag2ShootMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Strafe special move
            if (summonSpectreMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'summonSpectre');
                if (move && movesLeft >= move.cost) {
                    const wizardRow = selectedPiece.row;
                    const wizardCol = selectedPiece.col;
                    const wizardPiece = board[wizardRow][wizardCol];

                    // Store placement info for callback
                    const summonRow = row;
                    const summonCol = col;

                    // Deduct points immediately
                    movesLeft -= move.cost; // cost 2

                    // Trigger coin toss
                    performCoinToss(
                        'Summon Spectre',
                        'Attempting to summon a Spectre...',
                        (success) => {
                            if (success) {
                                // Place Spectre at selected location
                                board[summonRow][summonCol] = { type: 'Spectre', player: currentPlayer };
                                spectresSummoned[currentPlayer]++;
                                wizardSummonedThisTurn[currentPlayer] = true;

                                // Mark wizard as unable to move next turn
                                wizardCannotMoveNextTurn[currentPlayer].add(`${wizardRow},${wizardCol}`);

                                // Award 3 bonus points for successful summoning
                                scores[currentPlayer] += 3;
                                registerScoreGain(currentPlayer, 3);
                                updateScoreDisplay();

                                gameStats.summonCount[currentPlayer]++; // Track summon for statistics
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} summoned a Spectre! (+3 bonus points)`);
                            } else {
                                // Failed summoning
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} failed to summon a Spectre.`);
                            }

                            selectedPiece = null;
                            validMoves = [];
                            summonSpectreMode = false;
                            showPieceInfo(null);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            checkGameOver();
                            if (movesLeft === 0 && !reinforcementPending) {
                                triggerAiTurn();
                            }
                        },
                        false, // automated
                        false  // showOverlay
                    );
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            if (strafeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'strafe');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const piece = board[fromRow][fromCol];

                    // Perform the move
                    movePiece(fromRow, fromCol, row, col);
                    movesLeft -= move.cost; // cost 2
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    movedPieces.add(`${row},${col}`); // Mark destination as moved so piece can't move again

                    // Increment usage counter based on piece type
                    if (piece.type === 'Wizard') {
                        wizardStrafeUsed[currentPlayer]++;
                    } else if (piece.type === 'Dragon') {
                        dragonStrafeUsed[currentPlayer]++;
                    }

                    selectedPiece = null;
                    validMoves = [];
                    strafeMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Fusilier Strafe special move
            if (fusilierStrafeActive && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'fusilierStrafe');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;

                    // Perform the move (no capture)
                    board[row][col] = board[fromRow][fromCol];
                    board[fromRow][fromCol] = null;

                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier strafed to (${row},${col})`);

                    selectedPiece = null;
                    validMoves = [];
                    fusilierStrafeActive = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            if (turnAndMoveMode && selectedPiece && board[selectedPiece.row][selectedPiece.col]?.type === 'Infantry') {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col);
                if (move && move.type === 'move' && movesLeft >= 1) {
                    movePiece(selectedPiece.row, selectedPiece.col, row, col, move.jump);
                    movesLeft -= 1;
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    turnAndMoveMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (guardOfHonourMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'swap');
                if (move && movesLeft >= move.cost) {
                    const guardRow = move.pos[0];
                    const guardCol = move.pos[1];
                    const guard = board[guardRow][guardCol];
                    board[guardRow][guardCol] = board[selectedPiece.row][selectedPiece.col];
                    board[selectedPiece.row][selectedPiece.col] = guard;
                    kingSpecialUsed[currentPlayer] = true;
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Guard of Honour to swap King and Guard at (${selectedPiece.row},${selectedPiece.col}) and (${guardRow},${guardCol})`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${guardRow},${guardCol}`);
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    selectedPiece = null;
                    validMoves = [];
                    guardOfHonourMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    checkSupremacy(currentPlayer);
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (teleportMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'teleport');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const teleportPiece = board[fromRow][fromCol];
                    board[move.pos[0]][move.pos[1]] = teleportPiece;
                    board[fromRow][fromCol] = null;
                    if (teleportPiece.type === 'Wizard') {
                        wizardTeleportUsed[currentPlayer]++;
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Wizard from (${fromRow},${fromCol}) to (${move.pos[0]},${move.pos[1]})`);
                    } else if (teleportPiece.type === 'Necromancer') {
                        incrementNecromancerTeleportCount(teleportPiece);
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Necromancer from (${fromRow},${fromCol}) to (${move.pos[0]},${move.pos[1]})`);
                    } else {
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported ${teleportPiece.type} from (${fromRow},${fromCol}) to (${move.pos[0]},${move.pos[1]})`);
                    }
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                    selectedPiece = null;
                    validMoves = [];
                    teleportMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (teleportSwapMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'teleportSwap');
                if (move && movesLeft >= move.cost) {
                    const opponentWizardRow = move.pos[0];
                    const opponentWizardCol = move.pos[1];
                    const playerWizard = board[selectedPiece.row][selectedPiece.col];
                    const opponentWizard = board[opponentWizardRow][opponentWizardCol];
                    board[opponentWizardRow][opponentWizardCol] = playerWizard;
                    board[selectedPiece.row][selectedPiece.col] = opponentWizard;
                    wizardTeleportSwapUsed[currentPlayer] = true;
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Teleport Swap to swap Wizard at (${selectedPiece.row},${selectedPiece.col}) with opponent's Wizard at (${opponentWizardRow},${opponentWizardCol})`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    movedPieces.add(`${opponentWizardRow},${opponentWizardCol}`);
                    selectedPiece = null;
                    validMoves = [];
                    teleportSwapMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (chargeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'move');
                if (move && movesLeft >= move.cost) {
                    movePiece(selectedPiece.row, selectedPiece.col, row, col, move.jump);
                    cavalryChargeUsed[currentPlayer] = true;
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Charge to move Cavalry from (${selectedPiece.row},${selectedPiece.col}) to (${row},${col})`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    chargeMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Elephantry Charge
            if (elephantryChargeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'elephantryCharge');
                if (move && movesLeft >= move.cost) {
                    const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;

                    // Process all captures along the path
                    if (move.captures && move.captures.length > 0) {
                        for (let [captureRow, captureCol, captureType] of move.captures) {
                            const capturedPiece = board[captureRow][captureCol];
                            if (capturedPiece) {
                                capturedSquares.push([captureRow, captureCol]);
                                capturedPieces[currentPlayer].push(capturedPiece);
                                const captureValue = pieceValues[capturedPiece.type];
                                scores[currentPlayer] += captureValue;
                                registerScoreGain(currentPlayer, captureValue);
                                registerPieceLoss(capturedPiece.player, capturedPiece.type);
                                trackCapture(currentPlayer); // Track capture for statistics
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry charged and captured ${capturedPiece.type} (+${captureValue} points) at (${captureRow},${captureCol})`);

                                if (capturedPiece.type === 'Champion') {
                                    championCaptured[capturedPiece.player] = true;
                                }
                                if (capturedPiece.type === 'King') {
                                    endGame(currentPlayer);
                                    return;
                                }
                                board[captureRow][captureCol] = null;
                            }
                        }
                    }

                    // Move the Elephantry to final position
                    movePiece(fromRow, fromCol, row, col, null);
                    elephantryChargeUsed.add(pieceKey);
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Elephantry Charge from (${fromRow},${fromCol}) to (${row},${col})`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    elephantryChargeMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    updateCapturedPiecesDisplay();
                    updateScoreDisplay();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Pistolier move+shoot final shot selection
            if (pistolierMoveShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'pistolierMoveShootFinal');
                if (move) {
                    // Execute the shoot
                    shootPiece(selectedPiece.row, selectedPiece.col, row, col);
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier shot at (${row},${col})`);

                    // Clean up
                    pistolierMoveShootMode = false;
                    pistolierMoveShootPosition = null;
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Elephantry move+shoot final shot selection
            if (elephantryMoveShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'elephantryMoveShootFinal');
                if (move) {
                    // Execute the shoot
                    shootPiece(selectedPiece.row, selectedPiece.col, row, col);
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry shot at (${row},${col})`);

                    // Clean up
                    elephantryMoveShootMode = false;
                    elephantryMoveShootPosition = null;
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Elephantry Triple Shot
            if (elephantryExtendedRangeActive && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'elephantryExtendedRange');
                if (move) {
                    const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
                    const targetRow = row;
                    const targetCol = col;
                    const elephantryRow = selectedPiece.row;
                    const elephantryCol = selectedPiece.col;

                    // Trigger coin flip for this shot
                    performCoinToss(
                        'Elephantry Triple Shot',
                        `Shot ${4 - elephantryExtendedRangeShotsRemaining[pieceKey]}/3: Attempting shot at (${targetRow},${targetCol})...`,
                        (success) => {
                            if (success) {
                                // Successful hit - capture the target
                                const targetPiece = board[targetRow][targetCol];
                                if (targetPiece && targetPiece.player !== currentPlayer) {
                                    capturedSquares.push([targetRow, targetCol]);
                                    capturedPieces[currentPlayer].push(targetPiece);
                                    const captureValue = pieceValues[targetPiece.type];
                                    scores[currentPlayer] += captureValue;
                                    registerScoreGain(currentPlayer, captureValue);
                                    registerPieceLoss(targetPiece.player, targetPiece.type);
                                    trackCapture(currentPlayer); // Track capture for statistics
                                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry triple shot hit! Captured ${targetPiece.type} (+${captureValue} points)`);

                                    if (targetPiece.type === 'Champion') {
                                        championCaptured[targetPiece.player] = true;
                                    }
                                    if (targetPiece.type === 'King') {
                                        endGame(currentPlayer);
                                        return;
                                    }
                                    board[targetRow][targetCol] = null;
                                    updateCapturedPiecesDisplay();
                                    updateScoreDisplay();
                                    checkSupremacy(currentPlayer);
                                }
                            } else {
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry triple shot missed at (${targetRow},${targetCol}).`);
                            }

                            // Decrement shots remaining (whether hit or miss)
                            elephantryExtendedRangeShotsRemaining[pieceKey]--;

                            // Update display
                            updateGameLog();
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();

                            // If shots remain in this Triple Shot usage, keep the mode active
                            if (elephantryExtendedRangeShotsRemaining[pieceKey] > 0) {
                                validMoves = getElephantryExtendedRangeMoves(elephantryRow, elephantryCol);
                                if (!validMoves.length) {
                                    elephantryExtendedRangeActive = false;
                                    selectedPiece = null;
                                    showPieceInfo(null);
                                    renderBoard();
                                    gameLog.push('No remaining targets for Elephantry Triple Shot.');
                                    updateGameLog();
                                } else {
                                    renderBoard();
                                }
                            } else {
                                // All 3 shots used, end the Triple Shot mode
                                elephantryExtendedRangeActive = false;
                                selectedPiece = null;
                                validMoves = [];
                                showPieceInfo(null);
                                renderBoard();
                            }

                            checkGameOver();
                            if (movesLeft === 0 && !reinforcementPending) {
                                triggerAiTurn();
                            }
                        },
                        false, // automated
                        false  // showOverlay
                    );
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Huntsman burst destination selection
            if (huntsmanBurstMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'huntsmanBurst');
                if (move) {
                    const context = huntsmanBurstMode;
                    const fromRow = context.row;
                    const fromCol = context.col;
                    movePiece(fromRow, fromCol, row, col, move.jump);
                    lastAction = { move: true };
                    movedPieces.add(`${row},${col}`);
                    huntsmanBurstMode = null;
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    resumeGameAfterHuntsmanBurst();
                    if (context && typeof context.onComplete === 'function') {
                        context.onComplete();
                    }
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
                return;
            }

            // Handle Champion summon targeting
            if (championSummonMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'championSummon');
                if (move) {
                    const summonType = move.summonType;
                    const source = championSummonMode.source || selectedPiece;
                    const fromRow = source.row;
                    const fromCol = source.col;
                    const champion = board[fromRow]?.[fromCol];
                    championSummonMode = null;
                    if (!champion || champion.type !== 'Champion' || champion.player !== currentPlayer) {
                        validMoves = [];
                        selectedPiece = null;
                        renderBoard();
                        return;
                    }
                    const championOwner = champion.player;
                    movesLeft = Math.max(0, movesLeft - move.cost);
                    updateStatus();
                    updateEndTurnButton();
                    const targetRow = move.pos[0];
                    const targetCol = move.pos[1];
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    const playerLabel = championOwner === 'W' ? 'Player' : getOpponentDisplayName();
                    const attemptLabel = summonType === 'Huntsman' ? 'Summon Huntsman' : 'Summon Necromancer';
                    const attemptMessage = `${playerLabel} attempts to summon a ${summonType}...`;
                    performCoinToss(
                        attemptLabel,
                        attemptMessage,
                        (success) => {
                            if (success) {
                                if (!board[targetRow][targetCol]) {
                                    if (summonType === 'Huntsman') {
                                        board[targetRow][targetCol] = { type: 'Huntsman', player: championOwner };
                                        recordHuntsmanSpawn(championOwner);
                                    } else {
                                        const necromancerPiece = { type: 'Necromancer', player: championOwner, facing: null };
                                        board[targetRow][targetCol] = necromancerPiece;
                                        necromancersSummoned[championOwner] = (necromancersSummoned[championOwner] || 0) + 1;
                                        necromancerTeleportCounts.set(necromancerPiece, 0);
                                        setNecromancerShotCooldown(necromancerPiece, 0);
                                    }
                                    gameStats.summonCount[championOwner]++;
                                    gameLog.push(`${playerLabel} summoned a ${summonType} at (${targetRow},${targetCol}).`);
                                } else {
                                    gameLog.push(`${playerLabel}'s ${summonType} summon succeeded but the chosen square was occupied.`);
                                }
                            } else {
                                gameLog.push(`${playerLabel} failed to summon a ${summonType}.`);
                            }
                            lastAction = { move: true };
                            movedPieces.add(`${fromRow},${fromCol}`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            checkGameOver();
                            if (movesLeft === 0 && !reinforcementPending) {
                                triggerAiTurn();
                            }
            },
            false,
            false
        );
                }
                return;
            }

            // Handle Necromancer summon targeting
            if (necromancerSummonMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'necromancerSummon');
                if (move) {
                    const summonType = move.summonType;
                    const source = necromancerSummonMode.source || selectedPiece;
                    const fromRow = source.row;
                    const fromCol = source.col;
                    const necromancer = board[fromRow]?.[fromCol];
                    necromancerSummonMode = null;
                    if (!necromancer || necromancer.type !== 'Necromancer' || necromancer.player !== currentPlayer) {
                        validMoves = [];
                        selectedPiece = null;
                        renderBoard();
                        return;
                    }
                    movesLeft = Math.max(0, movesLeft - move.cost);
                    updateStatus();
                    updateEndTurnButton();
                    const targetRow = move.pos[0];
                    const targetCol = move.pos[1];
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    const playerLabel = currentPlayer === 'W' ? 'Player' : getOpponentDisplayName();
                    const label = summonType === 'spectre' ? 'Spectre' : 'Zombie';
                    performCoinToss(
                        `Summon ${label}`,
                        `${playerLabel} attempts to summon a ${label}...`,
                        (success) => {
                            if (success) {
                                if (!board[targetRow][targetCol]) {
                                    if (summonType === 'spectre') {
                                        board[targetRow][targetCol] = { type: 'Spectre', player: currentPlayer };
                                        spectresSummoned[currentPlayer]++;
                                    } else {
                                        const zombiePiece = createZombiePiece(currentPlayer);
                                        board[targetRow][targetCol] = zombiePiece;
                                        zombiesSummoned[currentPlayer] = (zombiesSummoned[currentPlayer] || 0) + 1;
                                    }
                                    gameStats.summonCount[currentPlayer]++;
                                    gameLog.push(`${playerLabel} summoned a ${label} at (${targetRow},${targetCol}).`);
                                } else {
                                    gameLog.push(`${playerLabel}'s ${label} summon succeeded but the chosen square was occupied.`);
                                }
                            } else {
                                gameLog.push(`${playerLabel} failed to summon a ${label}.`);
                            }
                            lastAction = { move: true };
                            movedPieces.add(`${fromRow},${fromCol}`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            checkGameOver();
                            if (movesLeft === 0 && !reinforcementPending) {
                                triggerAiTurn();
                            }
                        },
                        false,
                        false
                    );
                }
                return;
            }

            if (!selectedPiece && piece && piece.player === 'W' && !movedPieces.has(`${row},${col}`)) {
                // During mercenary bonus turn, only allow selecting the specific mercenary
                if (mercenaryBonusTurnActive &&
                    (row !== mercenaryBonusTurnPiece.row || col !== mercenaryBonusTurnPiece.col)) {
                    // Clicked on wrong piece during mercenary bonus turn
                    return;
                }
                selectedPiece = { row, col };
                validMoves = getValidMoves(row, col);
                showPieceInfo(piece, piece.player);
                lastAction = null;
                renderBoard();
                updateEndTurnButton();
            } else if (selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col);
                if (move && movesLeft >= move.cost) {
                    if (move.type === 'move') {
                        // Handle Pistolier capturing by landing - requires coin flip
                        if (move.special === 'pistolierCapture') {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const toRow = row;
                            const toCol = col;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            // Trigger coin toss for capture
                            performCoinToss(
                                'Pistolier Capture',
                                `Attempting to capture at (${toRow},${toCol})...`,
                                (success) => {
                                    if (success) {
                                        // Successfully captured
                                        movePiece(fromRow, fromCol, toRow, toCol, null);
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier successfully captured by landing!`);
                                    } else {
                                        // Failed to capture - still move but don't capture
                                        const targetPiece = board[toRow][toCol];
                                        board[toRow][toCol] = board[fromRow][fromCol];
                                        board[fromRow][fromCol] = null;
                                        // Piece stays in place, no capture
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier failed to capture - move blocked.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    movedPieces.add(`${toRow},${toCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        }

                        // Handle Pistolier move+shoot combination - enter shoot selection mode
                        if (move.special === 'pistolierMoveShoot') {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            // Move to the position first
                            movePiece(fromRow, fromCol, row, col, null);
                            movesLeft -= move.cost;
                            movedPieces.add(`${fromRow},${fromCol}`);
                            movedPieces.add(`${row},${col}`);
                            lastAction = { move: true };

                            // Enter shoot selection mode
                            pistolierMoveShootMode = true;
                            pistolierMoveShootPosition = { row, col };
                            selectedPiece = { row, col };

                            // Generate shoot targets from new position (1 square diagonal only)
                            validMoves = [];
                            for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = row + d[0], shootC = col + d[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== currentPlayer) {
                                    validMoves.push({ type: 'shoot', pos: [shootR, shootC], cost: 0, special: 'pistolierMoveShootFinal' });
                                }
                            }
                            validMoves = filterShootMovesForPlayer(validMoves, currentPlayer);
                            if (!validMoves.length) {
                                pistolierMoveShootMode = false;
                                pistolierMoveShootPosition = null;
                                selectedPiece = null;
                                showPieceInfo(null);
                                renderBoard();
                                updateStatus();
                                updateEndTurnButton();
                                gameLog.push('No valid pistolier targets after moving.');
                                updateGameLog();
                                return;
                            }

                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier moved to (${row},${col}), select shoot target...`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            return;
                        }

                        // Handle Elephantry move+shoot combination - enter shoot selection mode
                        if (move.special === 'elephantryMoveShoot') {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            // Move to the position first
                            movePiece(fromRow, fromCol, row, col, null);
                            movesLeft -= move.cost;
                            movedPieces.add(`${fromRow},${fromCol}`);
                            movedPieces.add(`${row},${col}`);
                            lastAction = { move: true };

                            // Enter shoot selection mode
                            elephantryMoveShootMode = true;
                            elephantryMoveShootPosition = { row, col };
                            selectedPiece = { row, col };

                            // Generate shoot targets from new position
                            validMoves = [];
                            for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = row + d[0], shootC = col + d[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== currentPlayer) {
                                    validMoves.push({ type: 'shoot', pos: [shootR, shootC], cost: 0, special: 'elephantryMoveShootFinal' });
                                }
                            }
                            validMoves = filterShootMovesForPlayer(validMoves, currentPlayer);
                            if (!validMoves.length) {
                                elephantryMoveShootMode = false;
                                elephantryMoveShootPosition = null;
                                selectedPiece = null;
                                showPieceInfo(null);
                                renderBoard();
                                updateStatus();
                                updateEndTurnButton();
                                gameLog.push('No valid elephantry targets after moving.');
                                updateGameLog();
                                return;
                            }

                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry moved to (${row},${col}), select shoot target...`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            return;
                        }

                        // Check if capturing a Spectre - requires coin toss (except for Wizards/Spectres)
                        const targetPiece = board[row][col];
                        const attackingPiece = board[selectedPiece.row][selectedPiece.col];
                        const isCapturingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                        const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';

                        if (isCapturingSpectre && !captureExempt) {
                            // Store move info for callback
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const toRow = row;
                            const toCol = col;
                            const jump = move.jump;
                            const special = move.special;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            // Trigger coin toss
                            performCoinToss(
                                'Capture Spectre',
                                'Attempting to capture the Spectre...',
                                (success) => {
                                    let moveResult = null;
                                    if (success) {
                                        // Successfully captured Spectre
                                        moveResult = movePiece(fromRow, fromCol, toRow, toCol, jump);
                                        if (special === 'charge') {
                                            cavalryChargeUsed[currentPlayer] = true;
                                        }
                                        if (special === 'ballistaDoubleTime') {
                                            ballistaDoubleTimeUsed[currentPlayer]++;
                                        }
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} successfully captured the Spectre!`);
                                    } else {
                                        // Failed to capture Spectre - move not executed
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} failed to capture the Spectre.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);

                                    // Check if mercenary coin flip is needed
                                    if (success && moveResult?.mercenaryFlipNeeded) {
                                        const mercPiece = moveResult.mercenaryPiece;
                                        const mercPos = moveResult.mercenaryPos;

                                        handleMercenaryCoinFlip(mercPiece.player, mercPiece, mercPos.row, mercPos.col, (bonusTurnGranted) => {
                                            selectedPiece = null;
                                            validMoves = [];
                                            showPieceInfo(null);
                                            renderBoard();
                                            updateStatus();
                                            updateEndTurnButton();
                                            updateGameLog();
                                            checkGameOver();

                                            if (bonusTurnGranted) {
                                                return; // Player continues their turn
                                            }

                                            if (mercenaryBonusTurnActive) {
                                                mercenaryBonusTurnActive = false;
                                                mercenaryBonusTurnPiece = null;
                                            }
                                            if (movesLeft === 0 && !reinforcementPending) {
                                                triggerAiTurn();
                                            }
                                        });
                                        return;
                                    }

                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();

                                    // If we were in mercenary bonus turn mode and didn't get another bonus turn, clear the state
                                    if (mercenaryBonusTurnActive) {
                                        mercenaryBonusTurnActive = false;
                                        mercenaryBonusTurnPiece = null;
                                    }
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        } else {
                            // Normal move/capture
                            const moveResult = movePiece(selectedPiece.row, selectedPiece.col, row, col, move.jump);
                            if (move.special === 'charge') {
                                cavalryChargeUsed[currentPlayer] = true;
                            }
                            if (move.special === 'ballistaDoubleTime') {
                                if (board[row][col]?.type === 'Ballista') {
                                    // after moving, board[row][col] is the piece moved
                                }
                                ballistaDoubleTimeUsed[currentPlayer]++;
                            }

                            // Check if mercenary coin flip is needed
                            if (moveResult?.mercenaryFlipNeeded) {
                                const mercPiece = moveResult.mercenaryPiece;
                                const mercPos = moveResult.mercenaryPos;

                                // Show blocking coin flip modal
                                handleMercenaryCoinFlip(mercPiece.player, mercPiece, mercPos.row, mercPos.col, (bonusTurnGranted) => {
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    checkGameOver();

                                    if (bonusTurnGranted) {
                                        return; // Player continues their turn
                                    }

                                    // If we were in mercenary bonus turn mode and didn't get another bonus turn, clear the state
                                    if (mercenaryBonusTurnActive) {
                                        mercenaryBonusTurnActive = false;
                                        mercenaryBonusTurnPiece = null;
                                    }
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                });
                                return; // Exit to wait for coin flip callback
                            }

                            // If we were in mercenary bonus turn mode and didn't get another bonus turn, clear the state
                            if (mercenaryBonusTurnActive) {
                                mercenaryBonusTurnActive = false;
                                mercenaryBonusTurnPiece = null;
                            }
                        }
                    } else if (move.type === 'shoot') {
                        // Check if shooting a Spectre - requires coin toss (except for Wizards/Spectres)
                        const targetPiece = board[row][col];
                        const attackingPiece = board[selectedPiece.row][selectedPiece.col];
                        const isShootingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                        const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';
                        const autoCrackShot = move.special === 'fusilierCrackShotAuto';
                        const usingCrackShot = attackingPiece && attackingPiece.type === 'Fusilier' && fusilierCrackShotActive === attackingPiece;
                        const isNecromancerShot = attackingPiece && attackingPiece.type === 'Necromancer' && move.special === 'necromancerShoot';

                        if (isShootingSpectre && !captureExempt) {
                            gameLog.push('Spectres are immune to standard shooting attacks.');
                            updateGameLog();
                            return;
                        } else if (autoCrackShot) {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const pieceKey = `${fromRow},${fromCol},${currentPlayer}`;

                            movesLeft -= move.cost;

                            if (!(pieceKey in fusilierCrackShotCount)) {
                                fusilierCrackShotCount[pieceKey] = 3;
                            }
                            if (fusilierCrackShotCount[pieceKey] > 0) {
                                fusilierCrackShotCount[pieceKey]--;
                            }

                            performCoinToss(
                                'Crack Shot',
                                'Attempting Crack Shot...',
                                (success) => {
                                    fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                    fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);

                                    if (success) {
                                        shootPiece(fromRow, fromCol, row, col);
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot hit!`);
                                    } else {
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot missed.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        } else if (usingCrackShot) {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            performCoinToss(
                                'Crack Shot',
                                'Attempting Crack Shot...',
                                (success) => {
                                    // Mark the shot attempt for cooldown regardless of outcome
                                    fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                    fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);

                                    fusilierCrackShotActive = null;

                                    if (success) {
                                        shootPiece(fromRow, fromCol, row, col);
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot hit!`);
                                    } else {
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot missed.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        } else {
                            // Normal shoot
                            shootPiece(selectedPiece.row, selectedPiece.col, row, col);
                            if (move.special === 'archerDiag2') {
                                archerDiag2ShootUsed[currentPlayer]++;
                            }
                            if (isNecromancerShot) {
                                setNecromancerShotCooldown(attackingPiece, 2);
                            }
                        }
                    } else if (move.type === 'swap') {
                        const guardRow = move.pos[0];
                        const guardCol = move.pos[1];
                        const guard = board[guardRow][guardCol];
                        board[guardRow][guardCol] = board[selectedPiece.row][selectedPiece.col];
                        board[selectedPiece.row][selectedPiece.col] = guard;
                        kingSpecialUsed[currentPlayer] = true;
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Guard of Honour to swap King and Guard at (${selectedPiece.row},${selectedPiece.col}) and (${guardRow},${guardCol})`);
                        checkSupremacy(currentPlayer);
                        movedPieces.add(`${guardRow},${guardCol}`);
                        movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    } else if (move.type === 'teleport') {
                        const teleportPiece = board[selectedPiece.row][selectedPiece.col];
                        const abilityLabel = `${teleportPiece.type} Teleport`;
                        const result = teleportOntoSquare(selectedPiece.row, selectedPiece.col, move.pos[0], move.pos[1], currentPlayer, abilityLabel);
                        if (!result.success) {
                            cancelSpecialModes({ resetSelection: false });
                            return;
                        }
                        if (teleportPiece.type === 'Wizard') {
                            wizardTeleportUsed[currentPlayer]++;
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Wizard from (${selectedPiece.row},${selectedPiece.col}) to (${move.pos[0]},${move.pos[1]})`);
                        } else if (teleportPiece.type === 'Necromancer') {
                            incrementNecromancerTeleportCount(teleportPiece);
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Necromancer from (${selectedPiece.row},${selectedPiece.col}) to (${move.pos[0]},${move.pos[1]})`);
                        } else {
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported ${teleportPiece.type} from (${selectedPiece.row},${selectedPiece.col}) to (${move.pos[0]},${move.pos[1]})`);
                        }
                        movedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                    } else if (move.type === 'teleportSwap') {
                        const opponentWizardRow = row;
                        const opponentWizardCol = col;
                        const playerWizard = board[selectedPiece.row][selectedPiece.col];
                        const opponentWizard = board[opponentWizardRow][opponentWizardCol];
                        board[opponentWizardRow][opponentWizardCol] = playerWizard;
                        board[selectedPiece.row][selectedPiece.col] = opponentWizard;
                        wizardTeleportSwapUsed[currentPlayer] = true;
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Teleport Swap to swap Wizard at (${selectedPiece.row},${selectedPiece.col}) with opponent's Wizard at (${opponentWizardRow},${opponentWizardCol})`);
                        movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                        movedPieces.add(`${opponentWizardRow},${opponentWizardCol}`);
                    }
                    // Only deduct move cost if not in mercenary bonus turn mode
                    if (!mercenaryBonusTurnActive) {
                        movesLeft -= move.cost;
                    }
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    if (move.type === 'move' || move.type === 'teleport') {
                        movedPieces.add(`${row},${col}`);
                    }
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    // Clear mercenary bonus turn state after move completes
                    if (mercenaryBonusTurnActive) {
                        mercenaryBonusTurnActive = false;
                        mercenaryBonusTurnPiece = null;
                    }
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes();
                }
            }
        }

        function openTurnModal() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (turnablePieces.includes(piece.type) && movesLeft >= turnCosts[piece.type]) {
                const validDirections = getValidTurnDirections(piece.facing);
                const select = document.getElementById('turn-select');
                select.innerHTML = validDirections.map(dir => `<option value="${dir}">${dir} (${facingIcons[dir]})</option>`).join('');
                document.getElementById('turn-modal').style.display = 'block';
            }
        }

        function activateBallistaRange() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || ballistaRangeBoostUsedThisTurn[currentPlayer]) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Ballista') {
                ballistaRangeBoostActive[currentPlayer] = true;
                ballistaRangeBoostUsedThisTurn[currentPlayer] = true;
                movesLeft -= 2;
                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} activated Ballista Extend Range (+1 range this round)`);
                // Keep the piece selected and recalculate valid moves with extended range
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                checkGameOver();
                if (movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                }
            }
        }

        function getBallistaDoubleTimeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            let moves = [];
            for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                const r1 = row + d[0], c1 = col + d[1];
                const r2 = row + d[0]*2, c2 = col + d[1]*2;
                if (!isValid(r1, c1) || board[r1][c1]) continue; // path blocked on first
                if (isValid(r2, c2) && !board[r2][c2]) {
                    // Ballista can only move to empty squares - cannot capture by landing
                    moves.push({ type: 'move', pos: [r2, c2], cost: 2, special: 'ballistaDoubleTime' });
                }
            }
            return moves;
        }

        function activateBallistaDoubleTime() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || ballistaDoubleTimeUsed[currentPlayer] >= 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Ballista') {
                const options = getBallistaDoubleTimeMoves(selectedPiece.row, selectedPiece.col);
                validMoves = options;
                renderBoard();
            }
        }
        function activateArcherMoveDiagShoot() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (archerMoveDiagMode || archerDiagShootSelectMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Archer' && archerMoveDiagShootUsed[currentPlayer] < 2) {
                archerMoveDiagMode = true;
                archerMoveDiagStart = { row: selectedPiece.row, col: selectedPiece.col };
                // Only allow the Archer's basic 1-square orthogonal moves for the first step
                const moves = pieceTypes['Archer'].move(selectedPiece.row, selectedPiece.col, board, currentPlayer, null, piece.facing) || [];
                validMoves = moves.filter(m => m.type === 'move' && m.cost === 1);
                renderBoard();
            }
        }

        function activateArcherDiag2Shoot() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (archerDiag2ShootMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Archer' && archerDiag2ShootUsed[currentPlayer] < 2) {
                archerDiag2ShootMode = true;
                // Compute diagonal 2-square shoot targets
                const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                const row = selectedPiece.row, col = selectedPiece.col;
                let options = [];
                for (let d of dirs) {
                    const nr = row + d[0]*2, nc = col + d[1]*2;
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== currentPlayer) {
                        options.push({ type: 'shoot', pos: [nr, nc], cost: 2, special: 'archerDiag2' });
                    }
                }
                options = filterShootMovesForPlayer(options, currentPlayer);
                if (!options.length) {
                    archerDiag2ShootMode = false;
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    gameLog.push('No valid targets for Archer diagonal double shot.');
                    updateGameLog();
                    return;
                }
                validMoves = options;
                renderBoard();
            }
        }

        function activateStrafe() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (strafeMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            const usedCount = piece.type === 'Wizard' ? wizardStrafeUsed[currentPlayer] : dragonStrafeUsed[currentPlayer];

            if ((piece.type === 'Wizard' || piece.type === 'Dragon') && usedCount < 2) {
                strafeMode = true;
                // Compute orthogonal 1-square moves to empty squares only
                const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                const row = selectedPiece.row, col = selectedPiece.col;
                let options = [];
                for (let d of dirs) {
                    const nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        options.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'strafe' });
                    }
                }
                validMoves = options;
                renderBoard();
            }
        }

        function activateSummonSpectre() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (summonSpectreMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            const totalCaptured = capturedPieces['W'].length + capturedPieces['B'].length;

            if (piece.type === 'Wizard' && spectresSummoned[currentPlayer] < 2 && !wizardSummonedThisTurn[currentPlayer] && totalCaptured >= 5) {
                summonSpectreMode = true;
                // Compute adjacent squares (8 directions) for Spectre placement
                const dirs = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                const row = selectedPiece.row, col = selectedPiece.col;
                let options = [];
                for (let d of dirs) {
                    const nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        options.push({ type: 'summon', pos: [nr, nc], cost: 2, special: 'summonSpectre' });
                    }
                }
                validMoves = options;
                renderBoard();
            }
        }

        function activateChampionSummon(type) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (championSummonMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            if (isAnySpecialModeActive()) {
                cancelSpecialModes({ resetSelection: false });
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || piece.type !== 'Champion' || (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme')) return;
            if (type === 'Necromancer') {
                if (!canChampionSummonNecromancer(currentPlayer)) {
                    gameLog.push('No Necromancer summons remaining.');
                    updateGameLog();
                    return;
                }
            } else if (type === 'Huntsman') {
                if (!canChampionSummonHuntsman(currentPlayer)) {
                    gameLog.push('No Huntsman summons remaining.');
                    updateGameLog();
                    return;
                }
            } else {
                return;
            }
            if (!hasBackRowSpawnSlot(currentPlayer)) {
                gameLog.push('No open squares on the back row to summon a unit.');
                updateGameLog();
                return;
            }
            const backRow = currentPlayer === 'W' ? ROWS - 1 : 0;
            const options = [];
            for (let c = 0; c < COLS; c++) {
                if (!board[backRow][c]) {
                    options.push({ type: 'summon', pos: [backRow, c], cost: 2, special: 'championSummon', summonType: type });
                }
            }
            if (!options.length) {
                gameLog.push('No open squares on the back row to summon a unit.');
                updateGameLog();
                return;
            }
            championSummonMode = { type, source: { row: selectedPiece.row, col: selectedPiece.col } };
            validMoves = options;
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            gameLog.push(`Select a back row square to summon a ${type}.`);
            updateGameLog();
        }

        function activateNecromancerSummon(type) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (necromancerSummonMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            if (isAnySpecialModeActive()) {
                cancelSpecialModes({ resetSelection: false });
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || piece.type !== 'Necromancer' || (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme')) return;
            const isZombieSummon = type === 'zombie';
            const isSpectreSummon = type === 'spectre';
            if (!isZombieSummon && !isSpectreSummon) return;
            if (isZombieSummon) {
                const maxZombies = getMaxZombies(currentPlayer);
                if ((zombiesSummoned[currentPlayer] || 0) >= maxZombies) {
                    gameLog.push('Zombie limit reached. Cannot summon more.');
                    updateGameLog();
                    return;
                }
            } else if (spectresSummoned[currentPlayer] >= 2) {
                gameLog.push('Spectre limit reached. Cannot summon more.');
                updateGameLog();
                return;
            }
            let options = [];
            if (isSpectreSummon) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const nr = selectedPiece.row + dr;
                        const nc = selectedPiece.col + dc;
                        if (!isValid(nr, nc)) continue;
                        if (!board[nr][nc]) {
                            options.push({ type: 'summon', pos: [nr, nc], cost: 2, special: 'necromancerSummon', summonType: type });
                        }
                    }
                }
                if (!options.length) {
                    gameLog.push('No adjacent squares available next to the Necromancer to summon a Spectre.');
                    updateGameLog();
                    return;
                }
            } else {
                if (!hasBackRowSpawnSlot(currentPlayer)) {
                    gameLog.push('No open squares on the back row to place a summon.');
                    updateGameLog();
                    return;
                }
                const backRow = currentPlayer === 'W' ? ROWS - 1 : 0;
                for (let c = 0; c < COLS; c++) {
                    if (!board[backRow][c]) {
                        options.push({ type: 'summon', pos: [backRow, c], cost: 2, special: 'necromancerSummon', summonType: type });
                    }
                }
                if (!options.length) {
                    gameLog.push('No open squares on the back row to place a summon.');
                    updateGameLog();
                    return;
                }
            }
            necromancerSummonMode = { type, source: { row: selectedPiece.row, col: selectedPiece.col } };
            validMoves = options;
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            const label = type === 'spectre' ? 'Spectre' : 'Zombie';
            const placementLabel = isSpectreSummon ? 'an adjacent square' : 'a back row square';
            gameLog.push(`Select ${placementLabel} to summon a ${label}.`);
            updateGameLog();
        }

        function confirmTurn() {
            if (!selectedPiece) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const newFacing = document.getElementById('turn-select').value;
            turnPiece(selectedPiece.row, selectedPiece.col, newFacing);
            document.getElementById('turn-modal').style.display = 'none';
            movesLeft -= turnCosts[piece.type];
            movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
            selectedPiece = null;
            validMoves = [];
            showPieceInfo(null);
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
            checkGameOver();
            if (movesLeft === 0 && !reinforcementPending) {
                triggerAiTurn();
            }
        }

        function openTurnAndMoveModal() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Infantry' && movesLeft >= 2) {
                const validDirections = getValidTurnDirections(piece.facing);
                const select = document.getElementById('turn-move-select');
                select.innerHTML = validDirections.map(dir => `<option value="${dir}">${dir} (${facingIcons[dir]})</option>`).join('');
                document.getElementById('turn-move-modal').style.display = 'block';
            }
        }

        function confirmTurnAndMove() {
            if (!selectedPiece) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const newFacing = document.getElementById('turn-move-select').value;
            turnPiece(selectedPiece.row, selectedPiece.col, newFacing);
            document.getElementById('turn-move-modal').style.display = 'none';
            movesLeft -= 1;
            lastAction = { turn: true };
            turnAndMoveMode = true;
            validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
        }

        function closeTurnModal() {
            const modal = document.getElementById('turn-modal');
            if (modal) modal.style.display = 'none';
        }

        function openKingSummonModal() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'King' && (gameVariant === '36s-expert' || gameVariant === '36s-elite' || gameVariant === '36s-supreme')) {
                if (!hasBackRowSpawnSlot(currentPlayer)) {
                    gameLog.push('No open squares on the back row to summon a unit.');
                    updateGameLog();
                    return;
                }
                const select = document.getElementById('king-summon-select');
                select.innerHTML = '';

                // Add available summon options
                if (pistoliersSummoned[currentPlayer] < 2) {
                    const option = document.createElement('option');
                    option.value = 'Pistolier';
                    option.textContent = `Pistolier (${pistoliersSummoned[currentPlayer]}/2 summoned)`;
                    select.appendChild(option);
                }
                if (fusiliersSummoned[currentPlayer] < 2) {
                    const option = document.createElement('option');
                    option.value = 'Fusilier';
                    option.textContent = `Fusilier (${fusiliersSummoned[currentPlayer]}/2 summoned)`;
                    select.appendChild(option);
                }

                if (select.options.length > 0) {
                    document.getElementById('king-summon-modal').style.display = 'block';
                }
            }
        }

        function closeKingSummonModal() {
            const modal = document.getElementById('king-summon-modal');
            if (modal) modal.style.display = 'none';
        }

        function confirmKingSummon() {
            if (!selectedPiece || currentPlayer !== 'W') return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type !== 'King') return;

            const select = document.getElementById('king-summon-select');
            const unitType = select.value;

            if (!unitType) return;

            // Close modal
            closeKingSummonModal();

            // Deduct points immediately
            movesLeft -= 2;

            // Perform coin toss for summon
            performCoinToss(
                'Summon Unit',
                `Attempting to summon ${unitType}...`,
                (success) => {
                    if (success) {
                        // Find empty square in back row
                        const backRow = currentPlayer === 'W' ? ROWS - 1 : 0;
                        let emptySquares = [];
                        for (let c = 0; c < COLS; c++) {
                            if (!board[backRow][c]) {
                                emptySquares.push(c);
                            }
                        }

                        if (emptySquares.length > 0) {
                            // Place unit in first available empty square
                            const col = emptySquares[0];
                            const facing = currentPlayer === 'W' ? 'U' : 'D';
                            board[backRow][col] = { type: unitType, player: currentPlayer, facing: facing };

                            // Update summon counter
                            if (unitType === 'Pistolier') {
                                pistoliersSummoned[currentPlayer]++;
                            } else if (unitType === 'Fusilier') {
                                fusiliersSummoned[currentPlayer]++;
                            }

                            gameStats.summonCount[currentPlayer]++; // Track summon for statistics
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} successfully summoned ${unitType} at (${backRow},${col})!`);
                        } else {
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} succeeded summon but no empty squares in back row!`);
                        }
                    } else {
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} failed to summon ${unitType}.`);
                    }

                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                },
                false, // automated
                false  // showOverlay
            );
        }

        /* Legacy necromancer summon modal functions removed in favor of highlight-based placement */

        function closeTurnMoveModal() {
            const modal = document.getElementById('turn-move-modal');
            if (modal) modal.style.display = 'none';
            cancelSpecialModes({ resetSelection: false });
        }

        function closeTurnShootModal() {
            const modal = document.getElementById('turn-shoot-modal');
            if (modal) modal.style.display = 'none';
            cancelSpecialModes({ resetSelection: false });
        }

        function openTurnAndShootModal() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Archer' && movesLeft >= 2) {
                const validDirections = getValidTurnDirections(piece.facing);
                const select = document.getElementById('turn-shoot-select');
                select.innerHTML = validDirections.map(dir => `<option value="${dir}">${dir} (${facingIcons[dir]})</option>`).join('');
                document.getElementById('turn-shoot-modal').style.display = 'block';
            }
        }

        function confirmTurnAndShoot() {
            if (!selectedPiece) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const newFacing = document.getElementById('turn-shoot-select').value;
            turnPiece(selectedPiece.row, selectedPiece.col, newFacing);
            document.getElementById('turn-shoot-modal').style.display = 'none';
            // Spend 1 for the turn now; the shot will spend the 2nd point
            movesLeft -= 1;
            lastAction = { turn: true };
            turnAndShootMode = true;
            // Limit valid moves to only shooting options after the turn
            validMoves = getValidMoves(selectedPiece.row, selectedPiece.col).filter(m => m.type === 'shoot');
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
        }

        function getValidMoves(row, col) {
            const piece = board[row][col];
            if (!piece || movedPieces.has(`${row},${col}`)) return [];

            // Check if wizard is restricted from moving this turn
            if (piece.type === 'Wizard' && wizardCannotMoveNextTurn[piece.player].has(`${row},${col}`)) {
                return [];
            }

            const type = piece.type;
            const player = piece.player;
            let valid = [];
            
            // Handle Inferno Mode
            if (type === 'Dragon' && infernoMode && !dragonInfernoUsed[player] && movesLeft >= 2) {
                const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                for (let d of directions) {
                    let nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && (!board[nr][nc] || board[nr][nc].player !== player)) {
                        valid.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'inferno' });
                    }
                }
                return valid; // Return *only* inferno moves
            }

            // Standard Moves
            const isFirstMove = firstMoves.has(`${row},${col},${player}`);
            let moves = pieceTypes[type].move(row, col, board, player, isFirstMove, piece.facing, movesLeft);
            
            for (let move of moves) {
                if (move.type === 'move') {
                    const [r, c] = move.pos;
                    if (!board[r][c] || board[r][c].player !== player) {
                        if (type !== 'King' || !isCheckAfterMove(row, col, r, c, player)) {
                            if (movesLeft >= move.cost) {
                                valid.push(move);
                            }
                        }
                    }
                } else if (move.type === 'shoot') {
                    const targetPiece = board[move.pos[0]]?.[move.pos[1]];
                    if (targetPiece && targetPiece.player !== player && targetPiece.type === 'Spectre') {
                        continue;
                    }
                    if (movesLeft >= move.cost) {
                        valid.push(move);
                    }
                }
            }

            // Special Moves
            if (type === 'King' && !kingSpecialUsed[player] && movesLeft >= 2) {
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].type === 'Guard' && board[nr][nc].player === player) {
                        valid.push({ type: 'swap', pos: [nr, nc], cost: 2 });
                    }
                }
            }
            if (type === 'Wizard' && wizardTeleportUsed[player] < 2 && movesLeft >= 2) {
                const currentColor = (row + col) % 2;
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if ((r + c) % 2 === currentColor && (r !== row || c !== col)) {
                            const occupant = board[r][c];
                            if (occupant && (occupant.player === player || occupant.type !== 'Spectre')) continue;
                            valid.push({ type: 'teleport', pos: [r, c], cost: 2 });
                        }
                    }
                }
            }
            if (type === 'Necromancer' && (gameVariant === '36s-elite' || gameVariant === '36s-supreme') && movesLeft >= 2) {
                const pieceObj = piece;
                if (getNecromancerTeleportCount(pieceObj) < 2) {
                    for (let r = 0; r < ROWS; r++) {
                        for (let c = 0; c < COLS; c++) {
                            if (r === row && c === col) continue;
                            const occupant = board[r][c];
                            if (occupant && (occupant.player === player || occupant.type !== 'Spectre')) continue;
                            valid.push({ type: 'teleport', pos: [r, c], cost: 2 });
                        }
                    }
                }
            }
            if (type === 'Wizard' && !wizardTeleportSwapUsed[player] && movesLeft >= 2 && opponentHasWizards(player)) {
                const color = (row + col) % 2;
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (board[r][c] && board[r][c].type === 'Wizard' && board[r][c].player !== player && (r + c) % 2 === color) {
                            valid.push({ type: 'teleportSwap', pos: [r, c], cost: 2 });
                        }
                    }
                }
            }
            if (type === 'Cavalry' && !cavalryChargeUsed[player] && movesLeft >= 2) {
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let r = row, c = col;
                    while (true) {
                        r += d[0];
                        c += d[1];
                        if (!isValid(r, c)) break;
                        if (board[r][c]) {
                            if (board[r][c].player !== player) {
                                valid.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                            }
                            break;
                        }
                        valid.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                    }
                }
            }
            if (type === 'Archer' && movesLeft >= 2 && archerDiag2ShootUsed[player] < 2) {
                // Add diagonal 2-square shot (no movement)
                const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                for (let d of dirs) {
                    const nr = row + d[0]*2, nc = col + d[1]*2;
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== player) {
                        valid.push({ type: 'shoot', pos: [nr, nc], cost: 2, special: 'archerDiag2' });
                    }
                }
            }
            if (type === 'Ballista') {
                if (!ballistaRangeBoostUsedThisTurn[player] && movesLeft >= 2) {
                    valid.push({ type: 'activate', pos: [row, col], cost: 2, special: 'ballistaRange' });
                }
                if (ballistaDoubleTimeUsed[player] < 2 && movesLeft >= 2) {
                    valid.push(...getBallistaDoubleTimeMoves(row, col));
                }
            }
            // Note: Dragon Inferno is *not* added here because it's activated by a button, not as a passive option.
            // The logic above handles showing Inferno moves *only when infernoMode is true*.
            
            return valid;
        }

        // New function to execute the Inferno AOE capture
        function performInfernoCapture(row, col, player) {
            const opponent = player === 'W' ? 'B' : 'W';
            const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
            let capturedSomething = false;

            for (let d of directions) {
                let nr = row + d[0], nc = col + d[1];
                if (isValid(nr, nc)) {
                    const targetPiece = board[nr][nc];
                    // Dragons cannot capture other Dragons with Inferno
                    if (targetPiece && targetPiece.player === opponent && targetPiece.type !== 'Dragon') {
                        capturedSomething = true;
                        capturedSquares.push([nr, nc]);
                        capturedPieces[player].push(targetPiece);
                        const captureValue = pieceValues[targetPiece.type];
                        scores[player] += captureValue;
                        registerScoreGain(player, captureValue);
                        registerPieceLoss(opponent, targetPiece.type);
                        trackCapture(player); // Track capture for statistics
                        gameLog.push(`${player === 'W' ? 'Player' : 'AI'} captured ${targetPiece.type} (+${captureValue} points) with Dragon's Inferno at (${nr},${nc})`);

                        if (targetPiece.type === 'Champion') {
                            championCaptured[targetPiece.player] = true;
                        }
                        if (targetPiece.type === 'King') {
                            endGame(player);
                            return;
                        }
                        cleanupNecromancerTracking(targetPiece);
                        board[nr][nc] = null;
                    }
                }
            }

            if (capturedSomething) {
                checkSupremacy(player);
                updateGameLog();
                updateCapturedPiecesDisplay();
                updateScoreDisplay();
            }
        }


        function movePiece(fromRow, fromCol, toRow, toCol, jump) {
            const piece = board[fromRow][fromCol];
            const opponent = getOpponent(piece.player);
            let captured = false;
            const opponentBackRow = piece.player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);
            const ownBackRow = piece.player === 'W' ? (gameVariant === 'ccb' ? 7 : 9) : 0;

            if (piece.type === 'Champion' && fromRow === opponentBackRow) {
                championsOnBackRow[piece.player] = championsOnBackRow[piece.player].filter(pos => pos[0] !== fromRow || pos[1] !== fromCol);
            }

            if (jump && board[jump[0]][jump[1]] && board[jump[0]][jump[1]].player !== piece.player) {
                const capturedPiece = board[jump[0]][jump[1]];
                if (capturedPiece.type === 'Zombie') {
                    const result = handleZombieCaptureAttempt(piece, fromRow, fromCol, jump[0], jump[1], { jumpCapture: true });
                    if (!result.success) {
                        return;
                    }
                    captured = true;
                } else {
                    capturedSquares.push([jump[0], jump[1]]);
                    capturedPieces[piece.player].push(capturedPiece);
                    const captureValue = pieceValues[capturedPiece.type];
                    scores[piece.player] += captureValue;
                    registerScoreGain(piece.player, captureValue);
                    registerPieceLoss(opponent, capturedPiece.type);
                    trackCapture(piece.player); // Track capture for statistics
                    gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} captured ${capturedPiece.type} (+${captureValue} points) with ${piece.type} at (${jump[0]},${jump[1]})`);
                    cleanupNecromancerTracking(capturedPiece);
                    board[jump[0]][jump[1]] = null;
                    if (capturedPiece.type === 'King') {
                        // Complete the move first
                        board[toRow][toCol] = piece;
                        board[fromRow][fromCol] = null;
                        firstMoves.delete(`${fromRow},${fromCol},${piece.player}`);
                        renderBoard();
                        updateScoreDisplay();
                        updateCapturedPiecesDisplay();
                        updateGameLog();
                        // Immediately set gameOver flag to prevent any further actions
                        gameOver = true;
                        // Add 3-5 second delay before showing end game popup to allow final move animation to complete
                        const endGameDelay = 3000 + Math.random() * 2000; // Random delay between 3000-5000ms
                        setTimeout(() => {
                            endGame(piece.player);
                        }, endGameDelay);
                        return;
                    }
                    captured = true;
                }
            }

            if (board[toRow][toCol]) {
                // Archers and Ballistas cannot capture by landing - they can only shoot
                if (piece.type === 'Archer' || piece.type === 'Ballista') {
                    gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} ${piece.type} cannot capture by landing - must shoot instead`);
                    // Don't allow the move - this shouldn't happen but just in case
                } else {
                    const capturedPiece = board[toRow][toCol];
                    if (capturedPiece.type === 'Zombie') {
                        const result = handleZombieCaptureAttempt(piece, fromRow, fromCol, toRow, toCol);
                        if (!result.success) {
                            return;
                        }
                        captured = true;
                    } else {
                        capturedSquares.push([toRow, toCol]);
                        capturedPieces[piece.player].push(capturedPiece);
                        const captureValue = pieceValues[capturedPiece.type];
                        scores[piece.player] += captureValue;
                        registerScoreGain(piece.player, captureValue);
                        registerPieceLoss(opponent, capturedPiece.type);
                        trackCapture(piece.player); // Track capture for statistics
                        gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} captured ${capturedPiece.type} (+${captureValue} points) with ${piece.type} at (${toRow},${toCol})`);
                        if (capturedPiece.type === 'Champion') {
                            championCaptured[capturedPiece.player] = true;
                        }
                        cleanupNecromancerTracking(capturedPiece);
                        if (capturedPiece.type === 'King') {
                            // Complete the move first
                            board[toRow][toCol] = piece;
                            board[fromRow][fromCol] = null;
                            firstMoves.delete(`${fromRow},${fromCol},${piece.player}`);
                            renderBoard();
                            updateScoreDisplay();
                            updateCapturedPiecesDisplay();
                            updateGameLog();
                            // Immediately set gameOver flag to prevent any further actions
                            gameOver = true;
                            // Add 3-5 second delay before showing end game popup to allow final move animation to complete
                            const endGameDelay = 3000 + Math.random() * 2000; // Random delay between 3000-5000ms
                            setTimeout(() => {
                                endGame(piece.player);
                            }, endGameDelay);
                            return;
                        }
                        captured = true;
                    }
                }
            } else {
                gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} moved ${piece.type} from (${fromRow},${fromCol}) to (${toRow},${toCol})`);
            }

            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            firstMoves.delete(`${fromRow},${fromCol},${piece.player}`);

            // If a Ballista moved and had an active range boost, it persists for the turn (no change needed)

            if (piece.type === 'Champion' && toRow === opponentBackRow) {
                championsOnBackRow[piece.player].push([toRow, toCol]);
            }

            if ((piece.type === 'Infantry' || piece.type === 'Champion' || piece.type === 'King') && toRow === opponentBackRow && !captured) {
                reinforce(piece.player, toRow, toCol);
            }

            checkSupremacy(piece.player);

            // Mercenary special move: check if coin flip is needed for bonus turn after capture
            let mercenaryBonusTurn = false;
            let mercenaryFlipNeeded = false;
            if (captured && piece.type === 'Mercenary' && piece.player === currentPlayer &&
                !mercenaryBonusTurnUsed[piece.player].has(piece) &&
                mercenaryBonusTurnCount[piece.player] < 3) {
                // Indicate that a coin flip is needed
                mercenaryFlipNeeded = true;
            } else if (captured && piece.type === 'Mercenary' && piece.player === currentPlayer &&
                       mercenaryBonusTurnCount[piece.player] >= 3) {
                gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} Mercenary has no bonus turns remaining (3/3 used).`);
            }

            updateGameLog();
            updateCapturedPiecesDisplay();
            return { mercenaryBonusTurn, mercenaryFlipNeeded, mercenaryPiece: piece, mercenaryPos: { row: toRow, col: toCol } };
        }

        function handleMercenaryCoinFlip(player, piece, row, col, callback) {
            const playerLabel = player === 'W' ? 'Player' : 'AI';
            const automated = player === 'B'; // Automated for AI

            performCoinToss(
                'Mercenary Bonus Turn',
                `${playerLabel} mercenary attempts bonus turn`,
                (success) => {
                    if (success) {
                        // Grant bonus turn
                        mercenaryBonusTurnUsed[player].add(piece);
                        mercenaryBonusTurnCount[player]++;
                        // Remove the mercenary from movedPieces so it can move again
                        movedPieces.delete(`${row},${col}`);
                        // Set bonus turn state to restrict selection to this mercenary only
                        mercenaryBonusTurnActive = true;
                        mercenaryBonusTurnPiece = { row, col };
                        const remaining = 3 - mercenaryBonusTurnCount[player];
                        gameLog.push(`${playerLabel} Mercenary won the coin flip! Bonus turn granted - the mercenary can move again without cost. (${remaining} bonus turns remaining)`);

                        updateGameLog();
                        callback(true); // Bonus turn granted
                    } else {
                        gameLog.push(`${playerLabel} Mercenary lost the coin flip. No bonus turn.`);
                        updateGameLog();
                        callback(false); // No bonus turn
                    }
                },
                automated,
                false  // showOverlay
            );
        }

        function shootPiece(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            if (!piece) return;
            if (piece.type === 'Fusilier') {
                fusilierShotThisTurn[piece.player].add(piece);
                fusilierShotLastTurn[piece.player].delete(piece);
                if (fusilierCrackShotActive === piece) {
                    fusilierCrackShotActive = null;
                }
            }
            const targetPiece = board[toRow][toCol];
            if (targetPiece && targetPiece.type === 'Spectre') {
                const actorLabel = piece.player === 'W' ? 'Player' : getOpponentDisplayName();
                gameLog.push(`${actorLabel} cannot shoot Spectres. The attack fizzled.`);
                updateGameLog();
                return;
            }
            if (targetPiece && targetPiece.type === 'Zombie') {
                const result = handleZombieCaptureAttempt(piece, fromRow, fromCol, toRow, toCol, { ranged: true });
                if (result.handled) {
                    if (result.success) {
                        renderBoard();
                        updateScoreDisplay();
                        updateCapturedPiecesDisplay();
                        updateGameLog();
                    }
                    return;
                }
            }
            if (targetPiece && targetPiece.type === 'Huntsman') {
                const attackerLabel = piece.player === 'W' ? 'Player' : getOpponentDisplayName();
                const success = randomCoinFlip();
                if (!success) {
                    gameLog.push(`${attackerLabel} failed to shoot the Huntsman at (${toRow},${toCol}).`);
                    updateGameLog();
                    return;
                }
                gameLog.push(`${attackerLabel} won the Huntsman defense coin flip at (${toRow},${toCol}).`);
                updateGameLog();
            }
            if (targetPiece) {
                capturedSquares.push([toRow, toCol]);
                capturedPieces[piece.player].push(targetPiece);
                const captureValue = pieceValues[targetPiece.type];
                scores[piece.player] += captureValue;
                registerScoreGain(piece.player, captureValue);
                registerPieceLoss(getOpponent(piece.player), targetPiece.type);
                trackCapture(piece.player); // Track capture for statistics
                gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} shot ${targetPiece.type} (+${captureValue} points) with ${piece.type} at (${toRow},${toCol})`);
                if (targetPiece.type === 'Champion') {
                    championCaptured[targetPiece.player] = true;
                }
                cleanupNecromancerTracking(targetPiece);
                if (targetPiece.type === 'King') {
                    // Immediately set gameOver flag to prevent any further actions
                    gameOver = true;
                    board[toRow][toCol] = null;
                    renderBoard();
                    updateScoreDisplay();
                    updateCapturedPiecesDisplay();
                    updateGameLog();
                    // Add 3-5 second delay before showing end game popup to allow final move animation to complete
                    const endGameDelay = 3000 + Math.random() * 2000; // Random delay between 3000-5000ms
                    setTimeout(() => {
                        endGame(piece.player);
                    }, endGameDelay);
                    return;
                }
                board[toRow][toCol] = null;
                checkSupremacy(piece.player);
            }
            updateGameLog();
            updateCapturedPiecesDisplay();
        }

        function applySpellCapture(attackerPlayer, targetRow, targetCol, options = {}) {
            const targetPiece = board[targetRow]?.[targetCol];
            if (!targetPiece) return false;

            capturedSquares.push([targetRow, targetCol]);
            capturedPieces[attackerPlayer].push(targetPiece);
            const captureValue = pieceValues[targetPiece.type] || 0;
            scores[attackerPlayer] += captureValue;
            registerScoreGain(attackerPlayer, captureValue);
            registerPieceLoss(targetPiece.player, targetPiece.type);
            trackCapture(attackerPlayer);
            if (options.logMessage) {
                gameLog.push(options.logMessage);
            }
            if (targetPiece.type === 'Champion') {
                championCaptured[targetPiece.player] = true;
                championsOnBackRow[targetPiece.player] = championsOnBackRow[targetPiece.player].filter(([r, c]) => !(r === targetRow && c === targetCol));
            }
            cleanupNecromancerTracking(targetPiece);
            board[targetRow][targetCol] = null;
            if (targetPiece.type === 'King') {
                const victoryReason = options.victoryReason || options.ability || null;
                endGame(attackerPlayer, victoryReason);
            }
            return true;
        }

        function turnPiece(row, col, newFacing) {
            const piece = board[row][col];
            if (piece && turnablePieces.includes(piece.type)) {
                piece.facing = newFacing;
                gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} turned ${piece.type} at (${row},${col}) to face ${newFacing} (${facingIcons[newFacing]})`);
            }
        }

        function reinforce(player, row, col) {
            reinforcementPending = { player, row, col };
            let availablePieces = capturedPieces[player].map(p => p.type);
            const piece = board[row][col];
            if (piece.type === 'Champion' || piece.type === 'King') {
                if (gameVariant === '36s-expert' || gameVariant === '36s-elite' || gameVariant === '36s-supreme') {
                    availablePieces.push(...Array(2).fill('Ballista'), ...Array(2).fill('Elephantry'), ...Array(2).fill('Mercenary'));
                }
            }
            if (availablePieces.length === 0) {
                reinforcementPending = null;
                return;
            }
            if (player === 'W') {
                const modal = document.getElementById('reinforce-modal');
                const select = document.getElementById('reinforce-select');
                select.innerHTML = availablePieces.map(p => `<option value="${p}">${p}</option>`).join('');
                modal.style.display = 'block';
            } else {
                // AI prioritizes high-value pieces for reinforcement
                const sortedPieces = availablePieces.sort((a, b) => {
                    return (aiPieceValues[b] || basePieceValues[b] || 0) - (aiPieceValues[a] || basePieceValues[a] || 0);
                });
                // Take the highest value piece (or occasionally second-highest for variety)
                const pieceType = Math.random() < 0.8 ? sortedPieces[0] : (sortedPieces[1] || sortedPieces[0]);
                confirmReinforcement(pieceType);
            }
        }

        function confirmReinforcement(pieceType) {
            if (!reinforcementPending) return;
            const { player, row, col } = reinforcementPending;
            const backRow = player === 'W' ? (gameVariant === 'ccb' ? 7 : 9) : 0;
            let relentlessTriggered = false;
            for (let c = 0; c < COLS; c++) {
                if (!board[backRow][c]) {
                    const type = pieceType || document.getElementById('reinforce-select').value;
                    board[backRow][c] = {
                        type,
                        player,
                        facing: turnablePieces.includes(type) ? (player === 'W' ? 'U' : 'D') : null
                    };
                    gameLog.push(`${player === 'W' ? 'Player' : 'AI'} reinforced ${type} at (${backRow},${c})`);
                    relentlessTriggered = registerReinforcement(player, type);
                    break;
                }
            }
            document.getElementById('reinforce-modal').style.display = 'none';
            reinforcementPending = null;
            if (relentlessTriggered) {
                return;
            }
            renderBoard();
            updateStatus();
            updateGameLog();
            checkGameOver();
            // After reinforcement, explicitly check if turn should end
            if (currentPlayer === 'W') {
                if (movesLeft <= 0) {
                    triggerAiTurn();
                } else {
                    ensureAITurnIfNeeded();
                }
            }
        }

        function cloneBoard(board) {
            return board.map(row => row.map(cell => cell ? { ...cell } : null));
        }

        /**
         * New aggressive evaluation function.
         */
        function evaluateBoard(board, player) {
            let score = 0;
            const opponent = player === 'W' ? 'B' : 'W';
            const opponentBackRow = player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);
            const centerRow = (ROWS - 1) / 2;
            const centerCol = (COLS - 1) / 2;

            // Use AI profile weights (if AI is playing, adjust weights based on profile)
            const profile = (player === 'B' && currentAiProfile) ? currentAiProfile : null;
            const MOBILITY_WEIGHT = profile ? (0.45 * profile.mobilityWeight) : 0.45;
            const CENTER_WEIGHT = profile ? (0.25 * profile.centerWeight) : 0.25;
            const THREAT_MULTIPLIER = profile ? profile.threatWeight : 1.0;
            
            let playerPieceValue = 0;
            let opponentPieceValue = 0;
            let playerThreats = 0;
            let opponentThreats = 0;
            let playerMobility = 0;
            let opponentMobility = 0;
            let playerCenterControl = 0;
            let opponentCenterControl = 0;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece) continue;

                    const value = aiPieceValues[piece.type];
                    const distToCenter = Math.hypot(r - centerRow, c - centerCol);

                    if (piece.player === player) {
                        playerPieceValue += value;
                        playerCenterControl -= distToCenter;
                        if ((piece.type === 'Infantry' || piece.type === 'Champion') && r === opponentBackRow) {
                            playerPieceValue += 5; // Promotion/reinforcement bonus
                        }

                        // Add advancement bonus for pieces that can trigger reinforcements
                        if (piece.type === 'Infantry' || piece.type === 'Champion' || piece.type === 'King') {
                            const distanceToBackRow = Math.abs(r - opponentBackRow);
                            const maxDistance = player === 'W' ? ROWS - 1 : (gameVariant === 'ccb' ? 7 : 9);
                            const advancementBonus = (1 - distanceToBackRow / maxDistance) * 3; // Up to +3 bonus for being close to back row
                            playerPieceValue += advancementBonus;
                        }

                        const moves = pieceTypes[piece.type].move(r, c, board, player, false, piece.facing, 3) || [];
                        playerMobility += moves.length;
                        for (const move of moves) {
                            if (move.type === 'move' || move.type === 'shoot') {
                                const targetPiece = board[move.pos[0]]?.[move.pos[1]];
                                if (targetPiece && targetPiece.player === opponent) {
                                    // KING TARGETING: Massively increase threat value when threatening the King
                                    if (targetPiece.type === 'King') {
                                        playerThreats += aiPieceValues[targetPiece.type] * 50.0 * THREAT_MULTIPLIER; // Huge bonus for threatening King
                                    } else {
                                        playerThreats += aiPieceValues[targetPiece.type] * 0.85 * THREAT_MULTIPLIER;
                                    }
                                }
                            }
                        }
                    } else {
                        opponentPieceValue += value;
                        opponentCenterControl -= distToCenter;

                        const moves = pieceTypes[piece.type].move(r, c, board, opponent, false, piece.facing, 3) || [];
                        opponentMobility += moves.length;
                        for (const move of moves) {
                            if (move.type === 'move' || move.type === 'shoot') {
                                const targetPiece = board[move.pos[0]]?.[move.pos[1]];
                                if (targetPiece && targetPiece.player === player) {
                                    // KING TARGETING: Massively penalize if opponent is threatening our King
                                    if (targetPiece.type === 'King') {
                                        opponentThreats += aiPieceValues[targetPiece.type] * 50.0 * THREAT_MULTIPLIER; // Huge penalty for opponent threatening our King
                                    } else {
                                        opponentThreats += aiPieceValues[targetPiece.type] * 0.85 * THREAT_MULTIPLIER;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            score = (playerPieceValue - opponentPieceValue)
                  + (playerThreats - opponentThreats)
                  + MOBILITY_WEIGHT * (playerMobility - opponentMobility)
                  + CENTER_WEIGHT * (playerCenterControl - opponentCenterControl);
            
            return score;
        }

        function simulateMove(board, fromRow, fromCol, toRow, toCol, jump, player, capturedPieces, scores, championsOnBackRow) {
            const newBoard = cloneBoard(board);
            const piece = newBoard[fromRow][fromCol];
            let captured = false;
            const opponentBackRow = player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);

            if (piece.type === 'Champion' && fromRow === opponentBackRow) {
                championsOnBackRow[player] = championsOnBackRow[player].filter(pos => pos[0] !== fromRow || pos[1] !== fromCol);
            }

            if (jump && newBoard[jump[0]][jump[1]] && newBoard[jump[0]][jump[1]].player !== player) {
                capturedPieces[player].push(newBoard[jump[0]][jump[1]]);
                scores[player] += aiPieceValues[newBoard[jump[0]][jump[1]].type];
                newBoard[jump[0]][jump[1]] = null;
                captured = true;
            }
            if (newBoard[toRow][toCol]) {
                capturedPieces[player].push(newBoard[toRow][toCol]);
                scores[player] += aiPieceValues[newBoard[toRow][toCol].type];
                captured = true;
            }
            newBoard[toRow][toCol] = piece;
            newBoard[fromRow][fromCol] = null;

            if (piece.type === 'Champion' && toRow === opponentBackRow) {
                championsOnBackRow[player].push([toRow, toCol]);
            }

            return { board: newBoard, captured };
        }

        function simulateShoot(board, fromRow, fromCol, toRow, toCol, player, capturedPieces, scores) {
            const newBoard = cloneBoard(board);
            if (newBoard[toRow][toCol]) {
                if (newBoard[toRow][toCol].type === 'Spectre') {
                    return newBoard;
                }
                capturedPieces[player].push(newBoard[toRow][toCol]);
                scores[player] += aiPieceValues[newBoard[toRow][toCol].type];
                newBoard[toRow][toCol] = null;
            }
            return newBoard;
        }

        function simulateTurn(board, row, col, newFacing) {
            const newBoard = cloneBoard(board);
            newBoard[row][col].facing = newFacing;
            return newBoard;
        }

        /**
         * Find moves for low-value pieces (Infantry, Archer, etc.) to use final move point
         */
        function findLowValuePieceMove(player, movedPieces) {
            const LOW_VALUE_PIECES = ['Infantry', 'Archer', 'Zombie', 'Pistolier', 'Cavalry'];
            const centerRow = (ROWS - 1) / 2;
            const centerCol = (COLS - 1) / 2;
            let best = null;
            let bestScore = -Infinity;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player || movedPieces.has(`${r},${c}`)) continue;

                    // Prioritize low-value pieces
                    if (!LOW_VALUE_PIECES.includes(piece.type)) continue;

                    const moves = pieceTypes[piece.type].move(r, c, board, player, false, piece.facing, 1);
                    if (!moves) continue;

                    for (const move of moves) {
                        if (move.cost > 1) continue; // Only 1-cost moves
                        const [mr, mc] = move.pos;
                        const targetPiece = board[mr]?.[mc];

                        let score = 0;

                        // Prioritize captures even for low-value pieces
                        if (targetPiece && targetPiece.player !== player) {
                            score += aiPieceValues[targetPiece.type] * 10;

                            // Extra bonus for adjacent captures
                            const distance = Math.abs(mr - r) + Math.abs(mc - c);
                            if (distance === 1) {
                                score += 50; // High priority for using last move on adjacent capture
                            }
                        } else {
                            // For non-captures, prefer moving towards center or forward
                            const distToCenter = Math.hypot(mr - centerRow, mc - centerCol);
                            score -= distToCenter * 0.1;

                            // Encourage forward movement (towards opponent's side)
                            if (player === 'B' && mr > r) score += 2; // AI moves down
                            if (player === 'W' && mr < r) score += 2; // Player moves up
                        }

                        // Slightly prefer Infantry to use last point
                        if (piece.type === 'Infantry') score += 1;

                        if (score > bestScore) {
                            bestScore = score;
                            best = { ...move, from: [r, c], pieceType: piece.type };
                        }
                    }
                }
            }
            return best;
        }

        function findSimpleAIAction(player, movesLeft, movedPieces) {
            let best = null;
            let bestScore = -Infinity;
            const centerRow = (ROWS - 1) / 2;
            const centerCol = (COLS - 1) / 2;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player || movedPieces.has(`${r},${c}`)) continue;
                    const moves = getValidMoves(r, c) || [];
                    for (let move of moves) {
                        if (move.cost > movesLeft) continue;
                        const [mr, mc] = move.pos;
                        const targetPiece = board[mr]?.[mc];
                        const moveCost = typeof move.cost === 'number' ? move.cost : 1;
                        let score = moveCost * 0.45; // encourage spending available points
                        if (targetPiece && targetPiece.player !== player) {
                            const captureBonus = currentAiProfile ? currentAiProfile.captureBonus : 1.0;
                            score += aiPieceValues[targetPiece.type] * 2.4 * captureBonus; // heavily favour captures (adjusted by AI profile)
                            // Add proximity bonus for close attacks
                            const distance = Math.abs(mr - r) + Math.abs(mc - c);
                            if (distance === 1) {
                                // CRITICAL PRIORITY: Adjacent pieces are immediate threats - heavily prioritize capturing them
                                const captureBonus = currentAiProfile ? currentAiProfile.captureBonus : 1.0;
                                score += aiPieceValues[targetPiece.type] * 7.56 * captureBonus; // 756% bonus for adjacent captures (increased by 80% from original 4.2, adjusted by AI profile)
                                // Extra flat bonus for ANY adjacent capture to encourage eliminating all immediate threats
                                score += 15; // Flat bonus to encourage capturing even low-value adjacent pieces
                            } else if (distance <= 2) {
                                score += aiPieceValues[targetPiece.type] * 0.5; // 50% bonus for close attacks in simple AI
                            }
                        } else if (move.special) {
                            let specialBonus = 2.0; // Base special move bonus
                            if (aiDifficulty === 'Hard') specialBonus = 5.85; // +30% difficulty (4.5 → 5.85)
                            else if (aiDifficulty === 'Medium') specialBonus = 4.2; // +20% difficulty (3.5 → 4.2)
                            else if (aiDifficulty === 'Easy') specialBonus = 2.2; // Slightly higher for Easy (+10%)

                            // Apply AI profile modifier to special ability usage
                            if (currentAiProfile) {
                                specialBonus *= currentAiProfile.specialAbilityBonus;
                            }
                            score += specialBonus;
                        } else {
                            score -= 0.5; // penalise idle repositioning
                        }
                        if (move.type === 'turn') score -= 0.6; // avoid standalone turns unless needed
                        if (move.type === 'move' && !targetPiece && !move.special) {
                            score -= 0.2 * Math.max(0, movesLeft - moveCost); // don't leave points unused
                        }
                        const distToCenter = Math.hypot(mr - centerRow, mc - centerCol);
                        score -= distToCenter * 0.05;
                        if (score > bestScore) {
                            bestScore = score;
                            best = { ...move, from: [r, c], pieceType: piece.type };
                        }
                    }
                }
            }
            return best;
        }

        // New AI simulation function for Inferno AOE
        function simulateInfernoCapture(board, row, col, player, capturedPieces, scores) {
            const newBoard = cloneBoard(board);
            const opponent = player === 'W' ? 'B' : 'W';
            const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];

            for (let d of directions) {
                let nr = row + d[0], nc = col + d[1];
                if (isValid(nr, nc)) {
                    const targetPiece = newBoard[nr][nc];
                    if (targetPiece && targetPiece.player === opponent) {
                        capturedPieces[player].push(targetPiece);
                        scores[player] += aiPieceValues[targetPiece.type];
                        newBoard[nr][nc] = null;
                    }
                }
            }
            return newBoard;
        }


        function simulateTurnAndMove(board, row, col, newFacing, toRow, toCol, jump, player, capturedPieces, scores, championsOnBackRow) {
            let newBoard = cloneBoard(board);
            newBoard[row][col].facing = newFacing;
            const piece = newBoard[row][col];
            let captured = false;
            const opponentBackRow = player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);

            if (piece.type === 'Champion' && row === opponentBackRow) {
                championsOnBackRow[player] = championsOnBackRow[player].filter(pos => pos[0] !== row || pos[1] !== col);
            }

            if (jump && newBoard[jump[0]][jump[1]] && newBoard[jump[0]][jump[1]].player !== player) {
                capturedPieces[player].push(newBoard[jump[0]][jump[1]]);
                scores[player] += aiPieceValues[newBoard[jump[0]][jump[1]].type];
                newBoard[jump[0]][jump[1]] = null;
                captured = true;
            }
            if (newBoard[toRow][toCol]) {
                capturedPieces[player].push(newBoard[toRow][toCol]);
                scores[player] += aiPieceValues[newBoard[toRow][toCol].type];
                captured = true;
            }
            newBoard[toRow][toCol] = piece;
            newBoard[row][col] = null;

            if (piece.type === 'Champion' && toRow === opponentBackRow) {
                championsOnBackRow[player].push([toRow, toCol]);
            }

            return { board: newBoard, captured };
        }

        function minimax(board, depth, isMaximizing, player, movesLeft, movedPieces, capturedPieces, scores, alpha, beta, championsOnBackRow) {
            const leafScore = () => {
                const leftover = Math.max(0, movesLeft);
                return evaluateBoard(board, player) - AI_LEFTOVER_PENALTY * leftover;
            };

            if (aiTimeExpired()) {
                return { score: leafScore(), sequence: [], sequenceCost: 0 };
            }

            if (depth === 0 || movesLeft <= 0) {
                return { score: leafScore(), sequence: [], sequenceCost: 0 };
            }
            const opponent = player === 'W' ? 'B' : 'W';
            let bestAction = null;
            if (isMaximizing) {
                let maxEval = -Infinity;
                let allPossibleActions = [];
                let bestSequence = [];
                let bestSequenceCost = 0;

                // 1. Find all possible moves
                outerBuild:
                for (let r = 0; r < ROWS; r++) {
                    if (aiTimeExpired()) break outerBuild;
                    for (let c = 0; c < COLS; c++) {
                        if (aiTimeExpired()) break outerBuild;
                        if (board[r][c] && board[r][c].player === player && !movedPieces.has(`${r},${c}`)) {
                            const piece = board[r][c];
                            const moves = getValidMoves(r, c); // This is already filtered by movesLeft
                            for (let move of moves) {
                                if (aiTimeExpired()) break outerBuild;
                                let targetValue = 0;
                                if ((move.type === 'move' || move.type === 'shoot') && board[move.pos[0]][move.pos[1]]) {
                                    const targetPiece = board[move.pos[0]][move.pos[1]];
                                    const captureBonus = currentAiProfile ? currentAiProfile.captureBonus : 1.0;
                                    targetValue = aiPieceValues[targetPiece.type] * captureBonus;

                                    // KING TARGETING: Absolute priority for capturing the King - game-ending move
                                    if (targetPiece.type === 'King') {
                                        // Massive bonus for King capture - make it the highest priority target
                                        targetValue += aiPieceValues[targetPiece.type] * 50.0 * captureBonus; // 5000% bonus for King capture
                                        const distance = Math.abs(move.pos[0] - r) + Math.abs(move.pos[1] - c);
                                        if (distance === 1) {
                                            // Adjacent King - EXTREME PRIORITY
                                            targetValue += aiPieceValues[targetPiece.type] * 100.0 * captureBonus; // Additional 10000% bonus for adjacent King
                                        } else if (distance <= 2) {
                                            // Close to King - very high priority
                                            targetValue += aiPieceValues[targetPiece.type] * 25.0 * captureBonus; // Additional 2500% bonus for close King
                                        }
                                    } else {
                                        // If capturing a Spectre, account for 50% success rate (unless exempt)
                                        if (targetPiece.type === 'Spectre' && piece.type !== 'Wizard' && piece.type !== 'Spectre') {
                                            targetValue *= 0.5; // 50% chance of success
                                        }
                                        // Add proximity bonus: prioritize attacking adjacent/in-range pieces
                                        const distance = Math.abs(move.pos[0] - r) + Math.abs(move.pos[1] - c);
                                        if (distance === 1) {
                                            // CRITICAL PRIORITY: Adjacent pieces are immediate threats - heavily prioritize capturing them
                                            targetValue += aiPieceValues[targetPiece.type] * 4.32 * captureBonus; // 432% bonus for adjacent captures in minimax (increased by 80% from original 2.4, adjusted by AI profile)
                                            // Extra flat bonus for ANY adjacent capture to encourage eliminating all immediate threats
                                            targetValue += 10; // Flat bonus to encourage capturing even low-value adjacent pieces
                                        } else if (distance <= 2) {
                                            targetValue += aiPieceValues[targetPiece.type] * 0.3 * captureBonus; // 30% bonus for close attacks (adjusted by AI profile)
                                        }
                                    }
                                }
                                allPossibleActions.push({
                                    ...move,
                                    from: [r,c],
                                    pieceType: piece.type,
                                    targetValue: targetValue
                                });
                            }
                            
                            // Check for Dragon Inferno
                            if (piece.type === 'Dragon' && !dragonInfernoUsed[player] && movesLeft >= 2) {
                                const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                                for (let d of directions) {
                                    if (aiTimeExpired()) break outerBuild;
                                    let nr = r + d[0], nc = c + d[1];
                                    if (isValid(nr, nc) && (!board[nr][nc] || board[nr][nc].player !== player)) {
                                        // Calculate total value of this Inferno move
                                        let infernoValue = 0;
                                        if (board[nr][nc] && board[nr][nc].player === opponent) {
                                            infernoValue += aiPieceValues[board[nr][nc].type];
                                        }
                                        // Check adjacent squares to the *landing spot*
                                        // Dragons cannot capture other Dragons with Inferno
                                        for (let d2 of directions) {
                                            let nnr = nr + d2[0], nnc = nc + d2[1];
                                            if (isValid(nnr, nnc) && board[nnr][nnc] && board[nnr][nnc].player === opponent && board[nnr][nnc].type !== 'Dragon') {
                                                infernoValue += aiPieceValues[board[nnr][nnc].type];
                                            }
                                        }
                                        // Add 40% bonus to encourage using Inferno special ability
                                        infernoValue *= 1.4;
                                        // Apply difficulty multiplier for special moves: Medium 1.2x, Hard 1.4x
                                        if (aiDifficulty === 'Hard') infernoValue *= 1.82; // +30% difficulty (1.4 → 1.82)
                                        else if (aiDifficulty === 'Medium') infernoValue *= 1.44; // +20% difficulty (1.2 → 1.44)
                                        allPossibleActions.push({ type: 'move', pos: [nr, nc], from: [r,c], cost: 2, special: 'inferno', pieceType: 'Dragon', targetValue: infernoValue });
                                    }
                                }
                            }

                            // Check for Wizard Strafe
                            if (piece.type === 'Wizard' && wizardStrafeUsed[player] < 2 && movesLeft >= 2) {
                                const strafeDirs = [[0,1], [0,-1], [1,0], [-1,0]];
                                for (let d of strafeDirs) {
                                    if (aiTimeExpired()) break outerBuild;
                                    let nr = r + d[0], nc = c + d[1];
                                    if (isValid(nr, nc) && !board[nr][nc]) {
                                        // Strafe is a positional move, increased value for tactical positioning
                                        let strafeValue = 2.5;
                                        if (aiDifficulty === 'Hard') strafeValue *= 1.69; // +30% difficulty (1.3 → 1.69)
                                        else if (aiDifficulty === 'Medium') strafeValue *= 1.38; // +20% difficulty (1.15 → 1.38)
                                        allPossibleActions.push({ type: 'move', pos: [nr, nc], from: [r,c], cost: 2, special: 'strafe', pieceType: 'Wizard', targetValue: strafeValue });
                                    }
                                }
                            }

                            // Check for Dragon Strafe
                            if (piece.type === 'Dragon' && dragonStrafeUsed[player] < 2 && movesLeft >= 2) {
                                const strafeDirs = [[0,1], [0,-1], [1,0], [-1,0]];
                                for (let d of strafeDirs) {
                                    if (aiTimeExpired()) break outerBuild;
                                    let nr = r + d[0], nc = c + d[1];
                                    if (isValid(nr, nc) && !board[nr][nc]) {
                                        // Strafe is a positional move, increased value for tactical positioning
                                        let strafeValue = 2.5;
                                        if (aiDifficulty === 'Hard') strafeValue *= 1.69; // +30% difficulty (1.3 → 1.69)
                                        else if (aiDifficulty === 'Medium') strafeValue *= 1.38; // +20% difficulty (1.15 → 1.38)
                                        allPossibleActions.push({ type: 'move', pos: [nr, nc], from: [r,c], cost: 2, special: 'strafe', pieceType: 'Dragon', targetValue: strafeValue });
                                    }
                                }
                            }

                            // Check for Wizard Spectre Summoning
                            if (piece.type === 'Wizard' && spectresSummoned[player] < 2 && !wizardSummonedThisTurn[player] && movesLeft >= 2) {
                                const totalCaptured = capturedPieces['W'].length + capturedPieces['B'].length;
                                if (totalCaptured >= 5) {
                                    const summonDirs = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                                    for (let d of summonDirs) {
                                        if (aiTimeExpired()) break outerBuild;
                                        let nr = r + d[0], nc = c + d[1];
                                        if (isValid(nr, nc) && !board[nr][nc]) {
                                            // Summoning has 50% success rate, but Spectre is valuable (value 9)
                                            // Base value = 0.5 * 9 = 4.5, increased to 9.0 to heavily encourage summoning
                                            // Apply difficulty multiplier: Easy 1.0x, Medium 1.3x, Hard 1.5x
                                            let summonValue = 9.0;
                                            if (aiDifficulty === 'Hard') summonValue *= 1.95; // +30% difficulty (1.5 → 1.95)
                                            else if (aiDifficulty === 'Medium') summonValue *= 1.56; // +20% difficulty (1.3 → 1.56)
                                            allPossibleActions.push({ type: 'summon', pos: [nr, nc], from: [r,c], cost: 2, special: 'summonSpectre', pieceType: 'Wizard', targetValue: summonValue });
                                        }
                                    }
                                }
                            }

                            // Check for Necromancer Zombie Summoning (Elite/Supreme)
                            if (piece.type === 'Necromancer' && (gameVariant === '36s-elite' || gameVariant === '36s-supreme') && movesLeft >= 2) {
                                const maxZombies = getMaxZombies(player);
                                if (zombiesSummoned[player] < maxZombies) {
                                    const backRow = player === 'W' ? ROWS - 1 : 0;
                                    for (let col = 0; col < COLS; col++) {
                                        if (aiTimeExpired()) break outerBuild;
                                        if (!board[backRow][col]) {
                                            // Zombie summoning has 50% success rate, Zombie value is 3
                                            // Expected value = 0.5 * 3 = 1.5, increased to 6.0 to encourage summoning
                                            // Apply difficulty multiplier: Easy 1.0x, Medium 1.3x, Hard 1.5x
                                            let summonValue = 6.0;
                                            if (aiDifficulty === 'Hard') summonValue *= 1.95; // +30% difficulty (1.5 → 1.95)
                                            else if (aiDifficulty === 'Medium') summonValue *= 1.56; // +20% difficulty (1.3 → 1.56)
                                            allPossibleActions.push({ type: 'summon', pos: [backRow, col], from: [r,c], cost: 2, special: 'summonZombie', pieceType: 'Necromancer', targetValue: summonValue });
                                        }
                                    }
                                }
                            }

                            // Check for Necromancer Spectre Summoning (Elite/Supreme)
                            if (piece.type === 'Necromancer' && (gameVariant === '36s-elite' || gameVariant === '36s-supreme') && spectresSummoned[player] < 2 && movesLeft >= 2) {
                                for (let dr = -1; dr <= 1; dr++) {
                                    if (aiTimeExpired()) break outerBuild;
                                    for (let dc = -1; dc <= 1; dc++) {
                                        if (dr === 0 && dc === 0) continue;
                                        const nr = r + dr;
                                        const nc = c + dc;
                                        if (!isValid(nr, nc)) continue;
                                        if (board[nr][nc]) continue;
                                        // Spectre summoning has 50% success rate, Spectre value is 9
                                        // Expected value = 0.5 * 9 = 4.5, increased to 10.0 to heavily encourage summoning
                                        // Apply difficulty multiplier: Easy 1.0x, Medium 1.3x, Hard 1.5x
                                        let summonValue = 10.0;
                                        if (aiDifficulty === 'Hard') summonValue *= 1.5;
                                        else if (aiDifficulty === 'Medium') summonValue *= 1.3;
                                        allPossibleActions.push({ type: 'summon', pos: [nr, nc], from: [r,c], cost: 2, special: 'summonNecromancerSpectre', pieceType: 'Necromancer', targetValue: summonValue });
                                    }
                                }
                            }

                            // Check for Elephantry Charge
                            if (piece.type === 'Elephantry' && movesLeft >= 2) {
                                const pieceKey = `${r},${c},${player}`;
                                if (!elephantryChargeUsed.has(pieceKey)) {
                                    const facing = piece.facing;
                                    let directions = [];
                                    if (facing === 'U') directions = [[-1,0], [-1,-1], [-1,1]];
                                    else if (facing === 'D') directions = [[1,0], [1,-1], [1,1]];
                                    else if (facing === 'L') directions = [[0,-1], [-1,-1], [1,-1]];
                                    else if (facing === 'R') directions = [[0,1], [-1,1], [1,1]];

                                    for (let d of directions) {
                                        if (aiTimeExpired()) break outerBuild;
                                        let capturesInPath = [];
                                        let canCharge = true;
                                        let finalPos = null;

                                        for (let dist = 1; dist <= 3; dist++) {
                                            let nr = r + d[0] * dist;
                                            let nc = c + d[1] * dist;
                                            if (!isValid(nr, nc)) {
                                                canCharge = false;
                                                break;
                                            }

                                            const target = board[nr][nc];
                                            if (target) {
                                                if (target.type === 'Spectre' || target.type === 'Zombie') {
                                                    canCharge = false;
                                                    break;
                                                }
                                                if (target.player !== player) {
                                                    capturesInPath.push(aiPieceValues[target.type]);
                                                    if (target.type === 'Elephantry' || target.type === 'Ogre' || target.type === 'Troll' || target.type === 'Dragon') {
                                                        finalPos = [nr, nc];
                                                        break;
                                                    }
                                                } else {
                                                    canCharge = false;
                                                    break;
                                                }
                                            }
                                            if (dist === 3) finalPos = [nr, nc];
                                        }

                                        if (canCharge && finalPos) {
                                            let chargeValue = capturesInPath.reduce((sum, val) => sum + val, 0);
                                            // Encourage charge if it captures multiple pieces
                                            if (capturesInPath.length > 1) chargeValue *= 1.3;
                                            allPossibleActions.push({ type: 'move', pos: finalPos, from: [r,c], cost: 2, special: 'elephantryCharge', pieceType: 'Elephantry', targetValue: chargeValue });
                                        }
                                    }
                                }
                            }

                            // Check for turn actions
                            if (turnablePieces.includes(piece.type) && movesLeft >= turnCosts[piece.type]) {
                                const validDirections = getValidTurnDirections(piece.facing);
                                for (let facing of validDirections) {
                                    if (aiTimeExpired()) break outerBuild;
                                    allPossibleActions.push({ type: 'turn', pos: [r,c], from: [r,c], facing, cost: turnCosts[piece.type], pieceType: piece.type, targetValue: 0 });
                                    
                                    // Check for turn and move
                                    if (piece.type === 'Infantry' && movesLeft >= turnCosts[piece.type] + 1) {
                                        // Simulate the turn to get new moves
                                        const tempBoard = cloneBoard(board);
                                        tempBoard[r][c].facing = facing;
                                        const turnMoves = pieceTypes[piece.type].move(r, c, tempBoard, player, false, facing, movesLeft - turnCosts[piece.type]);
                                        for (let tm of turnMoves.filter(m => m.type === 'move' && m.cost <= (movesLeft - turnCosts[piece.type]))) {
                                            if (aiTimeExpired()) break outerBuild;
                                             allPossibleActions.push({ 
                                                type: 'turnAndMove', 
                                                pos: [r,c], 
                                                from: [r,c], 
                                                facing, 
                                                move: tm.pos, 
                                                cost: turnCosts[piece.type] + tm.cost, 
                                                jump: tm.jump,
                                                pieceType: piece.type,
                                                targetValue: board[tm.pos[0]][tm.pos[1]] ? aiPieceValues[board[tm.pos[0]][tm.pos[1]].type] : 0
                                            });
                                        }
                                    }

                                    // Archer Turn + Shoot (player-only)
                                    if (piece.type === 'Archer' && movesLeft >= turnCosts[piece.type] + 1) {
                                        const tempBoard2 = cloneBoard(board);
                                        tempBoard2[r][c].facing = facing;
                                        const turnMoves2 = pieceTypes['Archer'].move(r, c, tempBoard2, player, false, facing, movesLeft - turnCosts[piece.type]);
                                        for (let tm of turnMoves2.filter(m => m.type === 'shoot' && m.cost === 1)) {
                                            if (aiTimeExpired()) break outerBuild;
                                            allPossibleActions.push({
                                                type: 'turnAndShoot',
                                                pos: [r,c],
                                                from: [r,c],
                                                facing,
                                                shoot: tm.pos,
                                                cost: turnCosts[piece.type] + 1,
                                                pieceType: piece.type,
                                                targetValue: aiPieceValues[board[tm.pos[0]][tm.pos[1]]?.type] || 0
                                            });
                                        }
                                    }
                                }
                            }

                            // Archer Move + Diagonal Shoot (player-only)
                            if (piece.type === 'Archer' && movesLeft >= 2 && archerMoveDiagShootUsed[player] < 2) {
                                const basicMoves = pieceTypes['Archer'].move(r, c, board, player, null, piece.facing) || [];
                                for (let mv of basicMoves.filter(m => m.type === 'move' && m.cost === 1 && (!board[m.pos[0]][m.pos[1]] || board[m.pos[0]][m.pos[1]].player !== player))) {
                                    if (aiTimeExpired()) break outerBuild;
                                    const nr = mv.pos[0], nc = mv.pos[1];
                                    // Only consider if square is empty or capture allowed; allow both
                                    const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                                    for (let d of dirs) {
                                        if (aiTimeExpired()) break outerBuild;
                                        const sr = nr + d[0], sc = nc + d[1];
                                        if (isValid(sr, sc) && board[sr][sc] && board[sr][sc].player !== player) {
                                            allPossibleActions.push({
                                                type: 'archerMoveDiagShoot',
                                                from: [r,c],
                                                move: [nr, nc],
                                                shoot: [sr, sc],
                                                cost: 2,
                                                pieceType: 'Archer',
                                                targetValue: aiPieceValues[board[sr][sc].type]
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // 2. Sort actions: prioritize captures, then cost (prefer using more move points), then special abilities, then avoid unnecessary turns
                allPossibleActions.sort((a, b) => {
                    // Prioritize captures by target value
                    if (a.targetValue > b.targetValue) return -1;
                    if (a.targetValue < b.targetValue) return 1;

                    // Strongly prefer actions that use more move points (encourage AI to spend all points)
                    const aCost = typeof a.cost === 'number' ? a.cost : 1;
                    const bCost = typeof b.cost === 'number' ? b.cost : 1;
                    if (aCost !== bCost) return bCost - aCost; // Higher cost = better (spend more points)

                    // Prioritize special abilities
                    if (a.special && !b.special) return -1;
                    if (b.special && !a.special) return 1;

                    // Avoid unnecessary turns (don't penalize shooting pieces for turning)
                    if (a.type === 'turn' && !['Archer', 'Ballista'].includes(a.pieceType) && b.type !== 'turn') return 1;
                    if (b.type === 'turn' && !['Archer', 'Ballista'].includes(b.pieceType) && a.type !== 'turn') return -1;

                    return 0; // Keep stable order otherwise
                });

                const actionCap = isLargeBoardVariant() ? 80 : 220;
                if (allPossibleActions.length > actionCap) {
                    allPossibleActions = allPossibleActions.slice(0, actionCap);
                }
                
                // 3. Evaluate sorted actions
                for (let action of allPossibleActions) {
                    if (aiTimeExpired()) break;
                    const { from, pos, cost, jump, special, type, facing, move } = action;
                    const actionCost = typeof cost === 'number' ? cost : 0;
                    const r = from[0];
                    const c = from[1];

                    if (movesLeft < actionCost) continue; 

                    const newCapturedPieces = { W: [...capturedPieces.W], B: [...capturedPieces.B] };
                    const newScores = { ...scores };
                    const newChampionsOnBackRow = { W: [...championsOnBackRow.W], B: [...championsOnBackRow.B] };
                    let newBoard;
                    let newMovedPieces = new Set(movedPieces);
                    newMovedPieces.add(`${r},${c}`);
                    
                    if (type === 'move') {
                        const result = simulateMove(board, r, c, pos[0], pos[1], jump, player, newCapturedPieces, newScores, newChampionsOnBackRow);
                        newBoard = result.board;
                        if (special === 'inferno') {
                            newBoard = simulateInfernoCapture(newBoard, pos[0], pos[1], player, newCapturedPieces, newScores);
                        }
                        newMovedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (type === 'shoot') {
                        newBoard = simulateShoot(board, r, c, pos[0], pos[1], player, newCapturedPieces, newScores);
                    } else if (type === 'activate' && special === 'ballistaRange') {
                        // No board change; treat as state-only in real play. Here, approximate as no-op.
                        newBoard = cloneBoard(board);
                    } else if (type === 'swap') {
                        newBoard = cloneBoard(board);
                        const guardPiece = newBoard[pos[0]][pos[1]];
                        newBoard[pos[0]][pos[1]] = newBoard[r][c];
                        newBoard[r][c] = guardPiece;
                        newMovedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (type === 'teleport') {
                        newBoard = cloneBoard(board);
                        const destinationPiece = newBoard[pos[0]][pos[1]];
                        if (destinationPiece) {
                            if (destinationPiece.player === player || destinationPiece.type !== 'Spectre') {
                                continue;
                            }
                            newCapturedPieces[player].push(destinationPiece);
                            newScores[player] += aiPieceValues[destinationPiece.type];
                        }
                        newBoard[pos[0]][pos[1]] = newBoard[r][c];
                        newBoard[r][c] = null;
                        newMovedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (type === 'teleportSwap') {
                        newBoard = cloneBoard(board);
                        const playerWizard = newBoard[r][c];
                        const opponentWizard = newBoard[pos[0]][pos[1]];
                        newBoard[pos[0]][pos[1]] = playerWizard;
                        newBoard[r][c] = opponentWizard;
                        newMovedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (type === 'turn') {
                        newBoard = simulateTurn(board, r, c, facing);
                    } else if (type === 'turnAndMove') {
                         const result = simulateTurnAndMove(board, r, c, facing, move[0], move[1], jump, player, newCapturedPieces, newScores, newChampionsOnBackRow);
                         newBoard = result.board;
                         newMovedPieces.add(`${move[0]},${move[1]}`);
                    } else if (type === 'turnAndShoot') {
                        // Approximate: turn then apply shoot
                        const turned = simulateTurn(board, r, c, facing);
                        newBoard = simulateShoot(turned, r, c, action.shoot[0], action.shoot[1], player, newCapturedPieces, newScores);
                    } else if (type === 'archerMoveDiagShoot') {
                        const mv = simulateMove(board, r, c, action.move[0], action.move[1], null, player, newCapturedPieces, newScores, newChampionsOnBackRow);
                        newBoard = simulateShoot(mv.board, action.move[0], action.move[1], action.shoot[0], action.shoot[1], player, newCapturedPieces, newScores);
                        newMovedPieces.add(`${action.move[0]},${action.move[1]}`);
                    } else if (type === 'summon') {
                        // Simulate summoning (has 50% success rate, we evaluate expected value in targetValue)
                        newBoard = cloneBoard(board);
                        // Optimistically place the summoned piece for evaluation
                        if (special === 'summonSpectre') {
                            newBoard[pos[0]][pos[1]] = { type: 'Spectre', player };
                            // Note: In real execution, this has 50% success which is factored into targetValue
                        } else if (special === 'summonZombie') {
                            newBoard[pos[0]][pos[1]] = { type: 'Zombie', player, facing: player === 'W' ? 'U' : 'D' };
                        } else if (special === 'summonNecromancerSpectre') {
                            newBoard[pos[0]][pos[1]] = { type: 'Spectre', player };
                        }
                    } else {
                        continue; // Should not happen
                    }
                    
                    const childResult = minimax(newBoard, depth - 1, false, player, movesLeft - actionCost, newMovedPieces, newCapturedPieces, newScores, alpha, beta, newChampionsOnBackRow);
                    const eval = childResult.score;
                    const totalCost = actionCost + (childResult.sequenceCost || 0);
                    if (eval > maxEval + AI_TIE_EPSILON || (Math.abs(eval - maxEval) <= AI_TIE_EPSILON && totalCost > bestSequenceCost)) {
                        maxEval = eval;
                        bestAction = action;
                        bestSequence = [action, ...(childResult.sequence || [])];
                        bestSequenceCost = totalCost;
                    }
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                if (maxEval === -Infinity) {
                    maxEval = leafScore();
                }
                return { score: maxEval, action: bestAction, sequence: bestSequence, sequenceCost: bestSequenceCost };
            } else { // Minimizing player (opponent simulation)
                let minEval = Infinity;
                // Note: We don't need to sort for the minimizing player, just find their best (worst for us) response.
                for (let r = 0; r < ROWS; r++) {
                    if (aiTimeExpired()) break;
                    for (let c = 0; c < COLS; c++) {
                        if (aiTimeExpired()) break;
                        if (board[r][c] && board[r][c].player === opponent && !movedPieces.has(`${r},${c}`)) {
                            const piece = board[r][c];
                            const moves = getValidMoves(r, c); // Already filtered by movesLeft
                            for (let move of moves) {
                                if (aiTimeExpired()) break;
                                // ... (Simulation logic as above) ...
                                const newCapturedPieces = { W: [...capturedPieces.W], B: [...capturedPieces.B] };
                                const newScores = { ...scores };
                                const newChampionsOnBackRow = { W: [...championsOnBackRow.W], B: [...championsOnBackRow.B] };
                                let newBoard;
                                let newMovedPieces = new Set(movedPieces);
                                newMovedPieces.add(`${r},${c}`);

                                if (move.type === 'move') {
                                    const result = simulateMove(board, r, c, move.pos[0], move.pos[1], move.jump, opponent, newCapturedPieces, newScores, newChampionsOnBackRow);
                                    newBoard = result.board;
                                    if (move.special === 'inferno') {
                                        newBoard = simulateInfernoCapture(newBoard, move.pos[0], move.pos[1], opponent, newCapturedPieces, newScores);
                                    }
                                    newMovedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                                } else if (move.type === 'shoot') {
                                    newBoard = simulateShoot(board, r, c, move.pos[0], move.pos[1], opponent, newCapturedPieces, newScores);
                                } else if (move.type === 'swap') {
                                    newBoard = cloneBoard(board);
                                    const guardPiece = newBoard[move.pos[0]][move.pos[1]];
                                    newBoard[move.pos[0]][move.pos[1]] = newBoard[r][c];
                                    newBoard[r][c] = guardPiece;
                                    newMovedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                                } else if (move.type === 'teleport') {
                                    newBoard = cloneBoard(board);
                                    newBoard[move.pos[0]][move.pos[1]] = newBoard[r][c];
                                    newBoard[r][c] = null;
                                    newMovedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                                } else if (move.type === 'teleportSwap') {
                                    newBoard = cloneBoard(board);
                                    const playerWizard = newBoard[r][c];
                                    const opponentWizard = newBoard[move.pos[0]][move.pos[1]];
                                    newBoard[move.pos[0]][move.pos[1]] = playerWizard;
                                    newBoard[r][c] = opponentWizard;
                                    newMovedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                                } else {
                                    continue;
                                }

                                const eval = minimax(newBoard, depth - 1, true, player, movesLeft - move.cost, newMovedPieces, newCapturedPieces, newScores, alpha, beta, newChampionsOnBackRow).score;
                                minEval = Math.min(minEval, eval);
                                beta = Math.min(beta, eval);
                                if (beta <= alpha) break;
                            }
                            if (beta <= alpha) break;
                            
                            // Check for Dragon Inferno for opponent
                            if (piece.type === 'Dragon' && !dragonInfernoUsed[opponent] && movesLeft >= 2) {
                                const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                                for (let d of directions) {
                                    if (aiTimeExpired()) break;
                                    let nr = r + d[0], nc = c + d[1];
                                    if (isValid(nr, nc) && (!board[nr][nc] || board[nr][nc].player !== opponent)) {
                                        const newCapturedPieces = { W: [...capturedPieces.W], B: [...capturedPieces.B] };
                                        const newScores = { ...scores };
                                        const newChampionsOnBackRow = { W: [...championsOnBackRow.W], B: [...championsOnBackRow.B] };
                                        let newMovedPieces = new Set(movedPieces);
                                        newMovedPieces.add(`${r},${c}`);
                                        
                                        const result = simulateMove(board, r, c, nr, nc, null, opponent, newCapturedPieces, newScores, newChampionsOnBackRow);
                                        let newBoard = result.board;
                                        newBoard = simulateInfernoCapture(newBoard, nr, nc, opponent, newCapturedPieces, newScores);
                                        newMovedPieces.add(`${nr},${nc}`);
                                        
                                        const eval = minimax(newBoard, depth - 1, true, player, movesLeft - 2, newMovedPieces, newCapturedPieces, newScores, alpha, beta, newChampionsOnBackRow).score;
                                        minEval = Math.min(minEval, eval);
                                        beta = Math.min(beta, eval);
                                        if (beta <= alpha) break;
                                    }
                                }
                            }
                            if (beta <= alpha) break;

                            // Check opponent's turn actions
                            if (turnablePieces.includes(piece.type) && movesLeft >= turnCosts[piece.type]) {
                                const validDirections = getValidTurnDirections(piece.facing);
                                for (let facing of validDirections) {
                                    if (aiTimeExpired()) break;
                                    const newBoard = simulateTurn(board, r, c, facing);
                                    const newMovedPieces = new Set(movedPieces);
                                    newMovedPieces.add(`${r},${c}`);
                                    let newMovesLeft = movesLeft - turnCosts[piece.type];
                                    
                                    let eval;
                                    if (piece.type === 'Infantry' && newMovesLeft >= 1) {
                                        // Opponent turn-and-move
                                        const tempBoard = cloneBoard(newBoard);
                                        const turnMoves = pieceTypes[piece.type].move(r, c, tempBoard, opponent, false, facing, newMovesLeft);
                                        
                                        let bestTurnMoveEval = Infinity;
                                        for (let tm of turnMoves.filter(m => m.type === 'move' && m.cost <= newMovesLeft)) {
                                            if (aiTimeExpired()) break;
                                            const tmCapturedPieces = { W: [...capturedPieces.W], B: [...capturedPieces.B] };
                                            const tmScores = { ...scores };
                                            const tmChampions = { W: [...championsOnBackRow.W], B: [...championsOnBackRow.B] };
                                            const result = simulateTurnAndMove(board, r, c, facing, tm.pos[0], tm.pos[1], tm.jump, opponent, tmCapturedPieces, tmScores, tmChampions);
                                            const tmBoard = result.board;
                                            const tmMovedPieces = new Set(newMovedPieces);
                                            tmMovedPieces.add(`${tm.pos[0]},${tm.pos[1]}`);
                                            
                                            const tmEval = minimax(tmBoard, depth - 1, true, player, newMovesLeft - tm.cost, tmMovedPieces, tmCapturedPieces, tmScores, alpha, beta, tmChampions).score;
                                            bestTurnMoveEval = Math.min(bestTurnMoveEval, tmEval);
                                        }
                                        eval = bestTurnMoveEval;
                                        
                                    } else {
                                        // Simple turn
                                        eval = minimax(newBoard, depth - 1, true, player, newMovesLeft, newMovedPieces, capturedPieces, scores, alpha, beta, championsOnBackRow).score;
                                    }
                                    
                                    minEval = Math.min(minEval, eval);
                                    beta = Math.min(beta, eval);
                                    if (beta <= alpha) break;
                                }
                            }
                        }
                        if (beta <= alpha) break;
                    }
                }
                if (minEval === Infinity) {
                    minEval = leafScore();
                }
                return { score: minEval, sequence: [], sequenceCost: 0 };
            }
        }


        function evaluateTurn(row, col, newFacing, player) {
            const piece = board[row][col];
            const tempFacing = piece.facing;
            piece.facing = newFacing;
            const moves = getValidMoves(row, col);
            piece.facing = tempFacing;
            let score = (piece.type === 'Infantry' || piece.type === 'Mercenary') ? 1 : 0;
            const opponentBackRow = player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);
            for (let move of moves) {
                if (move.type === 'shoot') {
                    const [r, c] = move.pos;
                    score += aiPieceValues[board[r][c]?.type] || 0;
                } else if (move.type === 'move' && (piece.type === 'Infantry' || piece.type === 'Mercenary') && move.pos[0] === opponentBackRow) {
                    score += 5;
                }
            }
            return score + Math.random();
        }

        function isValid(row, col) {
            return row >= 0 && row < ROWS && col >= 0 && col < COLS;
        }

        function isCheckAfterMove(fromRow, fromCol, toRow, toCol, player) {
            return false;
        }

        function highlightValidMoves() {
            if (!selectedPiece) return;
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                const r = parseInt(square.dataset.row);
                const c = parseInt(square.dataset.col);
                const move = validMoves.find(m => m.pos[0] === r && m.pos[1] === c);
                if (r === selectedPiece.row && c === selectedPiece.col) {
                    square.classList.add('selected');
                } else if (move) {
                    if (move.type === 'move' && !board[r][c]) {
                        square.classList.add('valid-move');
                    } else if (move.type === 'move' && board[r][c] && board[r][c].player !== board[selectedPiece.row][selectedPiece.col].player) {
                        square.classList.add('valid-capture');
                    } else if (move.type === 'shoot') {
                        square.classList.add('valid-shoot');
                    } else if (move.type === 'swap' || move.type === 'teleportSwap') {
                        square.classList.add('valid-swap');
                    } else if (move.type === 'teleport') {
                        square.classList.add('valid-move');
                    } else if (move.type === 'summon') {
                        square.classList.add('valid-move');
                    }
                }
            });
        }

        function aiTurn() {
            currentPlayer = 'B';
            aiPending = false; // clear any scheduled AI flag
            aiRoundNumber++; // Increment AI round counter
            const baseMoves = calculateBaseMoves('B');
            // Reset Ballista per-round boost for AI
            ballistaRangeBoostActive['B'] = false;
            ballistaRangeBoostUsedThisTurn['B'] = false;
            // Reset wizard summoning flag for new round
            wizardSummonedThisTurn['B'] = false;
            // Clear wizard movement restrictions from previous round
            wizardCannotMoveNextTurn['B'].clear();
            isFirstPlayerTurn = false;
            aiSearchDeadline = 0;

            if (!applyStartTurnModifiers('B', baseMoves, { skipStopTimer: true })) {
                completeAiTurn();
                return;
            }

            movedPieces.clear();
            updateStatus();
            updateEndTurnButton();

            let plannedActions = [];

            function makeNextMove() {
                try {
                    // If game is paused (e.g., warcry animation), reschedule and wait
                    if (gamePaused) {
                        setTimeout(() => makeNextMove(), 200);
                        return;
                    }
                    if (currentPlayer !== 'B') {
                        return;
                    }
                    if (aiTurnTimeoutForced) {
                        aiTurnTimeoutForced = false;
                        movesLeft = 0;
                    }
                    // Give priority to defensive and utility King abilities when available
                    const kingEvadePlan = getBestKingEvadePlan('B', movedPieces);
                    if (kingEvadePlan) {
                        plannedActions = [];
                        const [fromRow, fromCol] = kingEvadePlan.from;
                        const [toRow, toCol] = kingEvadePlan.to;
                        highlightSquares = [kingEvadePlan.from, kingEvadePlan.to];
                        movePiece(fromRow, fromCol, toRow, toCol);
                        kingEvadeUsed['B'] = true;
                        nextRoundModifier['B'] -= 2;
                        lastAction = { move: true };
                        movedPieces.add(`${toRow},${toCol}`);
                        const aiLabel = getOpponentDisplayName();
                        gameLog.push(`${aiLabel} used King Evade (-2 moves next round).`);
                        renderBoard();
                        updateStatus();
                        updateEndTurnButton();
                        updateGameLog();
                        checkGameOver();
                        setTimeout(() => {
                            highlightSquares = [];
                            renderBoard();
                            setTimeout(() => makeNextMove(), 1000);
                        }, 800);
                        return;
                    }

                    if (plannedActions.length === 0) {
                        const kingShotPlan = getBestKingShotPlan('B', movedPieces, movesLeft);
                        if (kingShotPlan) {
                            plannedActions = [];
                            const [fromRow, fromCol] = kingShotPlan.from;
                            const [targetRow, targetCol] = kingShotPlan.target;
                            const kingPiece = board[fromRow]?.[fromCol];
                            if (!kingPiece || kingPiece.type !== 'King') {
                                setTimeout(() => makeNextMove(), 200);
                                return;
                            }
                            highlightSquares = [kingShotPlan.from, kingShotPlan.target];
                            movesLeft = Math.max(0, movesLeft - 1);
                            markKingShotUsed(kingPiece);
                            shootPiece(fromRow, fromCol, targetRow, targetCol);
                            lastAction = { shoot: true };
                            movedPieces.add(`${fromRow},${fromCol}`);
                            const aiLabel = getOpponentDisplayName();
                            gameLog.push(`${aiLabel} executed King Shot.`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            checkGameOver();
                            setTimeout(() => {
                                highlightSquares = [];
                                renderBoard();
                                setTimeout(() => makeNextMove(), 1200);
                            }, 1000);
                            return;
                        }

                        const moralBoostTarget = getAiMoralBoostTarget('B', movedPieces, movesLeft);
                        if (moralBoostTarget) {
                            plannedActions = [];
                            const [kingRow, kingCol] = moralBoostTarget;
                            moralBoostUses['B']++;
                            movesLeft = Math.max(0, movesLeft - 1);
                            highlightSquares = [[kingRow, kingCol]];
                            updateStatus();
                            updateEndTurnButton();
                            const aiLabel = getOpponentDisplayName();
                            performCoinToss(
                                'Moral Boost',
                                `${aiLabel} is attempting a Moral Boost...`,
                                (success) => {
                                    if (success) {
                                        nextRoundModifier['B'] += MORAL_BOOST_BONUS;
                                        gameLog.push(`${aiLabel} succeeded with Moral Boost! +2 moves next round.`);
                                    } else {
                                        gameLog.push(`${aiLabel} failed to inspire a Moral Boost.`);
                                    }
                                    lastAction = { special: 'moralBoost' };
                                    movedPieces.add(`${kingRow},${kingCol}`);
                                    highlightSquares = [];
                                    selectedPiece = null;
                                    validMoves = [];
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    setTimeout(() => makeNextMove(), 1200);
                                },
                                true,
                                false
                            );
                            return;
                        }
                    }

                    // *** UPDATED: AI turn ends when out of moves or pending reinforcement
                    if (movesLeft <= 0 || reinforcementPending) {
                        highlightSquares = [];
                        plannedActions = [];
                        completeAiTurn();
                        return;
                    }
                    
                const canExecuteAction = (candidate) => {
                    if (!candidate) return false;
                    const cost = typeof candidate.cost === 'number' ? candidate.cost : 1;
                    if (cost > movesLeft) return false;
                    if (candidate.from) {
                        const [fr, fc] = candidate.from;
                        const piece = board[fr] && board[fr][fc];
                        if (!piece || piece.player !== 'B') return false;
                    }
                    if (candidate.type === 'move' && candidate.pos) {
                        const targetRow = candidate.pos[0];
                        const targetCol = candidate.pos[1];
                        const targetPiece = board[targetRow] && board[targetRow][targetCol];
                        if (targetPiece && targetPiece.player === 'B') return false;
                    }
                    if ((candidate.type === 'turn' || candidate.type === 'turnAndMove' || candidate.type === 'turnAndShoot') && candidate.pos) {
                        const turnRow = candidate.pos[0];
                        const turnCol = candidate.pos[1];
                        const turnPiece = board[turnRow] && board[turnRow][turnCol];
                        if (!turnPiece || turnPiece.player !== 'B') return false;
                    }
                    return true;
                };

                let action = null;

                if (plannedActions.length > 0) {
                    action = plannedActions.shift();
                    if (!canExecuteAction(action)) {
                        action = null;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    aiSearchDeadline = Date.now() + getAiTimeBudget();
                    const result = minimax(board, aiMaxDepth, true, 'B', movesLeft, movedPieces, capturedPieces, scores, -Infinity, Infinity, championsOnBackRow);
                    if (result.sequence && result.sequence.length) {
                        action = result.sequence[0];
                        plannedActions = result.sequence.slice(1);
                        if (plannedActions.length > 3) {
                            plannedActions.length = 3;
                        }
                    } else {
                        action = result.action;
                        plannedActions = [];
                    }
                    if (!canExecuteAction(action)) {
                        action = null;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    const energyBlastAction = findAiEnergyBlastOpportunity('B', movesLeft, movedPieces);
                    if (energyBlastAction) {
                        action = energyBlastAction;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    const sacrificeAction = findAiSacrificeOpportunity('B', movesLeft, movedPieces);
                    if (sacrificeAction) {
                        action = sacrificeAction;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    const championSummonAction = findAiChampionSummonOpportunity('B', movesLeft, movedPieces);
                    if (championSummonAction) {
                        action = championSummonAction;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    const kingSummonAction = findKingSummonOpportunity('B', movesLeft, movedPieces);
                    if (kingSummonAction) {
                        action = kingSummonAction;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    const zombieSummonAction = findAiZombieSummonOpportunity('B', movesLeft, movedPieces);
                    if (zombieSummonAction) {
                        action = zombieSummonAction;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    const huntsmanBurstAction = findAiHuntsmanBurstOpportunity('B', movesLeft, movedPieces);
                    if (huntsmanBurstAction) {
                        action = huntsmanBurstAction;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    plannedActions = [];
                    action = findSimpleAIAction('B', movesLeft, movedPieces);
                }

                if (!canExecuteAction(action)) {
                    action = null;
                }

                    if (aiTurnTimeoutForced) {
                        aiTurnTimeoutForced = false;
                        movesLeft = 0;
                        plannedActions = [];
                        action = null;
                    }

                    if (!action) {
                        // Special case: if AI has exactly 1 move point left, try to use it on low-value pieces
                        if (movesLeft === 1) {
                            action = findLowValuePieceMove('B', movedPieces);
                        }

                        // If still no action, end turn
                        if (!action) {
                            highlightSquares = [];
                            plannedActions = [];
                            completeAiTurn();
                            return;
                        }
                    }
                    
                    highlightSquares = [];
                    if (action.type === 'move' || action.type === 'shoot' || action.type === 'swap' || action.type === 'teleport' || action.type === 'teleportSwap' || action.type === 'activate' || action.type === 'summon' || action.type === 'energyBlast' || action.type === 'huntsmanBurst') {
                        const { from, pos, cost, jump, special, direction } = action;
                        if (action.type === 'energyBlast') {
                            highlightSquares = from ? [from] : [];
                        } else {
                            const targets = [];
                            if (from) targets.push(from);
                            if (pos) targets.push(pos);
                            highlightSquares = targets;
                        }
                        if (action.type === 'summon' && special === 'summonSpectre') {
                            // AI attempts to summon Spectre
                            const wizardRow = from[0], wizardCol = from[1];
                            const summonRow = pos[0], summonCol = pos[1];

                            // Deduct cost before coin toss
                            movesLeft -= cost;
                            movedPieces.add(`${wizardRow},${wizardCol}`);

                            // Show automated coin toss popup for AI
                            performCoinToss(
                                'Summon Spectre',
                                'AI is attempting to summon a Spectre...',
                                (success) => {
                                    if (success) {
                                        // Successfully summoned Spectre
                                        board[summonRow][summonCol] = { type: 'Spectre', player: 'B' };
                                        spectresSummoned['B']++;
                                        wizardSummonedThisTurn['B'] = true;
                                        wizardCannotMoveNextTurn['B'].add(`${wizardRow},${wizardCol}`);

                                        // Award 3 bonus points for successful summoning
                                        scores['B'] += 3;

                                        gameLog.push(`AI summoned a Spectre at (${summonRow},${summonCol})! (+3 bonus points)`);
                                    } else {
                                        // Failed summoning
                                        gameLog.push(`AI failed to summon a Spectre.`);
                                    }

                                    renderBoard();
                                    updateGameLog();
                                    updateScoreDisplay();

                                    // Continue AI turn
                                    setTimeout(() => makeNextMove(), 1200);
                                },
                                true, // Automated mode
                                false // showOverlay
                            );
                            return; // Exit to wait for coin toss callback
                        } else if (action.type === 'summon' && special === 'summonZombie') {
                            // AI attempts to summon Zombie (Necromancer)
                            const necromancerRow = from[0], necromancerCol = from[1];
                            const summonRow = pos[0], summonCol = pos[1];

                            // Deduct cost before coin toss
                            movesLeft -= cost;
                            movedPieces.add(`${necromancerRow},${necromancerCol}`);

                            // Show automated coin toss popup for AI
                            performCoinToss(
                                'Summon Zombie',
                                'AI is attempting to summon a Zombie...',
                                (success) => {
                                    if (success) {
                                        // Successfully summoned Zombie
                                        const zombiePiece = createZombiePiece('B');
                                        board[summonRow][summonCol] = zombiePiece;
                                        zombiesSummoned['B'] = (zombiesSummoned['B'] || 0) + 1;

                                        gameLog.push(`AI summoned a Zombie at (${summonRow},${summonCol})!`);
                                    } else {
                                        // Failed summoning
                                        gameLog.push(`AI failed to summon a Zombie.`);
                                    }

                                    renderBoard();
                                    updateGameLog();
                                    updateScoreDisplay();

                                    // Continue AI turn
                                    setTimeout(() => makeNextMove(), 1200);
                                },
                                true, // Automated mode
                                false // showOverlay
                            );
                            return; // Exit to wait for coin toss callback
                        } else if (action.type === 'summon' && special === 'summonNecromancerSpectre') {
                            // AI attempts to summon Spectre (Necromancer)
                            const necromancerRow = from[0], necromancerCol = from[1];
                            const summonRow = pos[0], summonCol = pos[1];

                            // Deduct cost before coin toss
                            movesLeft -= cost;
                            movedPieces.add(`${necromancerRow},${necromancerCol}`);

                            // Show automated coin toss popup for AI
                            performCoinToss(
                                'Summon Spectre',
                                'AI is attempting to summon a Spectre...',
                                (success) => {
                                    if (success) {
                                        // Successfully summoned Spectre
                                        const spectrePiece = createSpectrePiece('B');
                                        board[summonRow][summonCol] = spectrePiece;
                                        spectresSummoned['B'] = (spectresSummoned['B'] || 0) + 1;

                                        gameLog.push(`AI summoned a Spectre at (${summonRow},${summonCol})!`);
                                    } else {
                                        // Failed summoning
                                        gameLog.push(`AI failed to summon a Spectre.`);
                                    }

                                    renderBoard();
                                    updateGameLog();
                                    updateScoreDisplay();

                                    // Continue AI turn
                                    setTimeout(() => makeNextMove(), 1200);
                                }, 
                                true, // Automated mode
                                false // showOverlay
                            );
                            return; // Exit to wait for coin toss callback
                        } else if (action.type === 'energyBlast') {
                            const scheduleNextMove = () => setTimeout(() => makeNextMove(), 1200);
                            if (!from || !direction) {
                                scheduleNextMove();
                                return;
                            }
                            const [casterRow, casterCol] = from;
                            const casterPiece = board[casterRow] && board[casterRow][casterCol];
                            if (!casterPiece || casterPiece.player !== 'B' || !isSpellVariant() || !isSpellCasterPiece(casterPiece)) {
                                scheduleNextMove();
                                return;
                            }
                            const uses = energyBlastUsage.get(casterPiece) || 0;
                            if (uses >= 2) {
                                scheduleNextMove();
                                return;
                            }
                            const spellCost = uses === 0 ? 2 : 3;
                            if (movesLeft < spellCost) {
                                scheduleNextMove();
                                return;
                            }
                            const prepaidCost = Math.min(2, spellCost);
                            movesLeft -= prepaidCost;
                            updateStatus();
                            updateEndTurnButton();
                            gameLog.push('AI is channeling Energy Blast (2 move points spent to attempt spellcasting).');
                            updateGameLog();
                            coinTossSpecialEffect = 'energy-blast';
                            performCoinToss(
                                'Energy Blast',
                                'AI is attempting to channel spell energy...',
                                (success) => {
                                    if (!success) {
                                        gameLog.push('AI failed to channel Energy Blast.');
                                        updateGameLog();
                                        scheduleNextMove();
                                        return;
                                    }
                                    const currentPiece = board[casterRow]?.[casterCol];
                                    if (!currentPiece || currentPiece.player !== 'B') {
                                        removeEnergyBlastGlow();
                                        scheduleNextMove();
                                        return;
                                    }
                                    activeEnergyBlastCost = { row: casterRow, col: casterCol, prepaid: prepaidCost, cost: spellCost };
                                    applyEnergyBlastGlow();
                                    gameLog.push('AI successfully channeled Energy Blast!');
                                    updateGameLog();
                                    pendingAiEnergyBlastResume = () => setTimeout(() => makeNextMove(), 1200);
                                    performEnergyBlast(casterRow, casterCol, direction);
                                },
                                true,
                                false
                            );
                            return;
                        } else if (action.type === 'sacrifice') {
                            if (!from) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            const [sRow, sCol] = from;
                            const caster = board[sRow]?.[sCol];
                            if (!caster || caster.player !== 'B' || !isSpellCasterPiece(caster) || movesLeft < cost) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            if (sacrificeAttemptedPieces.has(caster)) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            sacrificeAttemptedPieces.add(caster);
                            performCoinToss(
                                'Sacrifice',
                                'AI is attempting Sacrifice...',
                                (success) => {
                                    if (!success) {
                                        gameLog.push('AI failed the Sacrifice coin flip.');
                                        updateGameLog();
                                        setTimeout(() => makeNextMove(), 1200);
                                        return;
                                    }
                                    if (movesLeft < cost) {
                                        gameLog.push('AI lacked the move points to complete Sacrifice.');
                                        updateGameLog();
                                        setTimeout(() => makeNextMove(), 1200);
                                        return;
                                    }
                                    executeSacrifice(sRow, sCol, {
                                        onComplete: () => setTimeout(() => makeNextMove(), 1200)
                                    });
                                },
                                true,
                                false
                            );
                            return;
                        } else if (action.type === 'summon' && special === 'kingSummon') {
                            const kingRow = from[0], kingCol = from[1];
                            const kingPiece = board[kingRow]?.[kingCol];
                            if (!kingPiece || kingPiece.player !== 'B' || kingPiece.type !== 'King') {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            const summonRow = pos[0], summonCol = pos[1];
                            const summonType = action.summonType || 'Pistolier';
                            movesLeft -= cost;
                            const attemptLabel = summonType === 'Pistolier' ? 'Summon Pistolier' : 'Summon Fusilier';
                            performCoinToss(
                                attemptLabel,
                                `AI attempts to summon a ${summonType}...`,
                                (success) => {
                                    if (success) {
                                        if (!board[summonRow][summonCol]) {
                                            board[summonRow][summonCol] = { type: summonType, player: 'B', facing: null };
                                            if (summonType === 'Pistolier') {
                                                pistoliersSummoned['B'] = (pistoliersSummoned['B'] || 0) + 1;
                                            } else {
                                                fusiliersSummoned['B'] = (fusiliersSummoned['B'] || 0) + 1;
                                            }
                                            gameStats.summonCount['B']++;
                                            gameLog.push(`${getOpponentDisplayName()} summoned a ${summonType} at (${summonRow},${summonCol}).`);
                                        } else {
                                            gameLog.push(`${getOpponentDisplayName()}'s ${summonType} summon succeeded but the square was occupied.`);
                                        }
                                    } else {
                                        gameLog.push(`${getOpponentDisplayName()} failed to summon a ${summonType}.`);
                                    }
                                    updateGameLog();
                                    lastAction = { move: true };
                                    movedPieces.add(`${kingRow},${kingCol}`);
                                    setTimeout(() => makeNextMove(), 1200);
                                },
                                true,
                                false
                            );
                            return;
                        } else if (action.type === 'summon' && special === 'championSummon') {
                            if (!from || !pos) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            const championRow = from[0];
                            const championCol = from[1];
                            const championPiece = board[championRow]?.[championCol];
                            if (!championPiece || championPiece.player !== 'B' || championPiece.type !== 'Champion') {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            if (movesLeft < cost) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            const summonRow = pos[0];
                            const summonCol = pos[1];
                            const summonType = action.summonType || 'Necromancer';
                            movesLeft -= cost;
                            performCoinToss(
                                'Champion Summon',
                                `AI attempts to summon a ${summonType}...`,
                                (success) => {
                                    if (success) {
                                        if (!board[summonRow][summonCol]) {
                                            if (summonType === 'Huntsman') {
                                                board[summonRow][summonCol] = { type: 'Huntsman', player: 'B' };
                                                recordHuntsmanSpawn('B');
                                                gameLog.push(`${getOpponentDisplayName()} summoned a Huntsman at (${summonRow},${summonCol}).`);
                                            } else {
                                                const necromancerPiece = { type: 'Necromancer', player: 'B', facing: null };
                                                board[summonRow][summonCol] = necromancerPiece;
                                                necromancersSummoned['B'] = (necromancersSummoned['B'] || 0) + 1;
                                                necromancerTeleportCounts.set(necromancerPiece, 0);
                                                setNecromancerShotCooldown(necromancerPiece, 0);
                                                gameLog.push(`${getOpponentDisplayName()} summoned a Necromancer at (${summonRow},${summonCol}).`);
                                            }
                                            gameStats.summonCount['B']++;
                                        } else {
                                            gameLog.push(`AI's ${summonType} summon succeeded but the chosen square was blocked.`);
                                        }
                                    } else {
                                        gameLog.push(`AI failed to summon a ${summonType}.`);
                                    }
                                    updateGameLog();
                                    lastAction = { move: true };
                                    movedPieces.add(`${championRow},${championCol}`);
                                    setTimeout(() => makeNextMove(), 1200);
                                },
                                true,
                                false
                            );
                            return;
                        } else if (action.type === 'huntsmanBurst') {
                            if (!from) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            const [burstRow, burstCol] = from;
                            const huntsman = board[burstRow]?.[burstCol];
                            if (!huntsman || huntsman.player !== 'B' || huntsman.type !== 'Huntsman' || !isSpellVariant()) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            if (movesLeft < cost || pendingHuntsmanBurst) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            highlightSquares = [from];
                            movesLeft -= cost;
                            updateStatus();
                            updateEndTurnButton();
                            beginHuntsmanBurstSequence(burstRow, burstCol, 'B', {
                                automated: true,
                                onComplete: () => setTimeout(() => makeNextMove(), 1200)
                            });
                            return;
                        } else if (action.type === 'move') {
                            // Check if capturing a Spectre - requires coin toss
                            const targetPiece = board[pos[0]][pos[1]];
                            const attackingPiece = board[from[0]][from[1]];
                            const isCapturingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                            const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';

                            if (isCapturingSpectre && !captureExempt) {
                                // Deduct cost before coin toss
                                movesLeft -= cost;

                                // Show automated coin toss popup for AI
                                performCoinToss(
                                    'Capture Spectre',
                                    'AI is attempting to capture the Spectre...',
                                    (success) => {
                                        let moveResult = null;
                                        if (success) {
                                            moveResult = movePiece(from[0], from[1], pos[0], pos[1], jump);
                                            gameLog.push(`AI successfully captured the Spectre!`);
                                        } else {
                                            gameLog.push(`AI failed to capture the Spectre.`);
                                        }

                                        if (special === 'charge') {
                                            cavalryChargeUsed['B'] = true;
                                        }
                                        if (special === 'inferno') {
                                            performInfernoCapture(pos[0], pos[1], 'B');
                                            dragonInfernoUsed['B'] = true;
                                        }
                                        if (special === 'strafe') {
                                            const piece = board[pos[0]][pos[1]];
                                            if (piece && piece.type === 'Wizard') {
                                                wizardStrafeUsed['B']++;
                                            } else if (piece && piece.type === 'Dragon') {
                                                dragonStrafeUsed['B']++;
                                            }
                                        }
                                        if (special === 'ballistaDoubleTime') {
                                            ballistaDoubleTimeUsed['B']++;
                                        }
                                        if (special === 'elephantryCharge') {
                                            const pieceKey = `${from[0]},${from[1]},B`;
                                            elephantryChargeUsed.add(pieceKey);
                                            gameLog.push(`AI used Elephantry Charge from (${from[0]},${from[1]}) to (${pos[0]},${pos[1]})`);
                                        }
                                        movedPieces.add(`${pos[0]},${pos[1]}`);

                                        renderBoard();
                                        updateGameLog();

                                        // Check if mercenary coin flip is needed
                                        if (success && moveResult?.mercenaryFlipNeeded) {
                                            const mercPiece = moveResult.mercenaryPiece;
                                            const mercPos = moveResult.mercenaryPos;

                                            handleMercenaryCoinFlip(mercPiece.player, mercPiece, mercPos.row, mercPos.col, (bonusTurnGranted) => {
                                                // Continue AI turn after coin flip
                                                setTimeout(() => makeNextMove(), 1200);
                                            });
                                            return;
                                        }

                                        // Continue AI turn
                                        setTimeout(() => makeNextMove(), 1200);
                                    },
                                    true, // Automated mode
                                    false // showOverlay
                                );
                                return; // Exit to wait for coin toss callback
                            } else {
                                // Normal move/capture
                                const moveResult = movePiece(from[0], from[1], pos[0], pos[1], jump);

                                if (special === 'charge') {
                                    cavalryChargeUsed['B'] = true;
                                }
                                // Handle AI Inferno
                                if (special === 'inferno') {
                                    performInfernoCapture(pos[0], pos[1], 'B');
                                    dragonInfernoUsed['B'] = true;
                                }
                                // Handle AI Strafe
                                if (special === 'strafe') {
                                    const piece = board[pos[0]][pos[1]]; // Piece is now at destination
                                    if (piece && piece.type === 'Wizard') {
                                        wizardStrafeUsed['B']++;
                                    } else if (piece && piece.type === 'Dragon') {
                                        dragonStrafeUsed['B']++;
                                    }
                                }
                                if (special === 'ballistaDoubleTime') {
                                    ballistaDoubleTimeUsed['B']++;
                                }
                                if (special === 'elephantryCharge') {
                                    const pieceKey = `${from[0]},${from[1]},B`;
                                    elephantryChargeUsed.add(pieceKey);
                                    gameLog.push(`AI used Elephantry Charge from (${from[0]},${from[1]}) to (${pos[0]},${pos[1]})`);
                                }
                                movedPieces.add(`${pos[0]},${pos[1]}`);

                                // Check if mercenary coin flip is needed
                                if (moveResult?.mercenaryFlipNeeded) {
                                    const mercPiece = moveResult.mercenaryPiece;
                                    const mercPos = moveResult.mercenaryPos;

                                    handleMercenaryCoinFlip(mercPiece.player, mercPiece, mercPos.row, mercPos.col, (bonusTurnGranted) => {
                                        // Continue AI turn after coin flip
                                        setTimeout(() => makeNextMove(), 1200);
                                    });
                                    return; // Exit to wait for coin flip callback
                                }
                            }
                        } else if (action.type === 'shoot') {
                            // Check if shooting a Spectre - requires coin toss
                        const targetPiece = board[pos[0]][pos[1]];
                        const attackingPiece = board[from[0]][from[1]];
                        const isShootingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                        const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';
                        const autoCrackShot = special === 'fusilierCrackShotAuto';
                        const usingCrackShot = attackingPiece && attackingPiece.type === 'Fusilier' && fusilierCrackShotActive === attackingPiece;
                        const isNecromancerShot = attackingPiece && attackingPiece.type === 'Necromancer' && special === 'necromancerShoot';

                        if (isShootingSpectre && !captureExempt) {
                            gameLog.push('AI cannot shoot Spectres. Target ignored.');
                            updateGameLog();
                            setTimeout(() => makeNextMove(), 400);
                            return;
                        } else if (autoCrackShot) {
                                movesLeft -= cost;

                                const pieceKey = `${from[0]},${from[1]},B`;
                                if (!(pieceKey in fusilierCrackShotCount)) {
                                    fusilierCrackShotCount[pieceKey] = 3;
                                }
                                if (fusilierCrackShotCount[pieceKey] > 0) {
                                    fusilierCrackShotCount[pieceKey]--;
                                }

                                performCoinToss(
                                    'Crack Shot',
                                    'AI is attempting a Crack Shot...',
                                    (success) => {
                                        fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                        fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);

                                        if (success) {
                                            shootPiece(from[0], from[1], pos[0], pos[1]);
                                            gameLog.push(`AI Fusilier Crack Shot hit!`);
                                        } else {
                                            gameLog.push(`AI Fusilier Crack Shot missed.`);
                                        }

                                        renderBoard();
                                        updateGameLog();

                                        // Continue AI turn
                                        setTimeout(() => makeNextMove(), 1200);
                                    },
                                    true, // Automated mode
                                    false // showOverlay
                                );
                                return;
                            } else if (usingCrackShot) {
                                movesLeft -= cost;

                                performCoinToss(
                                    'Crack Shot',
                                    'AI is attempting a Crack Shot...',
                                    (success) => {
                                        fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                        fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);
                                        fusilierCrackShotActive = null;

                                        if (success) {
                                            shootPiece(from[0], from[1], pos[0], pos[1]);
                                            gameLog.push(`AI Fusilier Crack Shot hit!`);
                                        } else {
                                            gameLog.push(`AI Fusilier Crack Shot missed.`);
                                        }

                                        renderBoard();
                                        updateGameLog();

                                        // Continue AI turn
                                        setTimeout(() => makeNextMove(), 1200);
                                    },
                                    true, // Automated mode
                                    false // showOverlay
                                );
                                return;
                            } else {
                                // Normal shoot
                                shootPiece(from[0], from[1], pos[0], pos[1]);
                            }

                            if (special === 'kingShot') {
                                markKingShotUsed(attackingPiece);
                            }

                            if (special === 'archerDiag2') {
                                archerDiag2ShootUsed['B']++;
                            }
                            if (isNecromancerShot) {
                                setNecromancerShotCooldown(attackingPiece, 2);
                            }
                        } else if (action.type === 'activate' && special === 'ballistaRange') {
                            // Extend range for Ballista this turn
                            ballistaRangeBoostActive['B'] = true;
                            ballistaRangeBoostUsedThisTurn['B'] = true;
                            gameLog.push(`AI activated Ballista Extend Range (+1 range this round)`);
                        } else if (action.type === 'swap') {
                            const kingRow = from[0], kingCol = from[1];
                            const guardRow = pos[0], guardCol = pos[1];
                            const kingPiece = board[kingRow][kingCol];
                            const guardPiece = board[guardRow][guardCol];
                            board[guardRow][guardCol] = kingPiece;
                            board[kingRow][kingCol] = guardPiece;
                            kingSpecialUsed['B'] = true;
                            gameLog.push(`AI used Guard of Honour to swap King and Guard at (${kingRow},${kingCol}) and (${guardRow},${guardCol})`);
                            checkSupremacy('B');
                            movedPieces.add(`${guardRow},${guardCol}`);
                        } else if (action.type === 'teleport') {
                            const wizardRow = from[0], wizardCol = from[1];
                            const newRow = pos[0], newCol = pos[1];
                            const teleportPiece = board[wizardRow][wizardCol];
                            const abilityLabel = `${teleportPiece.type} Teleport`;
                            const result = teleportOntoSquare(wizardRow, wizardCol, newRow, newCol, 'B', abilityLabel);
                            if (!result.success) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            if (teleportPiece.type === 'Wizard') {
                                wizardTeleportUsed['B']++;
                                gameLog.push(`AI teleported Wizard from (${wizardRow},${wizardCol}) to (${newRow},${newCol})`);
                            } else if (teleportPiece.type === 'Necromancer') {
                                incrementNecromancerTeleportCount(teleportPiece);
                                gameLog.push(`AI teleported Necromancer from (${wizardRow},${wizardCol}) to (${newRow},${newCol})`);
                            } else {
                                gameLog.push(`AI teleported ${teleportPiece.type} from (${wizardRow},${wizardCol}) to (${newRow},${newCol})`);
                            }
                            movedPieces.add(`${newRow},${newCol}`);
                        } else if (action.type === 'teleportSwap') {
                            const playerWizardRow = from[0], playerWizardCol = from[1];
                            const opponentWizardRow = pos[0], opponentWizardCol = pos[1];
                            const playerWizard = board[playerWizardRow][playerWizardCol];
                            const opponentWizard = board[opponentWizardRow][opponentWizardCol];
                            board[opponentWizardRow][opponentWizardCol] = playerWizard;
                            board[playerWizardRow][playerWizardCol] = opponentWizard;
                            wizardTeleportSwapUsed['B'] = true;
                            gameLog.push(`AI used Teleport Swap to swap Wizard at (${playerWizardRow},${playerWizardCol}) with opponent's Wizard at (${opponentWizardRow},${opponentWizardCol})`);
                            movedPieces.add(`${opponentWizardRow},${opponentWizardCol}`);
                        }
                        movesLeft -= cost;
                        movedPieces.add(`${from[0]},${from[1]}`);
                    } else if (action.type === 'turn') {
                        const { pos, facing, cost } = action;
                        highlightSquares = [pos];
                        turnPiece(pos[0], pos[1], facing);
                        movesLeft -= cost;
                        movedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (action.type === 'turnAndMove') {
                        const { pos, facing, move, cost, jump } = action;
                        highlightSquares = [pos, move];
                        turnPiece(pos[0], pos[1], facing);
                        const moveResult = movePiece(pos[0], pos[1], move[0], move[1], jump);
                        movesLeft -= cost;
                        movedPieces.add(`${pos[0]},${pos[1]}`);
                        movedPieces.add(`${move[0]},${move[1]}`);

                        // Check if mercenary coin flip is needed
                        if (moveResult?.mercenaryFlipNeeded) {
                            const mercPiece = moveResult.mercenaryPiece;
                            const mercPos = moveResult.mercenaryPos;

                            handleMercenaryCoinFlip(mercPiece.player, mercPiece, mercPos.row, mercPos.col, (bonusTurnGranted) => {
                                // Continue AI turn after coin flip
                                setTimeout(() => makeNextMove(), 1200);
                            });
                            return; // Exit to wait for coin flip callback
                        }
                    } else if (action.type === 'turnAndShoot') {
                        const { pos, facing, shoot, cost } = action;
                        highlightSquares = [pos, shoot];
                        turnPiece(pos[0], pos[1], facing);
                        shootPiece(pos[0], pos[1], shoot[0], shoot[1]);
                        movesLeft -= cost;
                        movedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (action.type === 'archerMoveDiagShoot') {
                        const { from, move, shoot, cost } = action;
                        highlightSquares = [from, move, shoot];
                        const moveResult = movePiece(from[0], from[1], move[0], move[1]);
                        shootPiece(move[0], move[1], shoot[0], shoot[1]);
                        archerMoveDiagShootUsed['B']++;
                        movesLeft -= cost;
                        movedPieces.add(`${move[0]},${move[1]}`);

                        // Check if mercenary coin flip is needed
                        if (moveResult?.mercenaryFlipNeeded) {
                            const mercPiece = moveResult.mercenaryPiece;
                            const mercPos = moveResult.mercenaryPos;

                            handleMercenaryCoinFlip(mercPiece.player, mercPiece, mercPos.row, mercPos.col, (bonusTurnGranted) => {
                                // Continue AI turn after coin flip
                                setTimeout(() => makeNextMove(), 1200);
                            });
                            return; // Exit to wait for coin flip callback
                        }
                    }

                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    
                    // Shorter delays for faster AI play
                    setTimeout(() => {
                        try {
                            highlightSquares = [];
                            renderBoard();
                            setTimeout(() => {
                                try {
                                    makeNextMove();
                                } catch (err) {
                                    console.error('AI move loop failed:', err);
                                    completeAiTurn({ reason: 'AI move error. Player resumes round.' });
                                }
                            }, 1000); // Make next move
                        } catch (err) {
                            console.error('AI post-move cleanup failed:', err);
                            completeAiTurn({ reason: 'AI move error. Player resumes round.' });
                        }
                    }, 1200); // Highlight duration
                } catch (err) {
                    console.error('AI move evaluation failed:', err);
                    completeAiTurn({ reason: 'AI move error. Player resumes round.' });
                }
            }
            setTimeout(() => makeNextMove(), 1500); // Start after brief delay for player to see board state
        }

        function resetGame() {
            // Initialize all game state variables first
            gameOver = false; // Reset game over flag
            currentPlayer = 'W'; // Will be set by coin toss
            roundCount = 1; // Reset round counter
            playerRoundNumber = 0; // Reset player round counter
            aiRoundNumber = 0; // Reset AI round counter
            gameRound = 1; // Reset game round counter
            firstPlayer = null; // Reset first player tracker
            selectedPiece = null;
            validMoves = [];
            movedPieces.clear();
            reinforcementPending = null;
            aiPending = false;
            stopGameTimer();
            stopTurnTimer();
            aiTurnTimeoutForced = false;
            movesLeft = 0;
            initialMovesLeft = 0;
            capturedPieces = { 'W': [], 'B': [] };
            championCaptured = { 'W': false, 'B': false };
            championsOnBackRow = { 'W': [], 'B': [] };
            scores = { 'W': 0, 'B': 0 };
            firstMoves.clear();
            gameLog = [];
            isFirstPlayerTurn = true;
            lastAction = null;
            turnAndShootMode = false;
            turnAndMoveMode = false;
            guardOfHonourMode = false;
            teleportMode = false;
            teleportSwapMode = false;
            chargeMode = false;
            infernoMode = false;
            strafeMode = false;
            summonSpectreMode = false;
            archerMoveDiagMode = false;
            archerDiagShootSelectMode = false;
            archerDiag2ShootMode = false;
            elephantryChargeMode = false;
            elephantryExtendedRangeActive = false;
            fusilierCrackShotActive = null;
            elephantryMoveShootMode = false;
            elephantryMoveShootPosition = null;
            pistolierMoveShootMode = false;
            pistolierMoveShootPosition = null;
            archerMoveDiagStart = null;
            highlightSquares = [];
            pendingSpellAction = null;
            energyBlastUsage = new Map();
            energyBlastUses = { 'W': 0, 'B': 0 };
            sacrificeAttemptedPieces = new Set();
            energyBlastFlipContext = null;
            pendingEnergyBlast = null;
            activeEnergyBlastCost = null;
            energyBlastGlowActive = false;
            energyBlastResidualSquares = new Map();
            energyBlastFlipPauseState = null;
            coinTossEnergyBlastMode = null;
            coinTossSpecialEffect = null;
            pendingAiEnergyBlastResume = null;
            pendingWarcryCelebrations = [];
            captureEffectActiveUntil = 0;
            if (warcryPopupTimeoutId) {
                clearTimeout(warcryPopupTimeoutId);
                warcryPopupTimeoutId = null;
            }
            protectionUsed = { 'W': false, 'B': false };
            pendingProtection = null;
            kingSpecialUsed = { 'W': false, 'B': false };
            wizardTeleportUsed = { 'W': 0, 'B': 0 };
            wizardTeleportSwapUsed = { 'W': false, 'B': false };
            cavalryChargeUsed = { 'W': false, 'B': false };
            dragonInfernoUsed = { 'W': false, 'B': false };
            wizardStrafeUsed = { 'W': 0, 'B': 0 };
            dragonStrafeUsed = { 'W': 0, 'B': 0 };
            fusilierShotLastTurn = { 'W': new Set(), 'B': new Set() };
            fusilierShotThisTurn = { 'W': new Set(), 'B': new Set() };
            mercenaryBonusTurnUsed = { 'W': new Set(), 'B': new Set() };
            mercenaryBonusTurnCount = { 'W': 0, 'B': 0 };
            mercenaryBonusTurnActive = false;
            mercenaryBonusTurnPiece = null;
            spectresSummoned = { 'W': 0, 'B': 0 };
            wizardSummonedThisTurn = { 'W': false, 'B': false };
            wizardCannotMoveNextTurn = { 'W': new Set(), 'B': new Set() };
            necromancersSummoned = { 'W': 0, 'B': 0 };
            huntsmenSummoned = { 'W': 0, 'B': 0 };
            huntsmenOnBoard = { 'W': 0, 'B': 0 };
            huntsmanBurstMode = null;
            pendingHuntsmanBurst = null;
            huntsmanBurstPauseState = null;
            kingShotMode = null;
            kingEvadeMode = null;
            moralBoostUses = { 'W': 0, 'B': 0 };
            kingShotUsed = { 'W': false, 'B': false };
            kingEvadeUsed = { 'W': false, 'B': false };
            resetKingShotFlags();
            championSummonMode = null;
            necromancerSummonMode = null;
            necromancerTeleportCounts = new Map();
            necromancerShootCooldown = new Map();
            zombiesSummoned = { 'W': 0, 'B': 0 };
            zombiePendingAdvanceQueue = [];
            zombieAutoAdvanceInProgress = false;
            clearZombieCoinAnimations();
            if (zombieAdvanceTimer) {
                clearTimeout(zombieAdvanceTimer);
                zombieAdvanceTimer = null;
            }
            zombieConversions = { 'W': 0, 'B': 0 };
            archerMoveDiagShootUsed = { 'W': 0, 'B': 0 };
            archerDiag2ShootUsed = { 'W': 0, 'B': 0 };
            ballistaRangeBoostActive = { 'W': false, 'B': false };
            ballistaRangeBoostUsedThisTurn = { 'W': false, 'B': false };
            ballistaDoubleTimeUsed = { 'W': 0, 'B': 0 };
            elephantryChargeUsed = new Set();
            elephantryExtendedRangeShotsRemaining = {};
            capturedSquares = [];
            roundScoreGain = { 'W': 0, 'B': 0 };
            roundLosses = { 'W': {}, 'B': {} };
            nextRoundModifier = { 'W': 0, 'B': 0 };
            reinforcementTotals = { 'W': 0, 'B': 0 };
            infantryReinforcements = { 'W': 0, 'B': 0 };
            truceAttempts = 0;
            truceDeclinedTurns = 0;
            truceEligible = true;
            trucePlayerVote = null;
            truceAIVote = null;
            gameTimeRemaining = GAME_TIME_OPTIONS[selectedGameTimerKey];
            playerTurnTimeRemaining = TURN_TIME_OPTIONS[selectedTurnTimerKey];
            aiTurnTimeRemaining = TURN_TIME_OPTIONS[selectedTurnTimerKey];
            updateTimerDisplay();
            removeEnergyBlastGlow();

            initBoard();
            showPieceInfo(null);
            const reinforceModal = document.getElementById('reinforce-modal');
            if (reinforceModal) reinforceModal.style.display = 'none';
            const turnModal = document.getElementById('turn-modal');
            if (turnModal) turnModal.style.display = 'none';
            const turnMoveModal = document.getElementById('turn-move-modal');
            if (turnMoveModal) turnMoveModal.style.display = 'none';
            const turnShootModal = document.getElementById('turn-shoot-modal');
            if (turnShootModal) turnShootModal.style.display = 'none';

            // Perform coin toss to determine starting player
            performCoinToss(
                'First Round',
                'Determining who goes first...',
                (playerWins) => {
                    if (playerWins) {
                        // Player (white) goes first
                        currentPlayer = 'W';
                        firstPlayer = 'W'; // Track who went first for round counting
                        gameLog.push('Player won the coin toss and goes first!');

                        const baseMoves = calculateBaseMoves('W');
                        movesLeft = baseMoves;
                        initialMovesLeft = baseMoves;

                        // Render board and update UI after coin toss
                        renderBoard();
                        updateScoreDisplay();
                        updateStatus();
                        updateGameLog();
                        updateCapturedPiecesDisplay();
                        updateEndTurnButton();

                        // Start timer after everything is set up
                        startGameTimer();
                        const startReady = applyStartTurnModifiers('W', baseMoves);

                        if (!startReady) {
                            checkGameOver();
                            setTimeout(() => triggerAiTurn(), 0);
                        }
                    } else {
                        // AI (black) goes first
                        currentPlayer = 'B';
                        firstPlayer = 'B'; // Track who went first for round counting
                        gameLog.push(`${getOpponentDisplayName()} won the coin toss and goes first!`);

                        const baseMoves = calculateBaseMoves('B');
                        movesLeft = baseMoves;
                        initialMovesLeft = baseMoves;

                        // Render board and update UI after coin toss
                        renderBoard();
                        updateScoreDisplay();
                        updateStatus();
                        updateGameLog();
                        updateCapturedPiecesDisplay();
                        updateEndTurnButton();

                        // Start timer after everything is set up
                        startGameTimer();

                        // Trigger AI turn after a brief delay
                        setTimeout(() => {
                            aiTurn();
                        }, 1500);
                    }
                }
            );
        }

        function updateStatus() {
            document.getElementById('status').textContent = `${currentPlayer === 'W' ? "Player" : "AI"}'s turn: ${movesLeft} moves remaining`;

            // Remove warcry active background when bonus moves are spent
            if (movesLeft <= baseMovesThisTurn) {
                removeWarcryActiveBackground();
            }

            // Explicitly check if round should end after status update
            if (!gamePaused && currentPlayer === 'W' && movesLeft <= 0 && !reinforcementPending && !aiPending) {
                setTimeout(() => triggerAiTurn(), 0);
            }
        }

        function endGame(winner, reason = '') {
            // Immediately set game over flag to prevent any further actions
            gameOver = true;

            stopGameTimer();
            stopTurnTimer();
            playerTurnTimeRemaining = 0;
            aiTurnTimeRemaining = 0;
            updateTimerDisplay();

            // Calculate game duration
            if (gameStats.gameStartTime !== null) {
                gameStats.gameDuration = Math.floor((Date.now() - gameStats.gameStartTime) / 1000);
            }

            // Prepare winner message and title
            let winnerText, reasonText, modalTitle;
            if (winner === 'draw') {
                winnerText = 'Draw!';
                modalTitle = 'Game Complete';

                // Create simplified draw reason text
                if (reason === 'Match') {
                    reasonText = 'Match';
                } else if (reason === 'Truce') {
                    reasonText = 'Truce';
                } else if (reason === 'Game timer expired.') {
                    reasonText = 'Supremacy';
                } else {
                    reasonText = reason || 'Draw';
                }
            } else {
                const winnerLabel = winner === 'W' ? 'Player' : getOpponentDisplayName();
                const loserLabel = winner === 'W' ? getOpponentDisplayName() : 'Player';
                winnerText = `${winnerLabel} Wins!`;

                // Set modal title based on whether player won or lost
                if (winner === 'W') {
                    modalTitle = 'Victory Achieved';
                } else {
                    modalTitle = 'All is Lost';
                }

                // Create simplified victory method text
                let victoryMethod = '';
                if (reason === 'Relentless') {
                    victoryMethod = 'Relentless';
                } else if (reason === 'Match') {
                    victoryMethod = 'Match';
                } else if (reason === 'Truce') {
                    victoryMethod = 'Truce';
                } else if (reason === 'Game timer expired.') {
                    victoryMethod = 'Supremacy';
                } else if (reason) {
                    victoryMethod = reason;
                } else {
                    // Default: assume it was Regicide (King captured)
                    victoryMethod = 'Regicide';
                }

                reasonText = `${winnerLabel} was victorious by ${victoryMethod}`;
            }

            // Add to game log
            const scoreSummary = `Final Score - Player: ${scores['W']}, ${getOpponentDisplayName()}: ${scores['B']}`;
            const message = `${winnerText} ${reasonText} ${scoreSummary}`;
            gameLog.push(message);
            updateGameLog();

            // Populate stats modal
            document.getElementById('game-stats-title').textContent = modalTitle;
            document.getElementById('stats-reason').textContent = reasonText;

            // Set player names in columns
            document.getElementById('stats-player-name').textContent = 'Player';
            document.getElementById('stats-ai-name').textContent = getOpponentDisplayName();

            // Populate player stats
            document.getElementById('stats-player-score').textContent = scores['W'];
            document.getElementById('stats-player-warcry').textContent = gameStats.warcryBonusCount['W'];
            document.getElementById('stats-player-despair').textContent = gameStats.despairPenaltyCount['W'];
            document.getElementById('stats-player-captures').textContent = gameStats.mostCapturesInRound['W'];
            document.getElementById('stats-player-high-score').textContent = gameStats.highestScoreInRound['W'];
            document.getElementById('stats-player-summons').textContent = gameStats.summonCount['W'];
            document.getElementById('stats-player-reinforcements').textContent = gameStats.reinforcementCount['W'];

            // Populate AI stats
            document.getElementById('stats-ai-score').textContent = scores['B'];
            document.getElementById('stats-ai-warcry').textContent = gameStats.warcryBonusCount['B'];
            document.getElementById('stats-ai-despair').textContent = gameStats.despairPenaltyCount['B'];
            document.getElementById('stats-ai-captures').textContent = gameStats.mostCapturesInRound['B'];
            document.getElementById('stats-ai-high-score').textContent = gameStats.highestScoreInRound['B'];
            document.getElementById('stats-ai-summons').textContent = gameStats.summonCount['B'];
            document.getElementById('stats-ai-reinforcements').textContent = gameStats.reinforcementCount['B'];

            // Format and display game info
            const minutes = Math.floor(gameStats.gameDuration / 60);
            const seconds = gameStats.gameDuration % 60;
            const durationStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('stats-turn-count').textContent = `Total Rounds: ${roundCount}`;
            document.getElementById('stats-duration').textContent = `Game Duration: ${durationStr}`;

            // Show stats modal
            document.getElementById('game-stats-modal').style.display = 'block';
            const endgameOverlay = document.getElementById('endgame-overlay');
            if (endgameOverlay) {
                endgameOverlay.style.display = 'block';
            }

            // Reset game pause state
            gamePaused = false;

            // Reset mercenary bonus turn state
            mercenaryBonusTurnActive = false;
            mercenaryBonusTurnPiece = null;

            // Clear AI pending and other active game states
            aiPending = false;
            reinforcementPending = null;
        }

        function checkGameOver() {
            // First check for Match (only kings remaining)
            if (checkForMatch()) return;

            let wKing = false, bKing = false;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] && board[r][c].type === 'King') {
                        if (board[r][c].player === 'W') wKing = true;
                        else bKing = true;
                    }
                }
            }
            if (!wKing) endGame('B');
            else if (!bKing) endGame('W');
        }

        function updateEndTurnButton() {
            const endTurnButton = document.getElementById('end-turn-button');
            if (!endTurnButton) return;
            const noMovesSpent = movesLeft >= initialMovesLeft;
            const selectionActive = !!selectedPiece;
            endTurnButton.disabled = currentPlayer !== 'W' || noMovesSpent || selectionActive;
            // Update hint button visibility
            updateHintButton();
            // Safety net
            ensureAITurnIfNeeded();
        }

        function updateHintButton() {
            const hintButton = document.getElementById('hint-button');
            if (hintButton) {
                // Show hint button only if hint mode is enabled and it's the player's turn
                if (hintModeEnabled && currentPlayer === 'W' && movesLeft > 0) {
                    hintButton.style.display = 'inline-block';
                } else {
                    hintButton.style.display = 'none';
                }
            }
        }

        function showHint() {
            if (!hintModeEnabled || currentPlayer !== 'W') return;

            // Use simplified AI logic to find a good move
            // Pass current movesLeft and movedPieces to the function
            const action = findSimpleAIAction('W', movesLeft, movedPieces);

            if (!action) {
                alert('No valid moves available.');
                return;
            }

            // Extract coordinates from action object
            const fromRow = action.from[0];
            const fromCol = action.from[1];
            const toRow = action.pos[0];
            const toCol = action.pos[1];

            // Clear any existing highlights
            document.querySelectorAll('.hint-highlight').forEach(cell => {
                cell.classList.remove('hint-highlight');
            });

            // Highlight the suggested move
            const piece = board[fromRow][fromCol];
            const fromCell = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
            const toCell = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);

            if (fromCell) {
                fromCell.classList.add('hint-highlight');
            }
            if (toCell) {
                toCell.classList.add('hint-highlight');
            }

            // Create hint message
            let hintMessage = `Move ${piece.type} from (${fromRow}, ${fromCol}) to (${toRow}, ${toCol})`;

            if (action.turnDirection) {
                hintMessage += ` and turn ${action.turnDirection}`;
            }
            if (action.shoot) {
                hintMessage += ` and shoot`;
            }
            if (action.special) {
                hintMessage += ` using ${action.special}`;
            }

            // Remove any existing hint popup
            const existingPopup = document.getElementById('hint-popup');
            if (existingPopup) {
                existingPopup.remove();
            }

            // Create a popup near the hinted piece
            const popup = document.createElement('div');
            popup.id = 'hint-popup';
            popup.textContent = hintMessage;
            popup.style.position = 'absolute';
            popup.style.backgroundColor = '#ffffcc';
            popup.style.border = '2px solid #ffcc00';
            popup.style.padding = '15px 20px';
            popup.style.borderRadius = '8px';
            popup.style.zIndex = '10000';
            popup.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.3)';
            popup.style.fontSize = '14px';
            popup.style.fontWeight = 'bold';
            popup.style.maxWidth = '300px';
            popup.style.wordWrap = 'break-word';

            // Position popup above the game board, centered
            const boardAnchor = getBoardAnchorRect();
            if (boardAnchor) {
                popup.style.left = `${boardAnchor.centerX}px`;
                popup.style.top = `${boardAnchor.top - 60}px`;
                popup.style.transform = 'translate(-50%, -100%)';
            } else {
                // Fallback to center of screen
                popup.style.left = '50%';
                popup.style.top = '20px';
                popup.style.transform = 'translateX(-50%)';
            }

            document.body.appendChild(popup);

            // Reset after 5 seconds
            setTimeout(() => {
                popup.remove();
                document.querySelectorAll('.hint-highlight').forEach(cell => {
                    cell.classList.remove('hint-highlight');
                });
            }, 5000);
        }

        function endTurn() {
            if (gameOver || gamePaused) return;
            if (movesLeft < initialMovesLeft) {
                // Reset player's per-turn Ballista boost on end turn
                ballistaRangeBoostActive['W'] = false;
                ballistaRangeBoostUsedThisTurn['W'] = false;
                // Remove warcry active background when turn ends
                removeWarcryActiveBackground();
                // Force turn transition
                movesLeft = 0;
                triggerAiTurn();
            }
        }

        function updateCapturedPiecesDisplay() {
            const playerCapturedDiv = document.getElementById('player-captured');
            const aiCapturedDiv = document.getElementById('ai-captured');
            playerCapturedDiv.innerHTML = getCapturedPiecesHTML('W');
            aiCapturedDiv.innerHTML = getCapturedPiecesHTML('B');
            const capturedContainer = document.getElementById('captured-pieces');
            constrainElementToBoardBounds(capturedContainer, getBoardAnchorRect());
        }

        function getCapturedPiecesHTML(player) {
            const pieces = capturedPieces[player];
            const counts = {};
            pieces.forEach(p => {
                counts[p.type] = (counts[p.type] || 0) + 1;
            });
            if (Object.keys(counts).length === 0) {
                return '<div class="captured-entry empty">None</div>';
            }
            return Object.entries(counts).map(([type, count]) => `
                <div class="captured-entry">
                    <span class="piece ${player === 'W' ? 'white' : 'black'}" style="color: ${player === 'W' ? 'black' : 'white'}">${pieceIcons[type]}</span>
                    <span class="captured-count">x${count}</span>
                </div>
            `).join('');
        }

        // New function to add capture effects
        function addCaptureEffect(row, col) {
            const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
            const body = document.body;
            if (square) {
                captureEffectActiveUntil = Math.max(captureEffectActiveUntil, Date.now() + CAPTURE_EFFECT_SETTLE_MS);
                if (pendingWarcryCelebrations.length) {
                    scheduleNextWarcryPopup();
                }
                // Add square background color change
                square.classList.add('capture-background');
                // Add square overlay
                const overlay = document.createElement('div');
                overlay.className = 'capture-overlay';
                square.appendChild(overlay);
                // Add game background color change only if not already applied
                if (!body.classList.contains('capture-game-background')) {
                    body.classList.add('capture-game-background');
                    // Remove game background after 2 seconds
                    setTimeout(() => {
                        body.classList.remove('capture-game-background');
                    }, 2000);
                }
                // Remove square effects after 2 seconds
                setTimeout(() => {
                    square.classList.remove('capture-background');
                    if (square.contains(overlay)) {
                        square.removeChild(overlay);
                    }
                }, 1780);
            }
        }

        document.addEventListener('click', (event) => {
            if (!event.target.closest('.variant-option')) {
                resetVariantSelections();
            }
            const howToModal = document.getElementById('how-to-play-modal');
            if (howToModal && howToModal.style.display === 'block') {
                const clickedInsideModal = event.target.closest('#how-to-play-modal');
                const clickedHowToButton = event.target.closest('.how-to-button');
                if (!clickedInsideModal && !clickedHowToButton) {
                    closeHowToPlay();
                }
            }
        });

        initializeBoardAnchoredModals();
        resetVariantSelections();
    </script>
</body>
</html>

