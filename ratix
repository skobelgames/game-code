<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ratix - Strategic Chess Variant</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #202020;
            margin: 0;
            padding: 20px;
        }
        #game-container {
            display: none;
            flex-direction: column;
            align-items: center;
        }
        #start-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #fff;
            padding: 20px;
            border: 2px solid #333;
            border-radius: 10px;
        }
        #start-menu h2 {
            margin-bottom: 20px;
        }
        #start-menu button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 5px;
            cursor: pointer;
        }
        /* Style for the selected difficulty button */
        #start-menu button.selected-diff {
            background-color: #4CAF50;
            color: white;
            border: 2px solid #4CAF50;
        }
        #start-menu button.selected-option {
            background-color: #4CAF50;
            color: white;
            border: 2px solid #4CAF50;
        }
        #start-menu button.selected-opponent {
            background-color: #4CAF50;
            color: white;
            border: 2px solid #4CAF50;
        }
        #start-menu button.selected-hint {
            background-color: #4CAF50;
            color: white;
            border: 2px solid #4CAF50;
        }
        .variant-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 15px;
            max-width: 300px;
            text-align: center;
        }
        .variant-option button.selected-variant {
            background-color: #4CAF50;
            color: #fff;
            border: 2px solid #4CAF50;
        }
        .variant-description {
            margin-top: 6px;
            font-size: 13px;
            line-height: 1.4;
            color: #333;
        }
        .variant-info {
            display: none;
            width: 100%;
            margin-top: 6px;
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: #f7f7f7;
            text-align: left;
        }
        .variant-info.visible {
            display: block;
            background-color: #f0f0f0;
        }
        .variant-difficulty {
            margin-top: 6px;
            font-size: 13px;
            color: #555;
        }
        #landing-header {
            text-align: center;
            color: #fff;
            margin-bottom: 20px;
        }
        #landing-header h1 {
            margin: 0;
            font-size: 48px;
            letter-spacing: 1px;
        }
        #landing-header p {
            margin: 6px 0 18px;
            font-size: 16px;
            color: #cccccc;
        }
        #landing-header .how-to-button {
            margin-bottom: 10px;
        }
        #landing-footer {
            margin-top: 20px;
            color: #cccccc;
            font-size: 14px;
            text-align: center;
        }
        .how-to-button {
            background-color: #fff;
            color: #000;
            border: 1px solid #333;
            border-radius: 5px;
            transition: background-color 0.2s ease;
        }
        .how-to-button:hover {
            background-color: #e0e0e0;
            color: #000;
        }
        #difficulty-selector {
            margin-top: 20px;
            border-top: 1px solid #ccc;
            padding-top: 15px;
            text-align: center;
        }
        #game-timer-selector, #turn-timer-selector {
            margin-top: 20px;
            border-top: 1px solid #ccc;
            padding-top: 15px;
            text-align: center;
        }
        #board {
            display: grid;
            border: 2px solid #000000;
            background-color: #fff;
        }
        .square {
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            cursor: pointer;
            position: relative;
            transition: background-color 0.5s ease-in-out; /* Smooth transition for background color */
        }
        .piece {
            font-family: Arial, sans-serif;
            font-weight: bold;
            font-size: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            background-color: rgb(0, 0, 0);
            border-radius: 50%;
            line-height: 1;
        }
        .piece.white {
            background-color: rgb(255, 255, 255);
        }
        .piece.black {
            background-color: rgb(0, 0, 0);
        }
        .light { background-color: #999999; }
        .dark { background-color: #363535; }
        .ai-move-highlight { background-color: #ffcc00 !important; }
        .selected { background-color: #ffcc00 !important; }
        .valid-move { background-color: #ffff99 !important; }
        .valid-capture { background-color: #ff2020 !important; }
        .valid-shoot { background-color: #ff2020 !important; }
        .valid-swap { background-color: #99ff99 !important; }
        .hint-highlight {
            background-color: #00ffff !important;
            box-shadow: 0 0 10px 3px #00ffff !important;
            animation: pulse-hint 1s infinite;
        }
        @keyframes pulse-hint {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .piece-arrow {
            font-size: 12px;
            position: absolute;
            bottom: 0px;
            right: 0px;
        }
        #status {
            margin-top: 20px;
            font-size: 18px;
            color: #fff;
        }
        #score-display {
            margin: 10px 0;
            font-size: 18px;
            padding: 10px;
            width: 280px;
            color: #fff;
            background-color: #ffffff00;
            border: 1px solid #33333300;
            border-radius: 5px;
            text-align: center;
        }
        #info-box {
            margin-top: 20px;
            width: 300px;
            padding: 10px;
            background-color: #fff;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            text-align: left;
            display: none;
        }
        #game-log {
            margin-top: 20px;
            width: 300px;
            height: 150px;
            padding: 10px;
            background-color: #fff;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            overflow-y: scroll;
            text-align: left;
        }
        #captured-pieces {
            margin-top: 20px;
            width: 300px;
            padding: 10px;
            background-color: #fff;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            text-align: left;
        }
        #reinforce-modal, #turn-modal, #turn-move-modal, #turn-shoot-modal, #truce-modal, #coin-toss-modal, #king-summon-modal, #champion-summon-modal, #necromancer-summon-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 20px;
            border: 2px solid #333;
            border-radius: 10px;
            z-index: 1000;
        }
        #truce-modal {
            z-index: 2001;
            max-width: 500px;
            text-align: center;
        }
        #truce-modal .modal-content p {
            margin: 15px 0;
            font-size: 16px;
        }
        #truce-modal .modal-footer button {
            margin: 10px;
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            color: white;
        }
        #truce-modal .modal-footer button:hover {
            opacity: 0.9;
        }
        #coin-toss-modal {
            z-index: 2002;
            max-width: 400px;
            text-align: center;
        }
        #coin-toss-modal .coin {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            margin: 20px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            border: 5px solid #333;
            background-color: #666;
            color: white;
            transition: all 0.3s ease;
        }
        #coin-toss-modal .coin.spinning {
            animation: flipCoin 2s ease-in-out;
        }
        #coin-toss-modal .coin.white {
            background-color: white;
            color: black;
        }
        #coin-toss-modal .coin.black {
            background-color: black;
            color: white;
        }
        @keyframes flipCoin {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(3600deg); }
        }
        #coin-toss-modal .modal-content p {
            margin: 15px 0;
            font-size: 18px;
            font-weight: bold;
        }
        #reinforce-modal select, #reinforce-modal button, #turn-modal select, #turn-modal button, #turn-move-modal select, #turn-move-modal button, #turn-shoot-modal select, #turn-shoot-modal button, #king-summon-modal select, #king-summon-modal button, #champion-summon-modal select, #champion-summon-modal button, #necromancer-summon-modal select, #necromancer-summon-modal button {
            margin: 10px;
            padding: 5px;
            font-size: 14px;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .modal-close {
            background: none;
            border: none;
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
        }
        .modal-close:hover {
            color: #c00;
        }
        #how-to-play-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 0;
            border: 2px solid #333;
            border-radius: 10px;
            z-index: 2000;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow: hidden;
        }
        #how-to-play-modal .modal-header {
            background-color: #333;
            color: #fff;
            padding: 15px 20px;
            margin: 0;
            border-radius: 8px 8px 0 0;
        }
        #how-to-play-modal .modal-header .modal-close {
            color: #fff;
            font-size: 24px;
        }
        #how-to-play-modal .modal-content {
            padding: 20px;
            max-height: calc(80vh - 120px);
            overflow-y: auto;
        }
        #how-to-play-modal .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid #ddd;
            text-align: center;
        }
        #how-to-play-modal .modal-footer button {
            padding: 10px 30px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #how-to-play-modal .modal-footer button:hover {
            background-color: #45a049;
        }
        #rules-content h2 {
            color: #333;
            border-bottom: 2px solid #333;
            padding-bottom: 5px;
            margin-top: 20px;
        }
        #rules-content h3 {
            color: #555;
            margin-top: 15px;
        }
        #rules-content .piece-info {
            background-color: #f5f5f5;
            padding: 10px;
            margin: 10px 0;
            border-left: 4px solid #333;
            border-radius: 3px;
        }
        #rules-content .piece-name {
            font-weight: bold;
            color: #333;
            font-size: 16px;
        }
        #rules-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        #rules-content li {
            margin: 5px 0;
        }
        #top-controls {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        #controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        #timer-display {
            margin: 10px auto 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            max-width: 600px;
            color: #fff;
        }
        #timer-display .timer-row {
            flex: 1;
            margin: 0 10px;
        }
        #timer-display .timer-row.player {
            text-align: left;
        }
        #timer-display .timer-row.game {
            text-align: center;
        }
        #timer-display .timer-row.ai {
            text-align: right;
        }
        #timer-display .timer-row.low-time {
            color: #FFD700;
            font-weight: bold;
        }
        #board.low-time {
            border-color: #FFD700 !important;
            box-shadow: 0 0 10px #FFD700;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        /* New styles for capture effects */
        .capture-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.5);
            animation: fadeOut 2s ease-in-out;
            z-index: 10;
        }
        .capture-background {
            background-color: rgb(223, 0, 0) !important;
            animation: fadeOutBackground 2s ease-in-out;
        }
        .capture-game-background {
            background-color: rgb(223, 0, 0) !important;
            animation: fadeOutGameBackground 2s ease-in-out;
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        @keyframes fadeOutBackground {
            from { background-color: rgb(223, 0, 0); }
            to { background-color: inherit; }
        }
        @keyframes fadeOutGameBackground {
            from { background-color: rgb(223, 0, 0); }
            to { background-color: #202020; }
        }
    </style>
</head>
<body>
    <div id="landing-header">
        <h1>Ratix</h1>
        <p>Created by Craig Skobel</p>
        <button class="how-to-button" onclick="openHowToPlay()">How to Play</button>
    </div>
    <div id="start-menu">
        <h2>Select Game Variant</h2>
        <div class="variant-option">
            <button id="variant-btn-24s" data-ready="false" onclick="handleVariantClick('24s')">24's (Standard)</button>
            <div id="variant-info-24s" class="variant-info">
                <p class="variant-description">Board: 10x14. Layout: single Infantry front rank backing a classic Cavalry, Troll, Dragon, Wizard, Guard, Champion, and King battle line.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Beginner-friendly for learning Ratix fundamentals, yet still offers solid tactical depth for any player.</p>
            </div>
        </div>
        <div class="variant-option">
            <button id="variant-btn-36s" data-ready="false" onclick="handleVariantClick('36s')">36's (Advanced)</button>
            <div id="variant-info-36s" class="variant-info">
                <p class="variant-description">Board: 10x14. Layout: Infantry shield, Archer/Troll support row, and heavy back line with Ogres, Ballista units, royal pieces, and additional cavalry.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Ideal for intermediate players ready for layered formations and expanded special abilities.</p>
            </div>
        </div>
        <div class="variant-option">
            <button id="variant-btn-36s-expert" data-ready="false" onclick="handleVariantClick('36s-expert')">36's (Expert)</button>
            <div id="variant-info-36s-expert" class="variant-info">
                <p class="variant-description">Board: 10x14. Layout: adds Mercenaries and Elephantry to the forward ranks on top of the Archer support line and elite back row for maximal piece variety.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Suited to veteran players comfortable juggling many unit types and long-term tactical planning.</p>
            </div>
        </div>
        <div class="variant-option">
            <button id="variant-btn-36s-elite" data-ready="false" onclick="handleVariantClick('36s-elite')">36's (Elite)</button>
            <div id="variant-info-36s-elite" class="variant-info">
                <p class="variant-description">Board: 10x14. Layout: mirrors the Expert ranks but unlocks Necromancers and relentless Zombie hordes for high-impact summoning play.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Designed for expert players ready to manage advanced summoning chains and relentless board pressure.</p>
            </div>
        </div>
        <div class="variant-option">
            <button id="variant-btn-ccb" data-ready="false" onclick="handleVariantClick('ccb')">24's Close-Combat Battle</button>
            <div id="variant-info-ccb" class="variant-info">
                <p class="variant-description">Board: 8x12. Layout: no buffer columns, keeping Infantry and the elite Cavalry/Troll/Dragon/Wizard formation in immediate close-quarters contact.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Best for aggressive intermediate-to-advanced players who enjoy fast tactical clashes.</p>
            </div>
        </div>
        
        <div id="difficulty-selector">
            <h3>Select AI Difficulty</h3>
            <button id="diff-easy" onclick="setDifficulty('Easy', this)">Easy</button>
            <button id="diff-medium" onclick="setDifficulty('Medium', this)" class="selected-diff">Medium</button>
            <button id="diff-hard" onclick="setDifficulty('Hard', this)">Hard</button>
        </div>

        <div id="opponent-selector">
            <h3>Select Your Opponent</h3>
            <button id="opp-random" onclick="setOpponent('Random', this)" class="selected-opponent">Random</button>
            <button id="opp-berserker" onclick="setOpponent('Berserker', this)">Ragnar the Berserker</button>
            <button id="opp-guardian" onclick="setOpponent('Guardian', this)">Thorne the Guardian</button>
            <button id="opp-tactician" onclick="setOpponent('Tactician', this)">Astra the Tactician</button>
            <button id="opp-sorcerer" onclick="setOpponent('Sorcerer', this)">Zephyr the Sorcerer</button>
            <button id="opp-nomad" onclick="setOpponent('Nomad', this)">Kira the Nomad</button>
        </div>

        <div id="hint-selector">
            <h3>Hint System</h3>
            <button id="hint-on" onclick="setHintMode('On', this)">On</button>
            <button id="hint-off" onclick="setHintMode('Off', this)" class="selected-hint">Off</button>
        </div>

        <div id="game-timer-selector">
            <h3>Select Game Timer</h3>
            <button id="game-timer-quick" onclick="setGameTimer('quick', this)">10 mins (Quick)</button>
            <button id="game-timer-standard" onclick="setGameTimer('standard', this)" class="selected-option">30 mins (Standard)</button>
            <button id="game-timer-long" onclick="setGameTimer('long', this)">60 mins (Long)</button>
        </div>
        <div id="turn-timer-selector">
            <h3>Select Turn Timer</h3>
            <button id="turn-timer-blitz" onclick="setTurnTimer('blitz', this)">30 secs (Blitz)</button>
            <button id="turn-timer-standard" onclick="setTurnTimer('standard', this)" class="selected-option">60 secs (Standard)</button>
        </div>
    </div>
    <footer id="landing-footer">Ratix &copy; 2025 Skobel Games</footer>
    <div id="game-container">
        <h1>Ratix</h1>
        <div id="top-controls">
            <button onclick="returnToMainMenu()">Main Menu</button>
            <button onclick="resetGame()">Reset Game</button>
            <button onclick="openHowToPlay()">How to Play</button>
        </div>
        <div id="score-display">Player Score: 0 | Opponent Score: 0</div>
        <div id="timer-display">
            <div class="timer-row player" id="player-timer-row">Player Turn: 00:00</div>
            <div class="timer-row game" id="game-timer-row">Game Time: 00:00</div>
            <div class="timer-row ai" id="ai-timer-row">Opponent Turn: 00:00</div>
        </div>
        <div id="board"></div>
        <div id="controls">
            <button id="turn-button" onclick="openTurnModal()" style="display: none;">Turn Piece</button>
            <button id="turn-move-button" onclick="openTurnAndMoveModal()" style="display: none;">Turn and Move</button>
            <button id="turn-shoot-button" onclick="openTurnAndShootModal()" style="display: none;">Turn and Shoot</button>
            <button id="archer-move-diag-shoot-button" onclick="activateArcherMoveDiagShoot()" style="display: none;">Skirmish (Move+Diag Shot)</button>
            <button id="archer-diag2-shoot-button" onclick="activateArcherDiag2Shoot()" style="display: none;">Longshot Diagonal</button>
            <button id="guard-honour-button" onclick="activateGuardOfHonour()" style="display: none;">Guard of Honour</button>
            <button id="teleport-button" onclick="activateTeleport()" style="display: none;">Teleport</button>
            <button id="teleport-swap-button" onclick="activateTeleportSwap()" style="display: none;">Teleport Swap</button>
            <button id="charge-button" onclick="activateCharge()" style="display: none;">Charge</button>
            <button id="inferno-button" onclick="activateInferno()" style="display: none;">Inferno</button>
            <button id="strafe-button" onclick="activateStrafe()" style="display: none;">Strafe</button>
            <button id="summon-spectre-button" onclick="activateSummonSpectre()" style="display: none;">Summon Spectre</button>
            <button id="hint-button" onclick="showHint()" style="display: none;">Get Hint</button>
            <button id="end-turn-button" onclick="endTurn()" disabled>End Turn</button>
        </div>
        <div id="status">Player's turn: 3 moves remaining</div>
        <div id="info-box"></div>
        <div id="game-log"></div>
        <div id="captured-pieces">
            <h3>Player's Captured Pieces</h3>
            <div id="player-captured"></div>
            <h3>Opponent's Captured Pieces</h3>
            <div id="ai-captured"></div>
        </div>
    </div>
    <div id="reinforce-modal">
        <h3>Select Reinforcement Piece</h3>
        <select id="reinforce-select"></select>
        <button onclick="confirmReinforcement()">Confirm</button>
    </div>
    <div id="king-summon-modal">
        <div class="modal-header"><span>Select Unit to Summon</span><button class="modal-close" onclick="closeKingSummonModal()" aria-label="Close">&times;</button></div>
        <select id="king-summon-select"></select>
        <button onclick="confirmKingSummon()">Summon (2 pts + coin flip)</button>
    </div>
    <div id="champion-summon-modal">
        <div class="modal-header"><span>Summon Necromancer</span><button class="modal-close" onclick="closeChampionSummonModal()" aria-label="Close">&times;</button></div>
        <select id="champion-summon-select"></select>
        <button onclick="confirmChampionSummon()">Summon (2 pts + coin flip)</button>
    </div>
    <div id="necromancer-summon-modal">
        <div class="modal-header"><span>Necromancer Summon</span><button class="modal-close" onclick="closeNecromancerSummonModal()" aria-label="Close">&times;</button></div>
        <select id="necromancer-summon-select"></select>
        <button onclick="confirmNecromancerSummon()">Summon (2 pts + coin flip)</button>
    </div>
    <div id="turn-modal">
        <div class="modal-header"><span>Select Facing Direction</span><button class="modal-close" onclick="closeTurnModal()" aria-label="Close">&times;</button></div>
        <select id="turn-select"></select>
                <button onclick="confirmTurn()">Confirm</button>
    </div>
    <div id="turn-move-modal">
        <div class="modal-header"><span>Select Facing Direction</span><button class="modal-close" onclick="closeTurnMoveModal()" aria-label="Close">&times;</button></div>
        <select id="turn-move-select"></select>
        <button onclick="confirmTurnAndMove()">Confirm</button>
    </div>
    <div id="turn-shoot-modal">
        <div class="modal-header"><span>Select Facing Direction</span><button class="modal-close" onclick="closeTurnShootModal()" aria-label="Close">&times;</button></div>
        <select id="turn-shoot-select"></select>
        <button onclick="confirmTurnAndShoot()">Confirm</button>
    </div>
    <div id="how-to-play-modal">
        <div class="modal-header">
            <span>How to Play - Ratix</span>
            <button class="modal-close" onclick="closeHowToPlay()" aria-label="Close">&times;</button>
        </div>
        <div class="modal-content">
            <div id="rules-content"></div>
        </div>
        <div class="modal-footer">
            <button onclick="closeHowToPlay()">Resume Game</button>
        </div>
    </div>
    <div id="truce-modal">
        <div class="modal-header">
            <span>Truce Proposal</span>
        </div>
        <div class="modal-content">
            <p id="truce-message">Both players have 6 or fewer pieces remaining. Do you wish to agree to a truce and end the game in a draw?</p>
            <p id="truce-attempts"></p>
        </div>
        <div class="modal-footer">
            <button onclick="acceptTruce()" style="background-color: #4CAF50;">Accept Truce</button>
            <button onclick="declineTruce()" style="background-color: #f44336;">Decline</button>
        </div>
    </div>
    <div id="coin-toss-modal">
        <div class="modal-header">
            <span id="coin-toss-title">Coin Toss</span>
        </div>
        <div class="modal-content">
            <div id="coin-result" class="coin">☠︎</div>
            <p id="coin-toss-message"></p>
            <p id="coin-toss-description" style="font-size: 14px; margin-top: 10px;"></p>
        </div>
        <div class="modal-footer">
            <button id="coin-toss-start" onclick="startCoinToss()" style="display: none; background-color: #2196F3;">Flip Coin</button>
            <button id="coin-toss-continue" onclick="closeCoinToss()" style="display: none; background-color: #4CAF50;">Continue</button>
        </div>
    </div>
    <script>
        let ROWS = 10;
        let COLS = 12;
        let gameVariant = '24s';
        let isFirstPlayerTurn = true;
        let lastAction = null;
        let turnAndMoveMode = false;
        let turnAndShootMode = false;
        let archerMoveDiagMode = false;
        let archerDiagShootSelectMode = false;
        let archerMoveDiagStart = null;
        let archerDiag2ShootMode = false;
        let guardOfHonourMode = false;
        let teleportMode = false;
        let teleportSwapMode = false;
        let chargeMode = false;
        let infernoMode = false; // New state for Dragon's Inferno
        let strafeMode = false; // New state for Wizard/Dragon Strafe
        let summonSpectreMode = false; // New state for Wizard Spectre summoning
        let elephantryChargeMode = false; // New state for Elephantry Charge
        let elephantryExtendedRangeActive = false; // Active when player is in extended range shooting mode
        let elephantryMoveShootMode = false; // Active when Elephantry has moved and needs to select shoot target
        let elephantryMoveShootPosition = null; // Store the position Elephantry moved to
        let pistolierMoveShootMode = false; // Active when Pistolier has moved and needs to select shoot target
        let pistolierMoveShootPosition = null; // Store the position Pistolier moved to
        let fusilierCrackShotActive = null; // Holds Fusilier piece currently empowered by Crack Shot
        let fusilierStrafeActive = false; // Active when Fusilier is selecting strafe move
        let initialMovesLeft = 3;
        let aiPending = false; // Prevent duplicate AI scheduling
        let gamePaused = false; // Track if game is paused
        let pausedTimers = { game: null, turn: null, turnPlayer: null }; // Store timer states when paused

        const VARIANT_LABELS = {
            '24s': "24's (Standard)",
            '36s': "36's (Advanced)",
            '36s-expert': "36's (Expert)",
            '36s-elite': "36's (Elite)",
            'ccb': "24's Close-Combat Battle"
        };
        const VARIANT_KEYS = Object.keys(VARIANT_LABELS);

        function resetVariantSelections() {
            VARIANT_KEYS.forEach(variant => {
                const button = document.getElementById(`variant-btn-${variant}`);
                if (button) {
                    button.classList.remove('selected-variant');
                    button.textContent = VARIANT_LABELS[variant];
                    button.dataset.ready = 'false';
                }
                const info = document.getElementById(`variant-info-${variant}`);
                if (info) {
                    info.classList.remove('visible');
                }
            });
        }

        function handleVariantClick(variant) {
            const button = document.getElementById(`variant-btn-${variant}`);
            const info = document.getElementById(`variant-info-${variant}`);
            if (!button || !info) return;

            if (button.dataset.ready === 'true') {
                startGame(variant);
                return;
            }

            resetVariantSelections();
            info.classList.add('visible');
            button.classList.add('selected-variant');
            button.dataset.ready = 'true';
            button.textContent = 'Start Game';
        }

        // Truce/Draw system
        let truceAttempts = 0;
        let truceMaxAttempts = 3;
        let truceDeclinedTurns = 0;
        let truceEligible = true;
        let trucePlayerVote = null; // null, 'accept', 'decline'
        let truceAIVote = null;

        function returnToMainMenu() {
            if (confirm('Return to main menu? Current game will be lost.')) {
                stopGameTimer();
                stopTurnTimer();
                if (window.aiTurnWatch) {
                    clearInterval(window.aiTurnWatch);
                    window.aiTurnWatch = null;
                }
                document.getElementById('game-container').style.display = 'none';
                document.getElementById('start-menu').style.display = 'flex';
                const landingHeader = document.getElementById('landing-header');
                if (landingHeader) landingHeader.style.display = 'block';
                const landingFooter = document.getElementById('landing-footer');
                if (landingFooter) landingFooter.style.display = 'block';
                resetVariantSelections();
            }
        }

        function openHowToPlay() {
            gamePaused = true;
            // Pause timers - save state BEFORE stopping
            pausedTimers.game = gameTimerInterval;
            pausedTimers.turn = turnTimerInterval;
            pausedTimers.turnPlayer = currentTurnTimerPlayer; // Save which player's timer was running
            stopGameTimer();
            stopTurnTimer();

            // Generate and display rules content
            generateRulesContent();
            document.getElementById('how-to-play-modal').style.display = 'block';
        }

        function closeHowToPlay() {
            document.getElementById('how-to-play-modal').style.display = 'none';
            gamePaused = false;

            // Resume timers if they were running
            if (pausedTimers.game && gameTimeRemaining > 0) {
                startGameTimer();
            }
            if (pausedTimers.turn && pausedTimers.turnPlayer) {
                if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                    startTurnTimer('W');
                } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                    startTurnTimer('B');
                }
            }
            pausedTimers = { game: null, turn: null, turnPlayer: null };
        }

        function generateRulesContent() {
            const rulesDiv = document.getElementById('rules-content');

            let html = `
                <h2>Game Overview</h2>
                <p><strong>Ratix</strong> is a strategic chess-like game where you command an army against an AI opponent. Capture the enemy King to win!</p>

                <h2>Game Variants</h2>
                <ul>
                    <li><strong>24's (Standard):</strong> 10x14 board with 24 pieces per side</li>
                    <li><strong>36's (Advanced):</strong> 10x14 board with 36 pieces per side - includes Archers, Ballistas, and Ogres</li>
                    <li><strong>36's (Expert):</strong> 10x14 board with 36 pieces per side - includes all advanced pieces plus Mercenaries and Elephantry</li>
                    <li><strong>24's Close-Combat Battle:</strong> Smaller 8x12 board for faster games</li>
                </ul>

                <h2>How to Win</h2>
                <ul>
                    <li><strong>Regicide:</strong> Capture the enemy King (instant victory)</li>
                    <li><strong>Supremacy:</strong> Capture enemy Champion, keep their score ≤1, and get your King or Champion to their back row</li>
                    <li><strong>Relentless:</strong> Activate 3 reinforcements using Infantry while opponent has 0 reinforcements</li>
                    <li><strong>Score Victory:</strong> Highest score when game timer expires</li>
                </ul>

                <h2>Draw Conditions</h2>
                <ul>
                    <li><strong>Truce:</strong> When both players have 6 or fewer pieces remaining, either player can propose a truce. Both players must agree for the game to end in a draw. If declined, the truce can be proposed again at the start of the next 3 turns. After 3 declined attempts, truce is no longer available.</li>
                    <li><strong>Match:</strong> When both players only have their King remaining, the game automatically ends in a draw.</li>
                </ul>

                <h2>Turn Mechanics</h2>
                <ul>
                    <li>Each turn you have 3 moves (or 2 if your Champion was captured)</li>
                    <li>Different actions cost different move points (1-2 points)</li>
                    <li><strong>Honour (Warcry):</strong> Score 10+ points in a turn to gain +2 moves next turn</li>
                    <li><strong>Despair:</strong> Lose 2+ non-basic pieces in a turn to suffer -2 moves next turn</li>
                    <li>Champions on enemy back row reduce opponent's moves by 1</li>
                </ul>

                <h2>Reinforcements</h2>
                <p>When Infantry, Champion, or King reaches the opponent's back row without capturing, you can reinforce a captured piece to your back row.</p>
                <ul>
                    <li><strong>36's (Expert):</strong> Champion/King can reinforce Ballista, Elephantry, or Mercenary</li>
                </ul>

                <h2>Piece Information</h2>
            `;

            // Add piece information
            for (let [pieceName, info] of Object.entries(pieceInfo)) {
                // Format the info.extra to make "Special Moves:" or "Special Move:" bold
                let formattedExtra = info.extra.replace(/Special Moves?:/g, '<strong>$&</strong>');

                html += `
                    <div class="piece-info">
                        <div class="piece-name">${pieceName}</div>
                        <div><strong>Movement:</strong> ${info.points}</div>
                        <div><strong>Important:</strong> ${formattedExtra}</div>
                    </div>
                `;
            }

            html += `
                <h2>Special Abilities</h2>
                <ul>
                    <li><strong>King - Guard of Honour:</strong> Swap with adjacent Guard (2 points, once per game)</li>
                    <li><strong>Wizard - Teleport:</strong> Move to any empty square of same color (2 points, twice per game)</li>
                    <li><strong>Wizard - Teleport Swap:</strong> Swap with enemy Wizard on same color (2 points, once per game)</li>
                    <li><strong>Cavalry - Charge:</strong> Move unlimited squares in one direction (2 points, once per game)</li>
                    <li><strong>Dragon - Inferno:</strong> Move 1 square and capture all adjacent enemies (2 points, once per game)</li>
                    <li><strong>Archer - Skirmish:</strong> Move then shoot diagonally 1 square (2 points, twice per game)</li>
                    <li><strong>Archer - Longshot Diagonal:</strong> Shoot diagonally 2 squares (2 points, twice per game)</li>
                    <li><strong>Ballista - Extend Range:</strong> +1 shooting range this turn (2 points, once per turn)</li>
                    <li><strong>Ballista - Double Time:</strong> Move 2 squares in one direction (2 points, twice per game)</li>
                </ul>

                <h2>Tips</h2>
                <ul>
                    <li>Protect your King and Champion - losing them severely weakens your army</li>
                    <li>Plan your moves carefully - you only get 3 per turn</li>
                    <li>Use special abilities strategically - most can only be used once or twice</li>
                    <li>Watch the timers - running out of time forfeits your turn</li>
                    <li>Score points by capturing enemy pieces - higher value pieces give more points</li>
                </ul>
            `;

            rulesDiv.innerHTML = html;
        }

        function countPieces(player) {
            let count = 0;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] && board[r][c].player === player) {
                        count++;
                    }
                }
            }
            return count;
        }

        function checkForMatch() {
            const playerPieces = countPieces('W');
            const aiPieces = countPieces('B');

            // Check if both players only have their King left
            if (playerPieces === 1 && aiPieces === 1) {
                let playerHasOnlyKing = false;
                let aiHasOnlyKing = false;

                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (board[r][c]) {
                            if (board[r][c].player === 'W' && board[r][c].type === 'King') {
                                playerHasOnlyKing = true;
                            }
                            if (board[r][c].player === 'B' && board[r][c].type === 'King') {
                                aiHasOnlyKing = true;
                            }
                        }
                    }
                }

                if (playerHasOnlyKing && aiHasOnlyKing) {
                    gameLog.push('Match: Both players only have their King remaining. Game ends in a draw.');
                    updateGameLog();
                    endGame('draw', 'Match');
                    return true;
                }
            }
            return false;
        }

        function checkForTruce() {
            if (!truceEligible || truceAttempts >= truceMaxAttempts) return;

            const playerPieces = countPieces('W');
            const aiPieces = countPieces('B');

            // Check if both players have 6 or fewer pieces
            if (playerPieces <= 6 && aiPieces <= 6) {
                // Only show truce modal at the start of player's turn after a decline
                if (truceDeclinedTurns > 0 && truceDeclinedTurns <= 3) {
                    proposeTruce();
                } else if (truceDeclinedTurns === 0) {
                    // First time checking - propose immediately
                    proposeTruce();
                }
            }
        }

        function proposeTruce() {
            gamePaused = true;
            stopGameTimer();
            stopTurnTimer();

            truceAttempts++;
            const attemptsRemaining = truceMaxAttempts - truceAttempts;

            document.getElementById('truce-attempts').textContent =
                `Attempt ${truceAttempts} of ${truceMaxAttempts}. ${attemptsRemaining} attempts remaining.`;

            // Calculate AI decision based on piece point values
            const aiPieces = countPieces('B');
            const playerPieces = countPieces('W');

            // Calculate total piece values for both players
            let aiTotalValue = 0;
            let playerTotalValue = 0;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece) {
                        const value = pieceValues[piece.type] || 0;
                        if (piece.player === 'B') {
                            aiTotalValue += value;
                        } else if (piece.player === 'W') {
                            playerTotalValue += value;
                        }
                    }
                }
            }

            // AI decision logic:
            // Base 50% chance, then adjusted by piece value difference
            // If AI has lower total value, more likely to accept
            // If AI has higher total value, less likely to accept
            const valueDifference = aiTotalValue - playerTotalValue;
            let acceptanceChance = 0.5; // Base 50% chance

            // Adjust based on value difference (normalized by typical piece value)
            acceptanceChance -= valueDifference / 50; // Adjust by ~2% per point difference

            // Clamp between 10% and 90%
            acceptanceChance = Math.max(0.1, Math.min(0.9, acceptanceChance));

            truceAIVote = (Math.random() < acceptanceChance) ? 'accept' : 'decline';

            // Set up 30-second timeout for auto-decline
            if (window.truceTimeout) {
                clearTimeout(window.truceTimeout);
            }
            window.truceTimeout = setTimeout(() => {
                if (document.getElementById('truce-modal').style.display === 'block') {
                    // Auto-decline if player hasn't responded
                    gameLog.push('Truce proposal timed out after 30 seconds. Automatically declined.');
                    updateGameLog();
                    declineTruce();
                }
            }, 30000); // 30 seconds

            document.getElementById('truce-modal').style.display = 'block';
        }

        function acceptTruce() {
            trucePlayerVote = 'accept';

            // Clear the timeout
            if (window.truceTimeout) {
                clearTimeout(window.truceTimeout);
                window.truceTimeout = null;
            }

            document.getElementById('truce-modal').style.display = 'none';

            if (truceAIVote === 'accept') {
                gameLog.push('Player accepted truce.');
                gameLog.push('AI accepted truce.');
                gameLog.push('Truce accepted by both players. Game ends in a draw.');
                updateGameLog();
                endGame('draw', 'Truce');
            } else {
                gameLog.push('Player accepted truce.');
                gameLog.push('AI declined truce.');
                gameLog.push(`Truce not established. ${truceMaxAttempts - truceAttempts} attempts remaining.`);
                updateGameLog();
                truceDeclinedTurns = 1;
                resumeAfterTruce();
            }
        }

        function declineTruce() {
            trucePlayerVote = 'decline';

            // Clear the timeout
            if (window.truceTimeout) {
                clearTimeout(window.truceTimeout);
                window.truceTimeout = null;
            }

            document.getElementById('truce-modal').style.display = 'none';

            gameLog.push('Player declined truce.');
            if (truceAIVote === 'accept') {
                gameLog.push('AI accepted truce.');
            } else {
                gameLog.push('AI declined truce.');
            }
            gameLog.push(`Truce not established. ${truceMaxAttempts - truceAttempts} attempts remaining.`);
            updateGameLog();

            if (truceAttempts >= truceMaxAttempts) {
                truceEligible = false;
                gameLog.push('Truce is no longer available for this game.');
                updateGameLog();
            } else {
                truceDeclinedTurns = 1;
            }

            resumeAfterTruce();
        }

        function resumeAfterTruce() {
            gamePaused = false;
            startGameTimer();
            if (currentPlayer === 'W') {
                startTurnTimer('W');
            } else {
                startTurnTimer('B');
            }
        }

        function performCoinToss(title, message, callback, automated = false) {
            gamePaused = true;
            // Save timer state before stopping
            pausedTimers.game = gameTimerInterval;
            pausedTimers.turn = turnTimerInterval;
            pausedTimers.turnPlayer = currentTurnTimerPlayer;
            stopGameTimer();
            stopTurnTimer();

            coinTossCallback = callback;

            // Determine if this is the first turn coin toss or an in-game outcome
            const isFirstTurn = title === 'First Turn';
            window.coinTossContext = isFirstTurn ? 'first-turn' : 'in-game';

            document.getElementById('coin-toss-title').textContent = title;
            document.getElementById('coin-toss-message').textContent = message;

            // Set appropriate description based on context
            if (isFirstTurn) {
                document.getElementById('coin-toss-description').textContent = 'The coin will flip to determine the outcome. White side means you go first, black side means AI goes first.';
            } else {
                document.getElementById('coin-toss-description').textContent = 'The coin will flip to determine the outcome. White side means success, black side means failure.';
            }

            document.getElementById('coin-toss-continue').style.display = 'none';

            // If automated (AI action), hide the button and auto-start
            if (automated) {
                document.getElementById('coin-toss-start').style.display = 'none';
            } else {
                document.getElementById('coin-toss-start').style.display = 'inline-block';
            }

            const coinResult = document.getElementById('coin-result');
            // Reset coin to initial state
            coinResult.className = 'coin';
            coinResult.textContent = '☠︎';
            coinResult.style.backgroundColor = '#666';
            coinResult.style.color = 'white';

            document.getElementById('coin-toss-modal').style.display = 'block';

            // Auto-start coin flip for AI
            if (automated) {
                setTimeout(() => startCoinToss(), 500);
            }
        }

        function startCoinToss() {
            // Hide the start button and description
            document.getElementById('coin-toss-start').style.display = 'none';
            document.getElementById('coin-toss-description').textContent = '';
            document.getElementById('coin-toss-message').textContent = 'Flipping...';

            const coinResult = document.getElementById('coin-result');

            // Determine result
            const result = Math.random() < 0.5; // true = white (success), false = black (failure)
            window.lastCoinTossResult = result;

            // Add spinning animation
            coinResult.classList.add('spinning');

            // After animation completes (2 seconds), show result
            setTimeout(() => {
                // Remove spinning class
                coinResult.classList.remove('spinning');

                // Apply result styling and show appropriate message based on context
                const isFirstTurn = window.coinTossContext === 'first-turn';

                if (result) {
                    coinResult.classList.add('white');
                    coinResult.style.backgroundColor = 'white';
                    coinResult.style.color = 'black';

                    if (isFirstTurn) {
                        document.getElementById('coin-toss-message').textContent = "You won the coin toss! You're going first.";
                    } else {
                        document.getElementById('coin-toss-message').textContent = "Success!";
                    }
                } else {
                    coinResult.classList.add('black');
                    coinResult.style.backgroundColor = 'black';
                    coinResult.style.color = 'white';

                    if (isFirstTurn) {
                        document.getElementById('coin-toss-message').textContent = `${getOpponentDisplayName()} won the coin toss and is going first.`;
                    } else {
                        document.getElementById('coin-toss-message').textContent = "Failure!";
                    }
                }

                // Show continue button after result is displayed
                setTimeout(() => {
                    document.getElementById('coin-toss-continue').style.display = 'inline-block';

                    // Auto-close after a delay
                    setTimeout(() => {
                        // Close modal first
                        document.getElementById('coin-toss-modal').style.display = 'none';

                        // Wait for modal to be completely hidden before starting game
                        setTimeout(() => {
                            // Execute callback which will handle game initialization
                            if (coinTossCallback) {
                                const callback = coinTossCallback;
                                coinTossCallback = null;
                                callback(result);
                            }

                            // Unpause game and resume timers after callback completes
                            gamePaused = false;

                            // Resume timers if they were running before the coin toss
                            if (pausedTimers.game && gameTimeRemaining > 0) {
                                startGameTimer();
                            }
                            if (pausedTimers.turn && pausedTimers.turnPlayer) {
                                if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                                    startTurnTimer('W');
                                } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                                    startTurnTimer('B');
                                }
                            }
                            pausedTimers = { game: null, turn: null, turnPlayer: null };
                        }, 300);
                    }, 2000);
                }, 500);
            }, 2000);
        }

        function closeCoinToss() {
            // Close modal
            document.getElementById('coin-toss-modal').style.display = 'none';

            // Wait for modal to be completely hidden before starting game
            setTimeout(() => {
                // Execute callback if it exists
                if (coinTossCallback) {
                    const callback = coinTossCallback;
                    coinTossCallback = null;
                    // Use the stored result from the coin toss
                    callback(window.lastCoinTossResult);
                }

                // Unpause game and resume timers
                gamePaused = false;

                // Resume timers if they were running before the coin toss
                if (pausedTimers.game && gameTimeRemaining > 0) {
                    startGameTimer();
                }
                if (pausedTimers.turn && pausedTimers.turnPlayer) {
                    if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                        startTurnTimer('W');
                    } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                        startTurnTimer('B');
                    }
                }
                pausedTimers = { game: null, turn: null, turnPlayer: null };
            }, 300);
        }

        function triggerAiTurn() {
            if (gamePaused || aiPending || reinforcementPending || currentPlayer !== 'W') return;
            stopTurnTimer();
            applyEndTurnEffects('W');
            aiPending = true;
            try {
                aiTurn();
            } catch (err) {
                console.error('AI turn failed:', err);
                completeAiTurn({ reason: 'AI encountered an error taking its turn.' });
            } finally {
                // aiTurn clears the flag when it begins; keep safety fallback here
                if (aiPending) {
                    aiPending = false;
                }
            }
        }

        function completeAiTurn({ reason = null, skipEndEffects = false } = {}) {
            if (!skipEndEffects) {
                applyEndTurnEffects('B');
            }
            aiPending = false;
            aiTurnTimeoutForced = false;
            stopTurnTimer();
            highlightSquares = [];
            currentPlayer = 'W';
            turnCount++; // Increment turn counter when AI finishes and control returns to player
            playerTurnNumber++; // Increment player turn counter
            ballistaRangeBoostActive['W'] = false;
            ballistaRangeBoostUsedThisTurn['W'] = false;
            // Reset wizard summoning flag for new turn
            wizardSummonedThisTurn['W'] = false;
            // Clear wizard movement restrictions from previous turn
            wizardCannotMoveNextTurn['W'].clear();

            const humanBaseMoves = calculateBaseMoves('W');
            const playerCanMove = applyStartTurnModifiers('W', humanBaseMoves);

            movedPieces.clear();
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            checkGameOver();

            if (!playerCanMove) {
                triggerAiTurn();
            } else {
                ensureAITurnIfNeeded();
            }

            if (reason) {
                gameLog.push(reason);
                updateGameLog();
            }
        }

        function ensureAITurnIfNeeded() {
            if (gamePaused || currentPlayer !== 'W' || reinforcementPending || aiPending) return;
            // Don't end turn if pistolier is in move+shoot mode waiting for shot selection
            if (pistolierMoveShootMode) return;
            if (movesLeft <= 0) {
                triggerAiTurn();
                return;
            }
            // For larger boards, always check if turn should end (not just when moves used)
            // For smaller boards, only check if at least one move has been used
            if (movesLeft < initialMovesLeft || isLargeBoardVariant()) {
                let anyValidActions = false;
                outer: for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const piece = board[r][c];
                        if (piece && piece.player === 'W' && !movedPieces.has(`${r},${c}`)) {
                            const vm = getValidMoves(r, c);
                            // Check if any moves are actually affordable
                            for (let move of vm) {
                                if (move.cost <= movesLeft) {
                                    anyValidActions = true;
                                    break outer;
                                }
                            }
                        }
                    }
                }
                if (!anyValidActions) {
                    movesLeft = 0; // Ensure movesLeft is 0 before triggering
                    triggerAiTurn();
                }
            }
        }

        function isAnySpecialModeActive() {
            return turnAndShootMode || turnAndMoveMode || guardOfHonourMode || teleportMode || teleportSwapMode || chargeMode || infernoMode || strafeMode || summonSpectreMode || archerMoveDiagMode || archerDiagShootSelectMode || archerDiag2ShootMode || elephantryChargeMode || elephantryExtendedRangeActive || elephantryMoveShootMode || pistolierMoveShootMode || fusilierCrackShotActive || fusilierStrafeActive;
        }

        function cancelSpecialModes(options = {}) {
            const { resetSelection = true } = options;
            turnAndShootMode = false;
            turnAndMoveMode = false;
            guardOfHonourMode = false;
            teleportMode = false;
            teleportSwapMode = false;
            chargeMode = false;
            infernoMode = false;
            strafeMode = false;
            summonSpectreMode = false;
            archerMoveDiagMode = false;
            archerDiagShootSelectMode = false;
            archerDiag2ShootMode = false;
            elephantryChargeMode = false;
            elephantryExtendedRangeActive = false;
            fusilierCrackShotActive = null;
            fusilierStrafeActive = false;
            elephantryMoveShootMode = false;
            elephantryMoveShootPosition = null;
            pistolierMoveShootMode = false;
            pistolierMoveShootPosition = null;
            archerMoveDiagStart = null;
            const turnModalEl = document.getElementById('turn-modal');
            if (turnModalEl) turnModalEl.style.display = 'none';
            const turnMoveModalEl = document.getElementById('turn-move-modal');
            if (turnMoveModalEl) turnMoveModalEl.style.display = 'none';
            const turnShootModalEl = document.getElementById('turn-shoot-modal');
            if (turnShootModalEl) turnShootModalEl.style.display = 'none';
            lastAction = null;

            if (resetSelection) {
                selectedPiece = null;
                validMoves = [];
                showPieceInfo(null);
            } else if (selectedPiece) {
                const { row, col } = selectedPiece;
                if (board[row][col] && board[row][col].player === currentPlayer) {
                    validMoves = getValidMoves(row, col);
                    showPieceInfo(board[row][col], currentPlayer);
                } else {
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                }
            } else {
                validMoves = [];
            }

            renderBoard();
            updateStatus();
            updateEndTurnButton();
        }

        function applyEndTurnEffects(player) {
            const opponent = getOpponent(player);
            let logUpdated = false;

            if (turnScoreGain[player] >= HONOUR_THRESHOLD) {
                nextTurnModifier[player] += HONOUR_BONUS;
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} triggered Honour (Warcry) bonus (+${HONOUR_BONUS} moves next turn).`);
                logUpdated = true;
            }

            const losses = turnLosses[opponent] || {};
            for (let type in losses) {
                if (losses[type] >= 2 && !DESPAIR_EXCLUDED.has(type)) {
                    nextTurnModifier[opponent] -= DESPAIR_PENALTY;
                    gameLog.push(`${opponent === 'W' ? 'Player' : 'AI'} suffers Despair penalty (-${DESPAIR_PENALTY} moves next turn).`);
                    logUpdated = true;
                    break;
                }
            }

            turnScoreGain[player] = 0;
            turnLosses[player] = {};
            turnLosses[opponent] = {};

            // Update Fusilier cooldowns at the end of the player's turn
            finalizeFusilierShots(player);

            if (logUpdated) {
                updateGameLog();
            }
        }

        function finalizeFusilierShots(player) {
            const lastTurnSet = fusilierShotLastTurn[player];
            if (!lastTurnSet) return;

            if (fusilierCrackShotActive && fusilierCrackShotActive.player === player) {
                fusilierCrackShotActive = null;
            }

            lastTurnSet.clear();
            fusilierShotThisTurn[player].forEach(piece => {
                if (piece && piece.player === player && piece.type === 'Fusilier') {
                    lastTurnSet.add(piece);
                }
            });
            fusilierShotThisTurn[player].clear();
        }

        function pruneFusilierShotTracking(player) {
            const activeFusiliers = new Set();
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece && piece.player === player && piece.type === 'Fusilier') {
                        activeFusiliers.add(piece);
                    }
                }
            }

            const lastTurnSet = fusilierShotLastTurn[player];
            if (lastTurnSet) {
                const keep = [];
                lastTurnSet.forEach(piece => {
                    if (activeFusiliers.has(piece)) {
                        keep.push(piece);
                    }
                });
                lastTurnSet.clear();
                keep.forEach(piece => lastTurnSet.add(piece));
            }

            const thisTurnSet = fusilierShotThisTurn[player];
            if (thisTurnSet) {
                const keep = [];
                thisTurnSet.forEach(piece => {
                    if (activeFusiliers.has(piece)) {
                        keep.push(piece);
                    }
                });
                thisTurnSet.clear();
                keep.forEach(piece => thisTurnSet.add(piece));
            }
        }

        function calculateBaseMoves(player) {
            let base = championCaptured[player] ? 2 : 3;
            const opponent = getOpponent(player);
            base -= championsOnBackRow[opponent].length;
            return Math.max(0, base);
        }

        function applyStartTurnModifiers(player, baseMoves, options = {}) {
            const { skipStopTimer = false } = options;
            if (!skipStopTimer) {
                stopTurnTimer();
            }
            pruneFusilierShotTracking(player);
            const opponent = getOpponent(player);
            let modifier = nextTurnModifier[player] || 0;
            let moves = Math.max(0, baseMoves + modifier);

            if (modifier > 0) {
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} gains Honour (Warcry) bonus (+${modifier} moves).`);
            } else if (modifier < 0) {
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} is hindered by Despair penalty (-${Math.abs(modifier)} moves).`);
            }

            if (modifier !== 0) {
                updateGameLog();
            }

            nextTurnModifier[player] = 0;
            movesLeft = moves;
            initialMovesLeft = moves;
            turnScoreGain[player] = 0;
            turnLosses[player] = turnLosses[player] || {};
            turnLosses[opponent] = {};
            decrementNecromancerCooldown(player);
            let turnStartHandled = false;
            const finalizeTurnStart = () => {
                if (turnStartHandled) return;
                turnStartHandled = true;
                if (moves === 0) {
                    if (player === 'W') {
                        playerTurnTimeRemaining = 0;
                    } else {
                        aiTurnTimeRemaining = 0;
                    }
                    updateTimerDisplay();
                    gameLog.push(`${player === 'W' ? 'Player' : 'AI'} is immobilized this turn.`);
                    updateGameLog();
                    return;
                }

                startTurnTimer(player);

                // Check for truce at start of player's turn
                if (player === 'W' && truceDeclinedTurns > 0) {
                    truceDeclinedTurns++;
                    if (truceDeclinedTurns <= 3) {
                        checkForTruce();
                    }
                } else if (player === 'W' && truceDeclinedTurns === 0) {
                    checkForTruce();
                }
            };

            const zombiesPending = advanceZombiesForPlayer(player, finalizeTurnStart);
            if (!zombiesPending) {
                finalizeTurnStart();
            }

            return moves > 0;
        }
        let highlightSquares = [];
        let kingSpecialUsed = { 'W': false, 'B': false };
        let wizardTeleportUsed = { 'W': 0, 'B': 0 };
        let wizardTeleportSwapUsed = { 'W': false, 'B': false };
        let cavalryChargeUsed = { 'W': false, 'B': false };
        let dragonInfernoUsed = { 'W': false, 'B': false }; // New state for Inferno usage
        let wizardStrafeUsed = { 'W': 0, 'B': 0 }; // Strafe move (limit 2)
        let dragonStrafeUsed = { 'W': 0, 'B': 0 }; // Strafe move (limit 2)
        let spectresSummoned = { 'W': 0, 'B': 0 }; // Spectre summoning (limit 2 per player)
        let wizardSummonedThisTurn = { 'W': false, 'B': false }; // Track if wizard summoned this turn
        let wizardCannotMoveNextTurn = { 'W': new Set(), 'B': new Set() }; // Wizards that cannot move next turn
        let necromancersSummoned = { 'W': 0, 'B': 0 }; // Necromancer summoning (limit 2 per player)
        let necromancerTeleportCounts = new Map(); // Track per-piece teleport usage
        let necromancerShootCooldown = new Map(); // Track per-piece ranged cooldown
        let zombiesSummoned = { 'W': 0, 'B': 0 }; // Total Zombies currently controlled (base cap 3)
        let zombiePendingAdvanceQueue = []; // Pending automatic Zombie advances requests
        let championSummonSource = null; // Track active champion summon request
        let necromancerSummonContext = null; // Track active necromancer summon
        let necromancerSummonType = null;
        let zombieConversions = { 'W': 0, 'B': 0 }; // Successful zombie conversions (max 2 to raise cap)
        let zombieCoinQueue = []; // Pending zombie coin flip animations
        let zombieCoinAnimating = false;
        let zombieCoinModalTimeouts = [];
        let zombieAutoAdvanceInProgress = false;
        let zombieAdvanceTimer = null;
        let coinTossCallback = null; // Callback for coin toss result
        let archerMoveDiagShootUsed = { 'W': 0, 'B': 0 }; // Move then shoot diagonally (limit 2)
        let archerDiag2ShootUsed = { 'W': 0, 'B': 0 }; // Diagonal 2-square shot (limit 2)
        let capturedSquares = []; // Track squares where captures occur
        // Ballista specials
        let ballistaRangeBoostActive = { 'W': false, 'B': false };
        let ballistaRangeBoostUsedThisTurn = { 'W': false, 'B': false };
        let ballistaDoubleTimeUsed = { 'W': 0, 'B': 0 };
        // Elephantry specials
        let elephantryChargeUsed = new Set(); // Track which elephantry pieces have used charge (set of "row,col,player")
        let elephantryExtendedRangeShotsRemaining = {}; // Map of "row,col,player" to remaining shots (starts at 3)
        let elephantryExtendedRangeMode = false; // Active during extended range shooting sequence
        // Fusilier specials
        let fusilierShotLastTurn = { 'W': new Set(), 'B': new Set() }; // Fusiliers that fired last turn (wait one turn before shooting again)
        let fusilierShotThisTurn = { 'W': new Set(), 'B': new Set() }; // Fusiliers that have fired during the current turn
        let fusilierCrackShotUsed = new Set(); // Track which fusilier pieces have used crack shot (set of "row,col,player", max 3 uses)
        let fusilierCrackShotCount = {}; // Map of "row,col,player" to remaining uses (starts at 3)
        let fusilierStrafeUsed = new Set(); // Track which fusilier pieces have used strafe (set of "row,col,player", max 2 uses)
        let fusilierStrafeCount = {}; // Map of "row,col,player" to remaining uses (starts at 2)
        // King summoning
        let pistoliersSummoned = { 'W': 0, 'B': 0 }; // Track summoned pistoliers (max 2 per player)
        let fusiliersSummoned = { 'W': 0, 'B': 0 }; // Track summoned fusiliers (max 2 per player)

        function getMaxZombies(player) {
            return 3 + Math.min(zombieConversions[player] || 0, 2);
        }

        function getNecromancerTeleportCount(piece) {
            if (!piece) return 0;
            return necromancerTeleportCounts.get(piece) || 0;
        }

        function incrementNecromancerTeleportCount(piece) {
            if (!piece) return;
            const used = getNecromancerTeleportCount(piece);
            necromancerTeleportCounts.set(piece, used + 1);
        }

        function setNecromancerShotCooldown(piece, turns) {
            if (!piece) return;
            if (turns > 0) {
                necromancerShootCooldown.set(piece, turns);
            } else {
                necromancerShootCooldown.delete(piece);
            }
        }

        function createZombiePiece(player) {
            return { type: 'Zombie', player, facing: player === 'W' ? 'U' : 'D' };
        }

        function createSpectrePiece(player) {
            return { type: 'Spectre', player };
        }

        function isPieceOnBoard(piece) {
            if (!piece) return false;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r] && board[r][c] === piece) {
                        return true;
                    }
                }
            }
            return false;
        }

        function cleanupNecromancerTracking(piece) {
            if (!piece) return;
            necromancerTeleportCounts.delete(piece);
            necromancerShootCooldown.delete(piece);
            if (piece.type === 'Necromancer' && necromancersSummoned[piece.player] > 0) {
                necromancersSummoned[piece.player]--;
            }
            if (piece.type === 'Zombie' && zombiesSummoned[piece.player] > 0) {
                zombiesSummoned[piece.player]--;
            }
        }

        function enqueueZombieCoinFlip(result, title, message) {
            zombieCoinQueue.push({ result, title, message });
            if (!zombieCoinAnimating) {
                processZombieCoinFlipQueue();
            }
        }

        function processZombieCoinFlipQueue() {
            if (!zombieCoinQueue.length) {
                zombieCoinAnimating = false;
                return;
            }
            zombieCoinAnimating = true;
            const { result, title, message } = zombieCoinQueue.shift();
            showZombieCoinFlipModal(result, title, message, () => {
                zombieCoinAnimating = false;
                processZombieCoinFlipQueue();
            });
        }

        function showZombieCoinFlipModal(result, title, message, done) {
            const modal = document.getElementById('coin-toss-modal');
            const coinResult = document.getElementById('coin-result');
            const titleEl = document.getElementById('coin-toss-title');
            const messageEl = document.getElementById('coin-toss-message');
            const descriptionEl = document.getElementById('coin-toss-description');
            const startBtn = document.getElementById('coin-toss-start');
            const continueBtn = document.getElementById('coin-toss-continue');

            if (!modal || !coinResult || !titleEl || !messageEl || !descriptionEl) {
                done();
                return;
            }

            if (startBtn) startBtn.style.display = 'none';
            if (continueBtn) continueBtn.style.display = 'none';

            titleEl.textContent = title || 'Coin Toss';
            messageEl.textContent = message || 'Flipping...';
            descriptionEl.textContent = 'The coin will flip to determine the outcome. White side means success, black side means failure.';

            coinResult.className = 'coin';
            coinResult.style.backgroundColor = '#666';
            coinResult.style.color = 'white';
            coinResult.textContent = '☠︎';

            modal.dataset.zombieFlip = 'true';
            modal.style.display = 'block';

            void coinResult.offsetWidth;
            coinResult.classList.add('spinning');

            const revealTimeout = setTimeout(() => {
                zombieCoinModalTimeouts = zombieCoinModalTimeouts.filter(id => id !== revealTimeout);
                coinResult.classList.remove('spinning');
                const outcomeText = result ? 'Success!' : 'Failure!';
                if (result) {
                    coinResult.classList.add('white');
                    coinResult.style.backgroundColor = 'white';
                    coinResult.style.color = 'black';
                } else {
                    coinResult.classList.add('black');
                    coinResult.style.backgroundColor = 'black';
                    coinResult.style.color = 'white';
                }
                messageEl.textContent = message ? `${message} - ${outcomeText}` : outcomeText;

                const closeTimeout = setTimeout(() => {
                    zombieCoinModalTimeouts = zombieCoinModalTimeouts.filter(id => id !== closeTimeout);
                    if (modal.dataset.zombieFlip === 'true') {
                        modal.style.display = 'none';
                        delete modal.dataset.zombieFlip;
                    }
                    coinResult.className = 'coin';
                    coinResult.style.backgroundColor = '#666';
                    coinResult.style.color = 'white';
                    coinResult.textContent = '☠︎';
                    descriptionEl.textContent = '';
                    messageEl.textContent = '';
                    if (startBtn) startBtn.style.display = 'none';
                    if (continueBtn) continueBtn.style.display = 'none';
                    done();
                }, 1600);
                zombieCoinModalTimeouts.push(closeTimeout);
            }, 2000);
            zombieCoinModalTimeouts.push(revealTimeout);
        }

        function clearZombieCoinAnimations() {
            zombieCoinQueue = [];
            zombieCoinAnimating = false;
            while (zombieCoinModalTimeouts.length) {
                const timeoutId = zombieCoinModalTimeouts.pop();
                clearTimeout(timeoutId);
            }
            const modal = document.getElementById('coin-toss-modal');
            const coinResult = document.getElementById('coin-result');
            const messageEl = document.getElementById('coin-toss-message');
            const descriptionEl = document.getElementById('coin-toss-description');
            const startBtn = document.getElementById('coin-toss-start');
            const continueBtn = document.getElementById('coin-toss-continue');
            if (modal && modal.dataset.zombieFlip) {
                modal.style.display = 'none';
                delete modal.dataset.zombieFlip;
            }
            if (coinResult) {
                coinResult.className = 'coin';
                coinResult.style.backgroundColor = '#666';
                coinResult.style.color = 'white';
                coinResult.textContent = '☠︎';
            }
            if (descriptionEl) {
                descriptionEl.textContent = '';
            }
            if (messageEl) {
                messageEl.textContent = '';
            }
            if (startBtn) startBtn.style.display = 'none';
            if (continueBtn) continueBtn.style.display = 'none';
        }

        function zombieCoinFlip({ title = 'Zombie Coin Flip', message = '' } = {}) {
            const result = Math.random() < 0.5;
            enqueueZombieCoinFlip(result, title, message);
            return result;
        }

        function randomCoinFlip() {
            return Math.random() < 0.5;
        }

        function getBackRow(player) {
            return player === 'W' ? ROWS - 1 : 0;
        }

        function getOpponentBackRow(player) {
            return player === 'W' ? 0 : ROWS - 1;
        }

        function findBackRowSpawnColumn(player, preferredCol = null) {
            const backRow = getBackRow(player);
            const columns = [];
            if (preferredCol !== null) columns.push(preferredCol);
            for (let c = 0; c < COLS; c++) {
                if (c !== preferredCol) columns.push(c);
            }
            for (const col of columns) {
                if (col >= 0 && col < COLS && !board[backRow][col]) {
                    return col;
                }
            }
            return null;
        }

        function spawnZombieAtBackRow(player, preferredCol = null) {
            const spawnCol = findBackRowSpawnColumn(player, preferredCol);
            if (spawnCol === null) return false;
            const backRow = getBackRow(player);
            const zombie = createZombiePiece(player);
            board[backRow][spawnCol] = zombie;
            zombiesSummoned[player] = (zombiesSummoned[player] || 0) + 1;
            gameLog.push(`${player === 'W' ? 'Player' : 'AI'} zombie spawned at (${backRow},${spawnCol}).`);
            return true;
        }

        function awardZombieBonus(player, reason) {
            scores[player] += 3;
            registerScoreGain(player, 3);
            gameLog.push(`${player === 'W' ? 'Player' : 'AI'} gained +3 points (${reason}).`);
        }

        function capturePieceForZombie(player, row, col, targetPiece) {
            cleanupNecromancerTracking(targetPiece);
            capturedSquares.push([row, col]);
            capturedPieces[player].push(targetPiece);
            const captureValue = pieceValues[targetPiece.type] || 0;
            scores[player] += captureValue;
            registerScoreGain(player, captureValue);
            registerPieceLoss(targetPiece.player, targetPiece.type);
            if (targetPiece.type === 'Champion') {
                championCaptured[targetPiece.player] = true;
            }
            if (targetPiece.type === 'King') {
                endGame(player);
            }
            board[row][col] = null;
        }

        function handleZombieReachedOpponentBackRow(player, row, col) {
            const opponentBackRow = getOpponentBackRow(player);
            if (row !== opponentBackRow) return false;
            const zombie = board[row][col];
            if (!zombie || zombie.type !== 'Zombie') return false;
            cleanupNecromancerTracking(zombie);
            board[row][col] = null;
            awardZombieBonus(player, 'Zombie reached opponent back row');
            const spawnSuccess = spawnZombieAtBackRow(player, col);
            if (!spawnSuccess) {
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} zombie could not respawn due to lack of space.`);
            }
            return true;
        }

        function moveZombieTo(fromRow, fromCol, toRow, toCol, player) {
            const zombie = board[fromRow][fromCol];
            board[toRow][toCol] = zombie;
            board[fromRow][fromCol] = null;
            handleZombieReachedOpponentBackRow(player, toRow, toCol);
        }

        function attemptZombieCapture(fromRow, fromCol, targetRow, targetCol, player) {
            const zombie = board[fromRow][fromCol];
            const targetPiece = board[targetRow]?.[targetCol];
            if (!targetPiece) {
                moveZombieTo(fromRow, fromCol, targetRow, targetCol, player);
                return 'moved';
            }
            const playerLabel = player === 'W' ? 'Player' : 'AI';
            if (targetPiece.type === 'Zombie') {
                const success = zombieCoinFlip({
                    title: 'Zombie Clash',
                    message: `${playerLabel} zombie challenges opposing Zombie.`
                });
                if (success) {
                    cleanupNecromancerTracking(targetPiece);
                    board[targetRow][targetCol] = null;
                    const spawnSuccess = zombieConversions[player] < 2 && spawnZombieAtBackRow(player);
                    if (spawnSuccess) {
                        zombieConversions[player]++;
                        gameLog.push(`${playerLabel} converted an opposing Zombie into their ranks.`);
                    } else if (zombieConversions[player] < 2) {
                        gameLog.push(`${playerLabel} destroyed an opposing Zombie but had no space to convert it.`);
                    } else {
                        gameLog.push(`${playerLabel} destroyed an opposing Zombie (conversion limit reached).`);
                    }
                    moveZombieTo(fromRow, fromCol, targetRow, targetCol, player);
                    return 'moved';
                } else {
                    cleanupNecromancerTracking(zombie);
                    board[fromRow][fromCol] = null;
                    gameLog.push(`${playerLabel} zombie lost the clash against an opposing Zombie at (${targetRow},${targetCol}).`);
                    return 'removed';
                }
            }
            const success = zombieCoinFlip({
                title: 'Zombie Capture',
                message: `${playerLabel} zombie attacks ${targetPiece.type}.`
            });
            if (success) {
                capturePieceForZombie(player, targetRow, targetCol, targetPiece);
                moveZombieTo(fromRow, fromCol, targetRow, targetCol, player);
                return 'moved';
            } else {
                gameLog.push(`${playerLabel} zombie failed to capture ${targetPiece.type} at (${targetRow},${targetCol}).`);
                return 'stay';
            }
        }

        function handleZombieCaptureAttempt(attackerPiece, fromRow, fromCol, targetRow, targetCol, options = {}) {
            const targetPiece = board[targetRow]?.[targetCol];
            if (!targetPiece || targetPiece.type !== 'Zombie') {
                return { handled: false };
            }
            if (attackerPiece.type === 'Elephantry') {
                gameLog.push(`${attackerPiece.player === 'W' ? 'Player' : 'AI'} Elephantry cannot capture Zombies by landing.`);
                return { handled: true, success: false, attackerRemoved: false };
            }
            const attackerLabel = attackerPiece.player === 'W' ? 'Player' : 'AI';
            const zombieOwner = targetPiece.player;
            const viaRanged = options.ranged;
            const attemptVerb = viaRanged ? 'shoot' : 'capture';
            const successVerb = viaRanged ? 'shot' : 'captured';
            const success = zombieCoinFlip({
                title: 'Zombie Defense',
                message: `${attackerLabel} ${viaRanged ? 'shoots at' : 'attacks'} Zombie.`
            });
            if (success) {
                cleanupNecromancerTracking(targetPiece);
                board[targetRow][targetCol] = null;
                capturedSquares.push([targetRow, targetCol]);
                capturedPieces[attackerPiece.player].push(targetPiece);
                const captureValue = pieceValues[targetPiece.type] || 0;
                scores[attackerPiece.player] += captureValue;
                registerScoreGain(attackerPiece.player, captureValue);
                registerPieceLoss(zombieOwner, targetPiece.type);
                gameLog.push(`${attackerLabel} ${successVerb} Zombie at (${targetRow},${targetCol}) after winning the coin flip.`);
                return { handled: true, success: true };
            } else {
                // For ranged/shooting attacks, the attacker stays on the board
                if (viaRanged) {
                    gameLog.push(`${attackerLabel} failed to ${attemptVerb} Zombie at (${targetRow},${targetCol}). The shot missed and the attacker remains safe.`);
                    return { handled: true, success: false, attackerRemoved: false };
                } else {
                    // For landing captures, the attacker is captured by the zombie
                    board[fromRow][fromCol] = null;
                    cleanupNecromancerTracking(attackerPiece);
                    capturedSquares.push([fromRow, fromCol]);
                    capturedPieces[zombieOwner].push(attackerPiece);
                    registerPieceLoss(attackerPiece.player, attackerPiece.type);
                    scores[zombieOwner] += 3;
                    registerScoreGain(zombieOwner, 3);
                    gameLog.push(`${attackerLabel} failed to ${attemptVerb} Zombie at (${targetRow},${targetCol}) and was lost in the attempt. (+3 bonus to ${zombieOwner === 'W' ? 'Player' : 'AI'})`);
                    renderBoard();
                    updateScoreDisplay();
                    updateCapturedPiecesDisplay();
                    updateGameLog();
                    return { handled: true, success: false, attackerRemoved: true };
                }
            }
        }

        function advanceZombieFromPosition(row, col, player) {
            const zombie = board[row][col];
            if (!zombie || zombie.type !== 'Zombie' || zombie.player !== player) return false;
            const direction = player === 'W' ? -1 : 1;
            if (handleZombieReachedOpponentBackRow(player, row, col)) {
                return true;
            }
            const forwardRow = row + direction;
            if (!isValid(forwardRow, col)) {
                if (handleZombieReachedOpponentBackRow(player, row, col)) {
                    return true;
                }
                return false;
            }
            const forwardPiece = board[forwardRow][col];
            if (!forwardPiece) {
                moveZombieTo(row, col, forwardRow, col, player);
                return true;
            }
            if (forwardPiece.player !== player) {
                const result = attemptZombieCapture(row, col, forwardRow, col, player);
                return result === 'moved' || result === 'removed';
            }
            const diagonals = [col - 1, col + 1];
            for (const diagCol of diagonals) {
                if (!isValid(forwardRow, diagCol)) continue;
                const diagPiece = board[forwardRow][diagCol];
                if (!diagPiece) {
                    moveZombieTo(row, col, forwardRow, diagCol, player);
                    return true;
                }
                if (diagPiece.player !== player) {
                    const result = attemptZombieCapture(row, col, forwardRow, diagCol, player);
                    if (result === 'moved' || result === 'removed') {
                        return true;
                    }
                }
            }
            return false;
        }

        function advanceZombiesForPlayer(player, onComplete = null) {
            if (gameVariant !== '36s-elite') {
                if (typeof onComplete === 'function') {
                    onComplete();
                }
                return false;
            }
            const positions = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece && piece.type === 'Zombie' && piece.player === player) {
                        positions.push({ row: r, col: c });
                    }
                }
            }
            if (!positions.length) {
                if (typeof onComplete === 'function') {
                    onComplete();
                }
                return false;
            }
            if (zombieAutoAdvanceInProgress) {
                zombiePendingAdvanceQueue.push({ player, onComplete });
                return true;
            }
            positions.sort((a, b) => {
                if (a.col !== b.col) {
                    return a.col - b.col;
                }
                return player === 'W' ? a.row - b.row : b.row - a.row;
            });
            if (zombieAdvanceTimer) {
                clearTimeout(zombieAdvanceTimer);
                zombieAdvanceTimer = null;
            }
            zombieAutoAdvanceInProgress = true;
            let pendingUpdate = false;
            const completeAdvance = () => {
                if (zombieAdvanceTimer) {
                    clearTimeout(zombieAdvanceTimer);
                    zombieAdvanceTimer = null;
                }
                zombieAutoAdvanceInProgress = false;
                if (pendingUpdate) {
                    renderBoard();
                    updateScoreDisplay();
                    updateCapturedPiecesDisplay();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                }
                if (typeof onComplete === 'function') {
                    onComplete();
                }
                if (zombiePendingAdvanceQueue.length) {
                    const nextRequest = zombiePendingAdvanceQueue.shift();
                    zombieAdvanceTimer = setTimeout(() => advanceZombiesForPlayer(nextRequest.player, nextRequest.onComplete), 200);
                }
            };
            const processNextZombie = () => {
                if (!positions.length) {
                    completeAdvance();
                    return;
                }
                const pos = positions.shift();
                const piece = board[pos.row]?.[pos.col];
                if (!piece || piece.type !== 'Zombie' || piece.player !== player) {
                    processNextZombie();
                    return;
                }
                const moved = advanceZombieFromPosition(pos.row, pos.col, player);
                if (moved) {
                    pendingUpdate = true;
                    renderBoard();
                    updateScoreDisplay();
                    updateCapturedPiecesDisplay();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                }
                zombieAdvanceTimer = setTimeout(processNextZombie, 280);
            };
            processNextZombie();
            return true;
        }

        function decrementNecromancerCooldown(player) {
            necromancerShootCooldown.forEach((turns, piece) => {
                if (!isPieceOnBoard(piece)) {
                    cleanupNecromancerTracking(piece);
                    return;
                }
                if (piece.player === player && turns > 0) {
                    const next = turns - 1;
                    if (next <= 0) {
                        necromancerShootCooldown.delete(piece);
                    } else {
                        necromancerShootCooldown.set(piece, next);
                    }
                }
            });
            necromancerTeleportCounts.forEach((_, piece) => {
                if (!isPieceOnBoard(piece)) {
                    cleanupNecromancerTracking(piece);
                }
            });
        }
        
        // AI Difficulty
        let aiDifficulty = 'Medium';
        let baseAiDepth = 16; // Track difficulty selection (defaults to Medium, increased by 60% from previous: 10 * 1.6)
        let aiMaxDepth = 16; // Effective depth after variant adjustments (increased by 60% from previous)
        let pieceValueScale = 4.18176; // Defaults to Medium (increased by 60% from previous: 2.6136 * 1.6)

        // Opponent Selection
        let selectedOpponent = 'Random'; // Default to random selection

        // Hint System
        let hintModeEnabled = false; // Default to off
        const AI_LEFTOVER_PENALTY = 0.75;
        const AI_TIE_EPSILON = 0.0001;
        const AI_TIME_LIMIT_DEFAULT = 1200; // Increased from 650ms for slower AI thinking
        const AI_TIME_LIMIT_LARGE = 400; // Increased from 180ms for slower AI thinking

        // AI Player Profiles - Different strategies and play styles (invisible to player)
        const AI_PROFILES = {
            'Berserker': {
                name: 'Berserker',
                displayName: 'Ragnar the Berserker',
                description: 'Hyper-aggressive attacker, prioritizes captures above all else',
                threatWeight: 1.8,           // Heavily values threatening enemy pieces
                mobilityWeight: 0.25,        // Lower mobility concern
                centerWeight: 0.15,          // Lower center control concern
                captureBonus: 1.4,           // +40% bonus to capture values
                specialAbilityBonus: 1.3,    // +30% bonus to special abilities
                aggressionLevel: 1.5         // Highly aggressive
            },
            'Guardian': {
                name: 'Guardian',
                displayName: 'Thorne the Guardian',
                description: 'Defensive player, focuses on piece preservation and center control',
                threatWeight: 0.6,           // Lower threat priority
                mobilityWeight: 0.7,         // Values having options
                centerWeight: 0.6,           // Strongly values center control
                captureBonus: 0.8,           // -20% capture bonus (more cautious)
                specialAbilityBonus: 0.9,    // -10% special ability usage
                aggressionLevel: 0.6         // Defensive playstyle
            },
            'Tactician': {
                name: 'Tactician',
                displayName: 'Astra the Tactician',
                description: 'Balanced strategist, adapts to board position',
                threatWeight: 1.0,           // Balanced threat evaluation
                mobilityWeight: 0.55,        // Moderate mobility value
                centerWeight: 0.35,          // Moderate center control
                captureBonus: 1.0,           // Normal capture values
                specialAbilityBonus: 1.1,    // Slightly favors special abilities
                aggressionLevel: 1.0         // Balanced approach
            },
            'Sorcerer': {
                name: 'Sorcerer',
                displayName: 'Zephyr the Sorcerer',
                description: 'Special ability specialist, maximizes use of unique powers',
                threatWeight: 0.85,          // Moderate threat focus
                mobilityWeight: 0.6,         // Values positioning for abilities
                centerWeight: 0.25,          // Lower center concern
                captureBonus: 0.95,          // Slightly lower capture priority
                specialAbilityBonus: 1.7,    // +70% bonus to special abilities
                aggressionLevel: 1.1         // Slightly aggressive
            },
            'Nomad': {
                name: 'Nomad',
                displayName: 'Kira the Nomad',
                description: 'Mobility-focused player, constantly repositioning for advantage',
                threatWeight: 0.75,          // Lower direct threat focus
                mobilityWeight: 0.85,        // Highly values movement options
                centerWeight: 0.4,           // Moderate center value
                captureBonus: 0.9,           // Slightly cautious on captures
                specialAbilityBonus: 1.0,    // Normal special ability usage
                aggressionLevel: 0.85        // Moderately cautious, prefers mobility
            }
        };

        // Current AI profile (selected randomly at game start)
        let currentAiProfile = null;
        const LARGE_BOARD_VARIANTS = ['36s', '36s-expert', '36s-elite'];
        let aiSearchDeadline = 0;
        function aiTimeExpired() {
            return aiSearchDeadline && Date.now() >= aiSearchDeadline;
        }

        const pieceIcons = {
            'Cavalry': 'C', 'Troll': 'T', 'Dragon': 'D', 'Wizard': 'W', 'Guard': 'G',
            'King': 'K', 'Champion': '✠', 'Infantry': 'I', 'Archer': 'A', 'Ballista': 'B',
            'Elephantry': 'E', 'Mercenary': 'M', 'Ogre': 'O', 'Spectre': 'S', 'Pistolier': 'P', 'Fusilier': 'F'
        };
        pieceIcons['Necromancer'] = 'N';
        pieceIcons['Zombie'] = 'Z';
        const facingIcons = {
            'U': '▲', 'D': '▼', 'L': '◀', 'R': '▶'
        };
        const basePieceValues = {
            'Infantry': 1, 'Archer': 2, 'Cavalry': 3, 'Pistolier': 3, 'Fusilier': 4, 'Guard': 4, 'Ballista': 5,
            'Troll': 6, 'Dragon': 7, 'Ogre': 8, 'Wizard': 9, 'Spectre': 5, 'Mercenary': 10,
            'Elephantry': 11, 'Champion': 12, 'King': 13
        };
        basePieceValues['Necromancer'] = 10;
        basePieceValues['Zombie'] = 3;
        const pieceValues = basePieceValues;
        let aiPieceValues = { ...basePieceValues };

        function isLargeBoardVariant() {
            return LARGE_BOARD_VARIANTS.includes(gameVariant);
        }

        function getAiTimeBudget() {
            let base = isLargeBoardVariant() ? AI_TIME_LIMIT_LARGE : AI_TIME_LIMIT_DEFAULT;
            if (aiDifficulty === 'Hard') {
                base += isLargeBoardVariant() ? 182 : 338; // +30% difficulty: increased thinking time (140→182, 260→338)
            } else if (aiDifficulty === 'Medium') {
                base += isLargeBoardVariant() ? 48 : 120; // +20% difficulty: increased thinking time (40→48, 100→120)
            } else if (aiDifficulty === 'Easy') {
                base += isLargeBoardVariant() ? 20 : 30; // +10% difficulty: give AI more thinking time
            }
            return base;
        }

        const GAME_TIME_OPTIONS = {
            quick: 10 * 60,
            standard: 30 * 60,
            long: 60 * 60
        };
        const TURN_TIME_OPTIONS = {
            blitz: 30,
            standard: 60
        };
        let selectedGameTimerKey = 'standard';
        let selectedTurnTimerKey = 'standard';
        let gameTimeRemaining = GAME_TIME_OPTIONS[selectedGameTimerKey];
        let gameTimerInterval = null;
        let turnTimerInterval = null;
        let playerTurnTimeRemaining = TURN_TIME_OPTIONS[selectedTurnTimerKey];
        let aiTurnTimeRemaining = TURN_TIME_OPTIONS[selectedTurnTimerKey];
        let currentTurnTimerPlayer = null;
        let aiTurnTimeoutForced = false;
        let turnCount = 0; // Initialize turn counter early for timer display
        let playerTurnNumber = 0; // Track player's turn count (for first 2 turns features)

        const HONOUR_THRESHOLD = 10;
        const HONOUR_BONUS = 2;
        const DESPAIR_PENALTY = 2;
        const DESPAIR_EXCLUDED = new Set(['Mercenary', 'Infantry', 'Archer']);
        const RELENTLESS_THRESHOLD = 3;

        let turnScoreGain = { 'W': 0, 'B': 0 };
        let turnLosses = { 'W': {}, 'B': {} };
        let nextTurnModifier = { 'W': 0, 'B': 0 };
        let reinforcementTotals = { 'W': 0, 'B': 0 };
        let infantryReinforcements = { 'W': 0, 'B': 0 };

        function updateAiPieceValues() {
            aiPieceValues = Object.fromEntries(Object.entries(basePieceValues).map(([k, v]) => [k, Math.round(v * pieceValueScale)]));
        }

        updateAiPieceValues();
        function setGameTimer(option, element) {
            selectedGameTimerKey = option;
            gameTimeRemaining = GAME_TIME_OPTIONS[selectedGameTimerKey];
            const buttons = document.querySelectorAll('#game-timer-selector button');
            buttons.forEach(btn => btn.classList.remove('selected-option'));
            if (element) {
                element.classList.add('selected-option');
            }
            updateTimerDisplay();
        }

        function setTurnTimer(option, element) {
            selectedTurnTimerKey = option;
            const duration = TURN_TIME_OPTIONS[selectedTurnTimerKey];
            playerTurnTimeRemaining = duration;
            aiTurnTimeRemaining = duration;
            const buttons = document.querySelectorAll('#turn-timer-selector button');
            buttons.forEach(btn => btn.classList.remove('selected-option'));
            if (element) {
                element.classList.add('selected-option');
            }
            updateTimerDisplay();
        }

        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTimerDisplay() {
            const gameTimerRow = document.getElementById('game-timer-row');
            const playerTimerRow = document.getElementById('player-timer-row');
            const aiTimerRow = document.getElementById('ai-timer-row');
            const board = document.getElementById('board');

            if (gameTimerRow) {
                gameTimerRow.textContent = `Game Time: ${formatTime(Math.max(0, gameTimeRemaining))} | Turn: ${turnCount}`;
            }

            // Update player timer with warning color
            if (playerTimerRow) {
                playerTimerRow.textContent = `Player Turn: ${formatTime(Math.max(0, playerTurnTimeRemaining))}`;
                if (playerTurnTimeRemaining <= 10 && playerTurnTimeRemaining > 0 && currentTurnTimerPlayer === 'W') {
                    playerTimerRow.classList.add('low-time');
                } else {
                    playerTimerRow.classList.remove('low-time');
                }
            }

            // Update AI timer with warning color
            if (aiTimerRow) {
                aiTimerRow.textContent = `${getOpponentDisplayName()} Turn: ${formatTime(Math.max(0, aiTurnTimeRemaining))}`;
                if (aiTurnTimeRemaining <= 10 && aiTurnTimeRemaining > 0 && currentTurnTimerPlayer === 'B') {
                    aiTimerRow.classList.add('low-time');
                } else {
                    aiTimerRow.classList.remove('low-time');
                }
            }

            // Update board border color based on active timer
            if (board) {
                const isPlayerTimerLow = playerTurnTimeRemaining <= 10 && playerTurnTimeRemaining > 0 && currentTurnTimerPlayer === 'W';
                const isAiTimerLow = aiTurnTimeRemaining <= 10 && aiTurnTimeRemaining > 0 && currentTurnTimerPlayer === 'B';

                if (isPlayerTimerLow || isAiTimerLow) {
                    board.classList.add('low-time');
                } else {
                    board.classList.remove('low-time');
                }
            }
        }

        function stopGameTimer() {
            if (gameTimerInterval) {
                clearInterval(gameTimerInterval);
                gameTimerInterval = null;
            }
        }

        function startGameTimer() {
            stopGameTimer();
            gameTimerInterval = setInterval(() => {
                if (gameTimeRemaining > 0) {
                    gameTimeRemaining -= 1;
                    updateTimerDisplay();
                    if (gameTimeRemaining <= 0) {
                        gameTimeRemaining = 0;
                        updateTimerDisplay();
                        stopGameTimer();
                        handleGameTimerExpired();
                    }
                }
            }, 1000);
        }

        function handleGameTimerExpired() {
            gameLog.push('Game timer expired.');
            updateGameLog();
            stopTurnTimer();
            const playerScore = scores['W'];
            const aiScore = scores['B'];
            if (playerScore > aiScore) {
                endGame('W', 'Game timer expired.');
            } else if (aiScore > playerScore) {
                endGame('B', 'Game timer expired.');
            } else {
                endGame('draw', 'Game timer expired.');
            }
        }

        function stopTurnTimer() {
            if (turnTimerInterval) {
                clearInterval(turnTimerInterval);
                turnTimerInterval = null;
            }
            currentTurnTimerPlayer = null;
        }

        function startTurnTimer(player) {
            stopTurnTimer();
            const duration = TURN_TIME_OPTIONS[selectedTurnTimerKey];
            currentTurnTimerPlayer = player;
            if (player === 'W') {
                playerTurnTimeRemaining = duration;
            } else {
                aiTurnTimeRemaining = duration;
            }
            updateTimerDisplay();
            turnTimerInterval = setInterval(() => {
                if (currentTurnTimerPlayer === 'W') {
                    playerTurnTimeRemaining = Math.max(0, playerTurnTimeRemaining - 1);
                    updateTimerDisplay();
                    if (playerTurnTimeRemaining === 0) {
                        stopTurnTimer();
                        handleTurnTimeout('W');
                    }
                } else if (currentTurnTimerPlayer === 'B') {
                    aiTurnTimeRemaining = Math.max(0, aiTurnTimeRemaining - 1);
                    updateTimerDisplay();
                    if (aiTurnTimeRemaining === 0) {
                        stopTurnTimer();
                        handleTurnTimeout('B');
                    }
                }
            }, 1000);
        }

        function handleTurnTimeout(player) {
            if (player === 'W') {
                playerTurnTimeRemaining = 0;
            } else {
                aiTurnTimeRemaining = 0;
            }
            updateTimerDisplay();
            if (player === 'W') {
                gameLog.push('Player turn timer expired. Turn forfeited.');
                cancelSpecialModes();
                if (reinforcementPending && reinforcementPending.player === 'W') {
                    reinforcementPending = null;
                    const modal = document.getElementById('reinforce-modal');
                    if (modal) modal.style.display = 'none';
                }
                movesLeft = 0;
                updateGameLog();
                updateStatus();
                updateEndTurnButton();
                triggerAiTurn();
            } else {
                aiTurnTimeoutForced = true;
                movesLeft = 0;
                completeAiTurn({ reason: 'AI turn timer expired. Player resumes turn.' });
            }
        }

        updateTimerDisplay();

        function getOpponent(player) {
            return player === 'W' ? 'B' : 'W';
        }

        function registerScoreGain(player, amount) {
            turnScoreGain[player] = (turnScoreGain[player] || 0) + amount;
        }

        function registerPieceLoss(player, type) {
            if (DESPAIR_EXCLUDED.has(type)) return;
            if (!turnLosses[player]) turnLosses[player] = {};
            turnLosses[player][type] = (turnLosses[player][type] || 0) + 1;
        }

        function registerReinforcement(player, type) {
            reinforcementTotals[player] = (reinforcementTotals[player] || 0) + 1;
            if (type !== 'Infantry') {
                return false;
            }
            infantryReinforcements[player] = (infantryReinforcements[player] || 0) + 1;
            const opponent = getOpponent(player);
            if (infantryReinforcements[player] >= RELENTLESS_THRESHOLD && (reinforcementTotals[opponent] || 0) === 0) {
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} achieved Relentless victory!`);
                updateGameLog();
                endGame(player);
                return true;
            }
            return false;
        }

        function isSupremacyPosition(player) {
            const opponentBackRow = player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);
            if (championsOnBackRow[player] && championsOnBackRow[player].some(([r]) => r === opponentBackRow)) {
                return true;
            }
            for (let c = 0; c < COLS; c++) {
                if (board[opponentBackRow] && board[opponentBackRow][c] && board[opponentBackRow][c].player === player && board[opponentBackRow][c].type === 'King') {
                    return true;
                }
            }
            return false;
        }

        function checkSupremacy(player) {
            const opponent = getOpponent(player);
            if (!championCaptured[opponent]) return;
            if (scores[opponent] > 1) return;
            if (!isSupremacyPosition(player)) return;
            gameLog.push(`${player === 'W' ? 'Player' : 'AI'} achieved Supremacy victory!`);
            updateGameLog();
            endGame(player);
        }

        const pieceInfo = {
            'Cavalry': {
                points: '1 point to move up to 5 squares vertically or horizontally. Special Moves: Charge - once per game, move unlimited squares horizontally or vertically for 2 move points; Diagonal Rush - on your first 2 turns only, move up to 3 squares diagonally for 2 move points.',
                extra: 'Stops at the first piece in its path.'
            },
            'Troll': {
                points: '1 point to move up to 2 squares vertically/horizontally or 1 square diagonally; +1 point for 1 extra square in same vertical/horizontal direction (total 2 points).',
                extra: 'On first turn, can move up to 4 squares vertically/horizontally or 2 squares diagonally at normal cost. No extra move on first turn.'
            },
            'Dragon': {
                points: '1 point to move 1 square diagonally or jump 2 squares diagonally + 1 square in any diagonal direction. Special Moves: Inferno - once per game, move 1 square in any direction for 2 move points, capturing all adjacent opponent pieces (except Dragons); Strafe - twice per game, move 1 square horizontally or vertically for 2 move points (cannot capture).',
                extra: 'Can change diagonal direction after 2-square jump.'
            },
            'Wizard': {
                points: '1 point to move up to 4 squares diagonally; 2 points to move up to 5 squares and/or through own pieces. Special Moves: Teleport - twice per game, move to any unoccupied square of the same color for 2 move points; Teleport Swap - once per game, swap with an opponent Wizard on the same color square for 2 move points; Strafe - twice per game, move 1 square horizontally or vertically for 2 move points (cannot capture); Summon Spectre - twice per game, costs 2 points, requires 5+ captured pieces, 50/50 chance, wizard cannot move next turn.',
                extra: 'Cannot move through opponent pieces.'
            },
            'Spectre': {
                points: '1 point to move in knight-diagonal pattern (2 diagonal + 1 perpendicular). Summoned by Wizard.',
                extra: 'Can move through all pieces. Capturing requires 50/50 coin toss (except vs Wizards/Spectres). Cannot trigger reinforcements. Max 2 per player.'
            },
            'Guard': {
                points: '1 point to move 1 square in any direction.',
                extra: 'Versatile movement in all directions.'
            },
            'King': {
                points: '1 point to move 1 square vertically or horizontally.',
                extra: 'Cannot move into check. Capture ends the game. Can activate reinforcements. Special Move: Guard of Honour - once per game, swap positions with an adjacent Guard for 2 move points.'
            },
            'Champion': {
                points: '1 point to move 1 square in any direction; 2 points for 2 squares in any direction.',
                extra: 'Cannot move through own pieces. Reduces opponent’s move points by 1 when on their back row. Can activate reinforcements.'
            },
            'Infantry': {
                points: '1 point to move 1 square forward or diagonally forward; 1 point to turn.',
                extra: 'First game turn can be up to 3 squares forward. Turn (1 point) or Turn and Move (2 points) via buttons. Both finalize action. Cannot move then turn. Can turn 90° left or right per action.'
            },
            'Archer': {
                points: '1 point to move 1 square vertically/horizontally, shoot 2 squares in facing direction, or turn; 2 points to turn+shoot or use a special.',
                extra: 'Specials: Move then shoot diagonally 1 square (2 uses per game); or shoot diagonally 2 squares without moving (2 uses per game). Can turn 90° left or right per action.'
            },
            'Ballista': {
                points: '1 point to move 1 square vertically/horizontally or shoot 3 (or 4 with Extend Range) squares based on facing; 2 points to turn or activate specials.',
                extra: 'Specials: Extend Range (+1 shoot range this turn, 2 points, once per turn); Double Time (move +1 extra square, 2 points, 2 uses per game). Shoots without moving. Can turn 90° left or right per action.'
            },
            'Elephantry': {
                points: '1 point to move 1 square any direction, shoot 1 square, or turn; 2 points to move+shoot.',
                extra: 'Special Moves: Charge - once per piece per game, move forward (straight or diagonal) 3 squares, capturing anything except Spectre; stops on Elephantry/Ogre/Troll/Dragon. Triple Shot - 2 points for 3 shots at 2-square range with coin flip each (stays in position, can retarget). Can turn 90° left or right per action.'
            },
            'Pistolier': {
                points: '1 point to move diagonally up to 3 squares or shoot diagonally up to 2 squares; 2 points to move+shoot (1 square shoot range).',
                extra: 'Capturing by landing (not shooting) requires coin flip (50/50). Does not turn - shoots and moves diagonally only.'
            },
            'Fusilier': {
                points: '1 point to move 2 squares diagonally or shoot forward/diagonally up to 3 squares. Cannot move and shoot in same turn.',
                extra: 'Can move through own pieces. After shooting, cannot shoot next turn (can still move). Only captures by shooting. Special Moves: Crack Shot - increase range by +1 for next shot (2 points, 3 uses per piece; success determined by coin flip); Strafe - move 1 square vertically/horizontally without capturing (2 points, 2 uses per piece).'
            },
            'Mercenary': {
                points: '1 point to move 1 square forward or diagonally forward; 2 points for 2 squares.',
                extra: 'Flexible 2-square path on extended move. Turn (1 point) or Turn and Move (2 points) via buttons. Can turn 90° left or right per action.'
            },
            'Ogre': {
                points: '1 point to move 1 square vertically/horizontally or jump 2 squares; 2 points for both.',
                extra: 'Captures by jumping over or landing. Cannot jump over other Ogres.'
            },
            'Necromancer': {
                points: '1 point to move 1 square in any direction. Special actions cost 2 points: summon Zombie or Spectre (coin flip) or channel a 2-range shot.',
                extra: 'Max 2 per player, arrives via Champion summoning. Shoots require a 1-turn cooldown and always resolve captures with coin flips. Teleport twice per game.'
            },
            'Zombie': {
                points: 'Automatically shambles forward each turn without spending move points.',
                extra: 'Summoned to the back row. Moves forward, attempting diagonal detours if blocked, and resolves captures (including defending) via coin flip. Converts opposing Zombies on successful clashes.'
            }
        };
        const turnablePieces = ['Archer', 'Ballista', 'Elephantry', 'Fusilier', 'Infantry', 'Mercenary'];
        const turnCosts = {
            'Archer': 1,
            'Ballista': 2,
            'Elephantry': 1,
            'Fusilier': 1,
            'Infantry': 1,
            'Mercenary': 1
        };
        const pieceTypes = {
            'Cavalry': { move: (r, c, board, player) => {
                let moves = [];
                // Standard orthogonal movement (up to 5 squares)
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    for (let i = 1; i <= 5; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                            }
                            break;
                        }
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                // Diagonal movement on player's first 2 turns only (costs 2 points, up to 3 squares)
                if (player === 'W' && playerTurnNumber < 2) {
                    for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                        for (let i = 1; i <= 3; i++) {
                            let nr = r + d[0] * i, nc = c + d[1] * i;
                            if (!isValid(nr, nc)) break;
                            if (board[nr][nc]) {
                                if (board[nr][nc].player !== player) {
                                    moves.push({ type: 'move', pos: [nr, nc], cost: 2 });
                                }
                                break;
                            }
                            moves.push({ type: 'move', pos: [nr, nc], cost: 2 });
                        }
                    }
                }
                return moves;
            }},
            'Troll': { move: (r, c, board, player, firstMove, _, movesLeft) => {
                let moves = [];
                let isFirstTurn = firstMove && isFirstPlayerTurn;
                let maxOrtho = isFirstTurn ? 4 : 2;
                let maxDiag = isFirstTurn ? 2 : 1;
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    for (let i = 1; i <= maxOrtho; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                            }
                            break;
                        }
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                if (!isFirstTurn && movesLeft >= 2) {
                    for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                        let nr1 = r + d[0], nc1 = c + d[1];
                        let nr2 = r + d[0] * 2, nc2 = c + d[1] * 2;
                        let nr3 = r + d[0] * 3, nc3 = c + d[1] * 3;
                        if (isValid(nr1, nc1) && isValid(nr2, nc2) && isValid(nr3, nc3) && !board[nr1][nc1] && !board[nr2][nc2] && !board[nr3][nc3]) {
                            moves.push({ type: 'move', pos: [nr3, nc3], cost: 2 });
                        }
                    }
                }
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    for (let i = 1; i <= maxDiag; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                            }
                            break;
                        }
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                return moves;
            }},
            'Dragon': { move: (r, c, board, player) => {
                let moves = [];
                // Normal moves
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                }
                for (let d of [[2,2], [2,-2], [-2,2], [-2,-2]]) {
                    let midr = r + d[0]/2, midc = c + d[1]/2;
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) {
                        for (let d2 of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                            let nnr = nr + d2[0], nnc = nc + d2[1];
                            if (isValid(nnr, nnc)) {
                                moves.push({ type: 'move', pos: [nnr, nnc], cost: 1 });
                            }
                        }
                    }
                }
                return moves;
            }},
            'Wizard': { move: (r, c, board, player, firstMove, facing, movesLeft) => {
                let moves = [];
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    for (let i = 1; i <= 4; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                            }
                            break;
                        }
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                if (movesLeft >= 2) {
                    for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                        let i = 1;
                        while (i <= 5) {
                            let nr = r + d[0] * i, nc = c + d[1] * i;
                            if (!isValid(nr, nc)) break;
                            if (board[nr][nc]) {
                                if (board[nr][nc].player === player) {
                                    i++;
                                    continue;
                                } else {
                                    moves.push({ type: 'move', pos: [nr, nc], cost: 2 });
                                    break;
                                }
                            }
                            moves.push({ type: 'move', pos: [nr, nc], cost: 2 });
                            i++;
                        }
                    }
                }
                return moves;
            }},
            'Guard': { move: (r, c, board, player) => {
                let moves = [];
                for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                }
                return moves;
            }},
            'King': { move: (r, c, board, player) => {
                let moves = [];
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc) && !isCheckAfterMove(r, c, nr, nc, player)) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                return moves;
            }},
            'Champion': { move: (r, c, board, player) => {
                let moves = [];
                let directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                for (let d of directions) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) {
                        if (!board[nr][nc] || board[nr][nc].player !== player) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        }
                        if (!board[nr][nc]) {
                            for (let d2 of directions) {
                                let nnr = nr + d2[0], nnc = nc + d2[1];
                                if (isValid(nnr, nnc) && (nnr !== r || nnc !== c)) {
                                    if (!board[nnr][nnc] || board[nnr][nnc].player !== player) {
                                        moves.push({ type: 'move', pos: [nnr, nnc], cost: 2 });
                                    }
                                }
                            }
                        }
                    }
                }
                let uniqueMoves = {};
                for (let move of moves) {
                    let key = `${move.pos[0]},${move.pos[1]}`;
                    if (!uniqueMoves[key] || move.cost < uniqueMoves[key].cost) {
                        uniqueMoves[key] = move;
                    }
                }
                return Object.values(uniqueMoves);
            }},
            'Infantry': { move: (r, c, board, player, _, facing) => {
                let moves = [];
                let max = isFirstPlayerTurn && player === 'W' ? 3 : 1;
                let dir, diag1, diag2;
                if (facing === 'U') { dir = [-1,0]; diag1 = [-1,-1]; diag2 = [-1,1]; }
                else if (facing === 'D') { dir = [1,0]; diag1 = [1,-1]; diag2 = [1,1]; }
                else if (facing === 'L') { dir = [0,-1]; diag1 = [-1,-1]; diag2 = [1,-1]; }
                else if (facing === 'R') { dir = [0,1]; diag1 = [-1,1]; diag2 = [1,1]; }
                
                if (!dir) return []; // Safety check if facing is null

                for (let i = 1; i <= max; i++) {
                    let nr = r + dir[0] * i, nc = c + dir[1] * i;
                    if (!isValid(nr, nc)) break;
                    if (board[nr][nc]) {
                        if (board[nr][nc].player !== player) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        }
                        break;
                    }
                    moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                }
                for (let d of [diag1, diag2]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) {
                        if (!board[nr][nc]) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        } else if (board[nr][nc].player !== player) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        }
                    }
                }
                return moves;
            }},
            'Archer': { move: (r, c, board, player, _, facing) => {
                let moves = [];
                // Movement: 1 square vertically or horizontally (only to empty squares - cannot capture by landing)
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                // Shooting: 1 or 2 squares in facing direction
                let dir;
                if (facing === 'U') dir = [-1, 0];
                else if (facing === 'D') dir = [1, 0];
                else if (facing === 'L') dir = [0, -1];
                else if (facing === 'R') dir = [0, 1];

                if (dir) { // Only shoot if facing is set
                    for (let dist = 1; dist <= 2; dist++) {
                        let nr = r + dir[0] * dist, nc = c + dir[1] * dist;
                        if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== player) {
                            moves.push({ type: 'shoot', pos: [nr, nc], cost: 1 });
                        }
                    }
                }
                return moves;
            }},
            'Ballista': { move: (r, c, board, player, _, facing) => {
                let moves = [];
                // Movement: 1 square vertically or horizontally (only to empty squares - cannot capture by landing)
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                // Shooting: 1, 2, or 3 squares in specified directions based on facing
                let dirs;
                if (facing === 'U') dirs = [[-1,0], [-1,-1], [-1,1]];  // Up, Up-Left, Up-Right
                else if (facing === 'D') dirs = [[1,0], [1,-1], [1,1]]; // Down, Down-Left, Down-Right
                else if (facing === 'L') dirs = [[0,-1], [-1,-1], [1,-1]]; // Left, Up-Left, Down-Left
                else if (facing === 'R') dirs = [[0,1], [-1,1], [1,1]]; // Right, Up-Right, Down-Right

                if (dirs) { // Only shoot if facing is set
                    const maxRange = (ballistaRangeBoostActive[player] ? 4 : 3);
                    for (let dir of dirs) {
                        for (let dist = 1; dist <= maxRange; dist++) {
                            let nr = r + dir[0] * dist, nc = c + dir[1] * dist;
                            if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== player) {
                                moves.push({ type: 'shoot', pos: [nr, nc], cost: 1 });
                            }
                        }
                    }
                }
                return moves;
            }},
            'Elephantry': { move: (r, c, board, player, _, facing, movesLeft) => {
                let moves = [];
                // 1 point: move 1 square any direction (can capture by landing)
                for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) {
                        if (board[nr][nc] && board[nr][nc].type === 'Zombie') continue;
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                // 1 point: shoot 1 square in any direction (without moving)
                for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== player) {
                        moves.push({ type: 'shoot', pos: [nr, nc], cost: 1 });
                    }
                }
                // 2 points: move+shoot combination (show move positions that have shoot targets available)
                if (movesLeft >= 2) {
                    for (let d1 of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                        let nr = r + d1[0], nc = c + d1[1];
                        if (isValid(nr, nc) && !board[nr][nc]) {
                            // Check if there are any shoot targets from this position
                            let hasShootTargets = false;
                            for (let d2 of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = nr + d2[0], shootC = nc + d2[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== player) {
                                    hasShootTargets = true;
                                    break;
                                }
                            }
                            // Only add this move if there are shoot targets available
                            if (hasShootTargets) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'elephantryMoveShoot' });
                            }
                        }
                    }
                }
                return moves;
            }},
            'Pistolier': { move: (r, c, board, player, _, facing, movesLeft) => {
                let moves = [];
                // 1 point: move diagonally up to 3 squares
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    for (let i = 1; i <= 3; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            // Capturing by landing requires coin flip - handled in handleClick
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 1, special: 'pistolierCapture' });
                            }
                            break;
                        }
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                // 1 point: shoot diagonally up to 2 squares (without moving)
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    for (let i = 1; i <= 2; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'shoot', pos: [nr, nc], cost: 1 });
                            }
                            break;
                        }
                    }
                }
                // 2 points: move+shoot combination (move diagonally, then shoot 1 square diagonally from new position)
                if (movesLeft >= 2) {
                    for (let d1 of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                        for (let i = 1; i <= 3; i++) {
                            let nr = r + d1[0] * i, nc = c + d1[1] * i;
                            if (!isValid(nr, nc)) break;
                            if (board[nr][nc]) break; // Can't move through pieces for move+shoot

                            // Check if there are any shoot targets from this position (1 square diagonal)
                            let hasShootTargets = false;
                            for (let d2 of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = nr + d2[0], shootC = nc + d2[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== player) {
                                    hasShootTargets = true;
                                    break;
                                }
                            }
                            // Only add this move if there are shoot targets available
                            if (hasShootTargets) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'pistolierMoveShoot' });
                            }
                        }
                    }
                }
                return moves;
            }},
            'Fusilier': { move: (r, c, board, player, _, facing, movesLeft) => {
                let moves = [];
                const pieceKey = `${r},${c},${player}`;
                const piece = board[r][c];
                if (!piece) return moves;
                if (!(pieceKey in fusilierCrackShotCount)) {
                    fusilierCrackShotCount[pieceKey] = 3;
                }
                const shotBlocked = piece ? (fusilierShotLastTurn[player].has(piece) || fusilierShotThisTurn[player].has(piece)) : false;

                // 1 point: move up to 2 squares diagonally (1 or 2 squares)
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    // 1 square diagonal movement
                    let nr1 = r + d[0], nc1 = c + d[1];
                    if (isValid(nr1, nc1)) {
                        if (!board[nr1][nc1]) {
                            moves.push({ type: 'move', pos: [nr1, nc1], cost: 1 });
                        }
                    }

                    // 2 squares diagonal movement (can move through own pieces)
                    let intermediateR = r + d[0], intermediateC = c + d[1];
                    let nr2 = r + d[0] * 2, nc2 = c + d[1] * 2;

                    if (!isValid(nr2, nc2)) continue;

                    // Can move through own pieces on intermediate square
                    const intermediateBlocked = board[intermediateR] && board[intermediateR][intermediateC] && board[intermediateR][intermediateC].player !== player;

                    if (!intermediateBlocked) {
                        if (!board[nr2][nc2]) {
                            moves.push({ type: 'move', pos: [nr2, nc2], cost: 1 });
                        }
                    }
                }

                // 1 point: shoot forward and diagonally up to 3 squares (only if didn't shoot last turn)
                // Crack Shot increases range to 4 squares
                if (!shotBlocked) {
                    let directions = [];
                    if (facing === 'U') {
                        directions = [[-1,0], [-1,-1], [-1,1]]; // Up, Up-Left, Up-Right
                    } else if (facing === 'D') {
                        directions = [[1,0], [1,-1], [1,1]]; // Down, Down-Left, Down-Right
                    } else if (facing === 'L') {
                        directions = [[0,-1], [-1,-1], [1,-1]]; // Left, Up-Left, Down-Left
                    } else if (facing === 'R') {
                        directions = [[0,1], [-1,1], [1,1]]; // Right, Up-Right, Down-Right
                    }

                    const crackShotActive = fusilierCrackShotActive === piece;
                    const crackShotsRemaining = fusilierCrackShotCount[pieceKey] || 0;
                    const canAutoCrackShot = !crackShotActive && crackShotsRemaining > 0 && movesLeft >= 3;

                    const maxRange = crackShotActive ? 4 : 3;
                    for (let d of directions) {
                        for (let i = 1; i <= 4; i++) {
                            let shootR = r + d[0] * i, shootC = c + d[1] * i;
                            if (!isValid(shootR, shootC)) break;
                            if (board[shootR][shootC]) {
                                if (board[shootR][shootC].player !== player) {
                                    if (i <= maxRange) {
                                        moves.push({ type: 'shoot', pos: [shootR, shootC], cost: 1 });
                                    } else if (i === 4 && canAutoCrackShot) {
                                        moves.push({ type: 'shoot', pos: [shootR, shootC], cost: 3, special: 'fusilierCrackShotAuto' });
                                    }
                                }
                                break;
                            }
                        }
                    }
                }

                return moves;
            }},
            'Mercenary': { move: (r, c, board, player, _, facing) => {
                let moves = [];
                let dir, diag1, diag2;
                if (facing === 'U') { dir = [-1,0]; diag1 = [-1,-1]; diag2 = [-1,1]; }
                else if (facing === 'D') { dir = [1,0]; diag1 = [1,-1]; diag2 = [1,1]; }
                else if (facing === 'L') { dir = [0,-1]; diag1 = [-1,-1]; diag2 = [1,-1]; }
                else if (facing === 'R') { dir = [0,1]; diag1 = [-1,1]; diag2 = [1,1]; }

                if (!dir) return []; // Safety check

                let forward = [r + dir[0], c + dir[1]];
                if (isValid(forward[0], forward[1]) && !board[forward[0]][forward[1]]) {
                    moves.push({ type: 'move', pos: forward, cost: 1 });
                }
                for (let d of [diag1, diag2]) {
                    let diagonal = [r + d[0], c + d[1]];
                    if (isValid(diagonal[0], diagonal[1])) {
                        if (!board[diagonal[0]][diagonal[1]]) {
                            moves.push({ type: 'move', pos: diagonal, cost: 1 });
                        } else if (board[diagonal[0]][diagonal[1]].player !== player) {
                            moves.push({ type: 'move', pos: diagonal, cost: 1 });
                        }
                    }
                }
                let twoForward = [r + 2*dir[0], c + 2*dir[1]];
                let midForward = [r + dir[0], c + dir[1]];
                if (isValid(midForward[0], midForward[1]) && !board[midForward[0]][midForward[1]] && 
                    isValid(twoForward[0], twoForward[1]) && !board[twoForward[0]][twoForward[1]]) {
                    moves.push({ type: 'move', pos: twoForward, cost: 2 });
                }
                for (let d of [diag1, diag2]) {
                    let twoDiagonal = [r + 2*d[0], c + 2*d[1]];
                    let midDiagonal = [r + d[0], c + d[1]];
                    if (isValid(midDiagonal[0], midDiagonal[1]) && !board[midDiagonal[0]][midDiagonal[1]] && 
                        isValid(twoDiagonal[0], twoDiagonal[1])) {
                        if (!board[twoDiagonal[0]][twoDiagonal[1]] || board[twoDiagonal[0]][twoDiagonal[1]].player !== player) {
                            moves.push({ type: 'move', pos: twoDiagonal, cost: 2 });
                        }
                    }
                }
                return moves;
            }},
            'Ogre': { move: (r, c, board, player) => {
                let moves = [];
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                }
                for (let d of [[0,2], [0,-2], [2,0], [-2,0], [2,2], [2,-2], [-2,2], [-2,-2]]) {
                    let nr = r + d[0], nc = c + d[1];
                    let midr = r + d[0]/2, midc = c + d[1]/2;
                    if (isValid(nr, nc) && (!board[midr][midc] || (board[midr][midc].type !== 'Ogre' && board[midr][midc].player !== player))) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1, jump: [midr, midc] });
                    }
                }
                return moves;
            }},
            'Spectre': { move: (r, c, board, player) => {
                let moves = [];
                // Knight-like diagonal movement: 2 diagonal + 1 perpendicular
                // Moves through pieces
                const knightDiagMoves = [
                    [2, 2, [[3, 2], [2, 3]]], // NE diagonal +perpendicular
                    [2, -2, [[3, -2], [2, -3]]], // NW diagonal
                    [-2, 2, [[-3, 2], [-2, 3]]], // SE diagonal
                    [-2, -2, [[-3, -2], [-2, -3]]] // SW diagonal
                ];
                for (let [dr, dc, perps] of knightDiagMoves) {
                    for (let [pr, pc] of perps) {
                        let nr = r + pr, nc = c + pc;
                        if (isValid(nr, nc) && (!board[nr][nc] || board[nr][nc].player !== player)) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        }
                    }
                }
                return moves;
            }}
        };

        pieceTypes['Necromancer'] = {
            move: (r, c, board, player, firstMove, facing, movesLeft = 0) => {
                let moves = [];
                const piece = board[r][c];
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const nr = r + dr;
                        const nc = c + dc;
                        if (!isValid(nr, nc)) continue;
                        if (!board[nr][nc] || board[nr][nc].player !== player) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        }
                    }
                }
                const cooldown = necromancerShootCooldown.get(piece) || 0;
                if (movesLeft >= 2 && cooldown === 0) {
                    const directions = [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]];
                    for (const [dr, dc] of directions) {
                        for (let dist = 1; dist <= 2; dist++) {
                            const nr = r + dr * dist;
                            const nc = c + dc * dist;
                            if (!isValid(nr, nc)) break;
                            if (board[nr][nc]) {
                                if (board[nr][nc].player !== player) {
                                    moves.push({ type: 'shoot', pos: [nr, nc], cost: 2, special: 'necromancerShoot' });
                                }
                                break;
                            }
                        }
                    }
                }
                return moves;
            }
        };

        pieceTypes['Zombie'] = {
            move: () => []
        };

        let board = [];
        let currentPlayer = 'W';
        let selectedPiece = null;
        let validMoves = [];
        let movesLeft = 3;
        let movedPieces = new Set();
        let capturedPieces = { 'W': [], 'B': [] };
        let championCaptured = { 'W': false, 'B': false };
        let championsOnBackRow = { 'W': [], 'B': [] };
        let scores = { 'W': 0, 'B': 0 };
        let firstMoves = new Set();
        let reinforcementPending = null;
        let gameLog = [];

        function setDifficulty(level, element) {
            aiDifficulty = level;
            const buttons = document.querySelectorAll('#difficulty-selector button');
            buttons.forEach(btn => btn.classList.remove('selected-diff'));
            element.classList.add('selected-diff');

            if (level === 'Easy') {
                baseAiDepth = 10; // Increased by 60% (6 * 1.6 ≈ 10)
                pieceValueScale = 3.2064; // Increased by 60% (2.004 * 1.6)
            } else if (level === 'Medium') {
                baseAiDepth = 16; // Increased by 60% (10 * 1.6 = 16)
                pieceValueScale = 4.18176; // Increased by 60% (2.6136 * 1.6)
            } else if (level === 'Hard') {
                baseAiDepth = 21; // Increased by 60% (13 * 1.6 ≈ 21)
                pieceValueScale = 5.32224; // Increased by 60% (3.3264 * 1.6)
            }
            applyAiDepthForVariant();
        }

        function setOpponent(opponent, element) {
            selectedOpponent = opponent;
            const buttons = document.querySelectorAll('#opponent-selector button');
            buttons.forEach(btn => btn.classList.remove('selected-opponent'));
            element.classList.add('selected-opponent');
        }

        function setHintMode(mode, element) {
            hintModeEnabled = (mode === 'On');
            const buttons = document.querySelectorAll('#hint-selector button');
            buttons.forEach(btn => btn.classList.remove('selected-hint'));
            element.classList.add('selected-hint');
        }

        function getOpponentDisplayName() {
            return currentAiProfile ? currentAiProfile.displayName : 'AI';
        }

        function applyAiDepthForVariant() {
            // Apply difficulty-based depth limits that scale with selected difficulty level
            // Caps are now proportional to allow difficulty settings to apply properly
            if (gameVariant === '24s' || gameVariant === 'ccb') {
                // Cap at 70% of base depth for medium-sized variants
                aiMaxDepth = Math.max(3, Math.min(baseAiDepth, Math.floor(baseAiDepth * 0.7)));
            } else if (isLargeBoardVariant()) {
                // Cap at 30% of base depth for large variants (performance consideration)
                aiMaxDepth = Math.max(2, Math.min(baseAiDepth, Math.floor(baseAiDepth * 0.3)));
            } else {
                // Default variants can use full depth
                aiMaxDepth = Math.max(2, baseAiDepth);
            }
            updateAiPieceValues();
        }

        function startGame(variant) {
            gameVariant = variant;

            // Select AI profile based on player's choice
            if (selectedOpponent === 'Random') {
                const profileNames = Object.keys(AI_PROFILES);
                const randomIndex = Math.floor(Math.random() * profileNames.length);
                currentAiProfile = AI_PROFILES[profileNames[randomIndex]];
            } else {
                currentAiProfile = AI_PROFILES[selectedOpponent];
            }
            console.log(`AI Profile: ${currentAiProfile.name} - ${currentAiProfile.description}`);

            if (variant === '24s') {
                ROWS = 10;
                COLS = 14;
            } else if (variant === '36s') {
                ROWS = 10;
                COLS = 14;
            } else if (variant === '36s-expert') {
                ROWS = 10;
                COLS = 14;
            } else if (variant === '36s-elite') {
                ROWS = 10;
                COLS = 14;
            } else if (variant === 'ccb') {
                ROWS = 8;
                COLS = 12;
            }
            applyAiDepthForVariant();
            document.getElementById('start-menu').style.display = 'none';
            const landingHeader = document.getElementById('landing-header');
            if (landingHeader) landingHeader.style.display = 'none';
            const landingFooter = document.getElementById('landing-footer');
            if (landingFooter) landingFooter.style.display = 'none';
            document.getElementById('game-container').style.display = 'flex';
            const boardDiv = document.getElementById('board');
            boardDiv.style.gridTemplateColumns = `repeat(${COLS}, 50px)`;
            boardDiv.style.gridTemplateRows = `repeat(${ROWS}, 50px)`;
            // Start aggressive watchdog to ensure AI turn always triggers when needed (especially for 36s variants)
            if (!window.aiTurnWatch) {
                window.aiTurnWatch = setInterval(() => {
                    try {
                        // Don't trigger AI turn if game is paused
                        if (gamePaused) return;

                        // Aggressively check turn transition
                        if (currentPlayer === 'W' && !reinforcementPending && !aiPending && movesLeft <= 0) {
                            triggerAiTurn();
                        } else {
                            ensureAITurnIfNeeded();
                        }
                    } catch (e) {
                        // Silently ignore watchdog errors
                    }
                }, 200); // Check every 200ms for faster response
            }
            resetGame();
        }

        function initBoard() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(null));
            firstMoves.clear();
            championsOnBackRow = { 'W': [], 'B': [] };
            if (gameVariant === '24s') {
                const backRowW = ['Cavalry', 'Troll', 'Dragon', 'Wizard', 'Guard', 'Champion', 'King', 'Guard', 'Wizard', 'Dragon', 'Troll', 'Cavalry'];
                const backRowB = ['Cavalry', 'Troll', 'Dragon', 'Wizard', 'Guard', 'King', 'Champion', 'Guard', 'Wizard', 'Dragon', 'Troll', 'Cavalry']; // King and Champion swapped for AI
                // Place pieces in columns 1-12, leaving columns 0 and 13 empty
                for (let c = 1; c <= 12; c++) {
                    const idx = c - 1; // Index into the piece arrays (0-11)
                    board[8][c] = { type: 'Infantry', player: 'W', facing: 'U' };
                    board[9][c] = { type: backRowW[idx], player: 'W', facing: turnablePieces.includes(backRowW[idx]) ? 'U' : null };
                    board[0][c] = { type: backRowB[idx], player: 'B', facing: turnablePieces.includes(backRowB[idx]) ? 'D' : null };
                    board[1][c] = { type: 'Infantry', player: 'B', facing: 'D' };
                    if (backRowW[idx] === 'Troll') {
                        firstMoves.add(`9,${c},W`);
                    }
                    if (backRowB[idx] === 'Troll') {
                        firstMoves.add(`0,${c},B`);
                    }
                }
            } else if (gameVariant === '36s') {
                const backRowW = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'Champion', 'King', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry'];
                const backRowB = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'King', 'Champion', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry']; // King and Champion swapped for AI
                const secondRow = ['Cavalry', 'Troll', 'Dragon', 'Archer', 'Archer', 'Guard', 'Guard', 'Archer', 'Archer', 'Dragon', 'Troll', 'Cavalry'];
                // Place pieces in columns 1-12, leaving columns 0 and 13 empty
                for (let c = 1; c <= 12; c++) {
                    const idx = c - 1; // Index into the piece arrays (0-11)
                    board[7][c] = { type: 'Infantry', player: 'W', facing: 'U' };
                    board[8][c] = { type: secondRow[idx], player: 'W', facing: turnablePieces.includes(secondRow[idx]) ? 'U' : null };
                    board[9][c] = { type: backRowW[idx], player: 'W', facing: turnablePieces.includes(backRowW[idx]) ? 'U' : null };
                    board[0][c] = { type: backRowB[idx], player: 'B', facing: turnablePieces.includes(backRowB[idx]) ? 'D' : null };
                    board[1][c] = { type: secondRow[idx], player: 'B', facing: turnablePieces.includes(secondRow[idx]) ? 'D' : null };
                    board[2][c] = { type: 'Infantry', player: 'B', facing: 'D' };
                    if (secondRow[idx] === 'Troll') {
                        firstMoves.add(`8,${c},W`);
                        firstMoves.add(`1,${c},B`);
                    }
                }
            } else if (gameVariant === '36s-expert') {
                const backRowW = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'Champion', 'King', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry'];
                const backRowB = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'King', 'Champion', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry']; // King and Champion swapped for AI
                const secondRow = ['Cavalry', 'Troll', 'Dragon', 'Archer', 'Archer', 'Guard', 'Guard', 'Archer', 'Archer', 'Dragon', 'Troll', 'Cavalry'];
                const infantryRow = ['Infantry', 'Infantry', 'Mercenary', 'Infantry', 'Elephantry', 'Infantry', 'Infantry', 'Elephantry', 'Infantry', 'Mercenary', 'Infantry', 'Infantry'];
                // Place pieces in columns 1-12, leaving columns 0 and 13 empty
                for (let c = 1; c <= 12; c++) {
                    const idx = c - 1; // Index into the piece arrays (0-11)
                    board[7][c] = { type: infantryRow[idx], player: 'W', facing: turnablePieces.includes(infantryRow[idx]) ? 'U' : null };
                    board[8][c] = { type: secondRow[idx], player: 'W', facing: turnablePieces.includes(secondRow[idx]) ? 'U' : null };
                    board[9][c] = { type: backRowW[idx], player: 'W', facing: turnablePieces.includes(backRowW[idx]) ? 'U' : null };
                    board[0][c] = { type: backRowB[idx], player: 'B', facing: turnablePieces.includes(backRowB[idx]) ? 'D' : null };
                    board[1][c] = { type: secondRow[idx], player: 'B', facing: turnablePieces.includes(secondRow[idx]) ? 'D' : null };
                    board[2][c] = { type: infantryRow[idx], player: 'B', facing: turnablePieces.includes(infantryRow[idx]) ? 'D' : null };
                    if (secondRow[idx] === 'Troll') {
                        firstMoves.add(`8,${c},W`);
                        firstMoves.add(`1,${c},B`);
                    }
                }
            } else if (gameVariant === '36s-elite') {
                const backRowW = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'Champion', 'King', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry'];
                const backRowB = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'King', 'Champion', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry']; // King and Champion swapped for AI
                const secondRow = ['Cavalry', 'Troll', 'Dragon', 'Archer', 'Archer', 'Guard', 'Guard', 'Archer', 'Archer', 'Dragon', 'Troll', 'Cavalry'];
                const infantryRow = ['Infantry', 'Infantry', 'Mercenary', 'Infantry', 'Elephantry', 'Infantry', 'Infantry', 'Elephantry', 'Infantry', 'Mercenary', 'Infantry', 'Infantry'];
                for (let c = 1; c <= 12; c++) {
                    const idx = c - 1;
                    board[7][c] = { type: infantryRow[idx], player: 'W', facing: turnablePieces.includes(infantryRow[idx]) ? 'U' : null };
                    board[8][c] = { type: secondRow[idx], player: 'W', facing: turnablePieces.includes(secondRow[idx]) ? 'U' : null };
                    board[9][c] = { type: backRowW[idx], player: 'W', facing: turnablePieces.includes(backRowW[idx]) ? 'U' : null };
                    board[0][c] = { type: backRowB[idx], player: 'B', facing: turnablePieces.includes(backRowB[idx]) ? 'D' : null };
                    board[1][c] = { type: secondRow[idx], player: 'B', facing: turnablePieces.includes(secondRow[idx]) ? 'D' : null };
                    board[2][c] = { type: infantryRow[idx], player: 'B', facing: turnablePieces.includes(infantryRow[idx]) ? 'D' : null };
                    if (secondRow[idx] === 'Troll') {
                        firstMoves.add(`8,${c},W`);
                        firstMoves.add(`1,${c},B`);
                    }
                }
            } else if (gameVariant === 'ccb') {
                const backRowW = ['Cavalry', 'Troll', 'Dragon', 'Wizard', 'Guard', 'Champion', 'King', 'Guard', 'Wizard', 'Dragon', 'Troll', 'Cavalry'];
                const backRowB = ['Cavalry', 'Troll', 'Dragon', 'Wizard', 'Guard', 'King', 'Champion', 'Guard', 'Wizard', 'Dragon', 'Troll', 'Cavalry']; // King and Champion swapped for AI
                const infantryRow = Array(COLS).fill('Infantry');
                for (let c = 0; c < COLS; c++) {
                    board[6][c] = { type: infantryRow[c], player: 'W', facing: 'U' };
                    board[7][c] = { type: backRowW[c], player: 'W', facing: turnablePieces.includes(backRowW[c]) ? 'U' : null };
                    board[0][c] = { type: backRowB[c], player: 'B', facing: turnablePieces.includes(backRowB[c]) ? 'D' : null };
                    board[1][c] = { type: infantryRow[c], player: 'B', facing: 'D' };
                    if (backRowW[c] === 'Troll') {
                        firstMoves.add(`7,${c},W`);
                    }
                    if (backRowB[c] === 'Troll') {
                        firstMoves.add(`0,${c},B`);
                    }
                }
            }
            // Don't render board here - wait until coin toss determines starting player
        }

        function renderBoard() {
            const boardDiv = document.getElementById('board');
            boardDiv.innerHTML = '';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const square = document.createElement('div');
                    square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = r;
                    square.dataset.col = c;
                    if (board[r][c]) {
                        const pieceSpan = document.createElement('span');
                        pieceSpan.className = `piece ${board[r][c].player === 'W' ? 'white' : 'black'}`;
                        pieceSpan.textContent = pieceIcons[board[r][c].type];
                        pieceSpan.style.color = board[r][c].player === 'W' ? 'black' : 'white';
                        square.appendChild(pieceSpan);
                        if (board[r][c].facing) {
                            const arrow = document.createElement('span');
                            arrow.className = 'piece-arrow';
                            arrow.textContent = facingIcons[board[r][c].facing];
                            arrow.style.color = board[r][c].player === 'W' ? 'white' : 'black';
                            square.appendChild(arrow);
                        }
                    }
                    square.addEventListener('click', () => handleClick(r, c));
                    boardDiv.appendChild(square);
                    if (currentPlayer === 'B' && highlightSquares.some(([hr, hc]) => hr == r && hc == c)) {
                        square.classList.add('ai-move-highlight');
                    }
                }
            }
            updateControlButtons();
            highlightValidMoves();
            updateScoreDisplay();
            updateEndTurnButton();
            // Apply capture effects after rendering
            capturedSquares.forEach(([r, c]) => addCaptureEffect(r, c));
            capturedSquares = [];
            // Extra safety: ensure AI begins if needed (e.g., 36's edge cases)
            ensureAITurnIfNeeded();
        }

        function opponentHasWizards(player) {
            const opponent = player === 'W' ? 'B' : 'W';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] && board[r][c].type === 'Wizard' && board[r][c].player === opponent) {
                        return true;
                    }
                }
            }
            return false;
        }

        function updateControlButtons() {
            const turnButton = document.getElementById('turn-button');
            const turnMoveButton = document.getElementById('turn-move-button');
            const turnShootButton = document.getElementById('turn-shoot-button');
            const archerMoveDiagShootButton = document.getElementById('archer-move-diag-shoot-button');
            const archerDiag2ShootButton = document.getElementById('archer-diag2-shoot-button');
            const guardHonourButton = document.getElementById('guard-honour-button');
            const teleportButton = document.getElementById('teleport-button');
            const teleportSwapButton = document.getElementById('teleport-swap-button');
            const chargeButton = document.getElementById('charge-button');
            const infernoButton = document.getElementById('inferno-button'); // Get Inferno button
            const strafeButton = document.getElementById('strafe-button'); // Get Strafe button
            const summonSpectreButton = document.getElementById('summon-spectre-button'); // Get Summon Spectre button
            // Ballista special buttons
            let ballistaRangeButton = document.getElementById('ballista-range-button');
            let ballistaDoubleButton = document.getElementById('ballista-double-button');
            if (!ballistaRangeButton) {
                ballistaRangeButton = document.createElement('button');
                ballistaRangeButton.id = 'ballista-range-button';
                ballistaRangeButton.textContent = 'Extend Range';
                ballistaRangeButton.style.display = 'none';
                ballistaRangeButton.onclick = activateBallistaRange;
                document.getElementById('controls').insertBefore(ballistaRangeButton, document.getElementById('guard-honour-button'));
            }
            if (!ballistaDoubleButton) {
                ballistaDoubleButton = document.createElement('button');
                ballistaDoubleButton.id = 'ballista-double-button';
                ballistaDoubleButton.textContent = 'Double Time';
                ballistaDoubleButton.style.display = 'none';
                ballistaDoubleButton.onclick = activateBallistaDoubleTime;
                document.getElementById('controls').insertBefore(ballistaDoubleButton, document.getElementById('guard-honour-button'));
            }
            // Elephantry special buttons
            let elephantryChargeButton = document.getElementById('elephantry-charge-button');
            let elephantryExtendedButton = document.getElementById('elephantry-extended-button');
            let elephantryMoveShootButton = document.getElementById('elephantry-moveshoot-button');
            if (!elephantryChargeButton) {
                elephantryChargeButton = document.createElement('button');
                elephantryChargeButton.id = 'elephantry-charge-button';
                elephantryChargeButton.textContent = 'Charge';
                elephantryChargeButton.style.display = 'none';
                elephantryChargeButton.onclick = activateElephantryCharge;
                document.getElementById('controls').insertBefore(elephantryChargeButton, document.getElementById('guard-honour-button'));
            }
            if (!elephantryExtendedButton) {
                elephantryExtendedButton = document.createElement('button');
                elephantryExtendedButton.id = 'elephantry-extended-button';
                elephantryExtendedButton.textContent = 'Triple Shot';
                elephantryExtendedButton.style.display = 'none';
                elephantryExtendedButton.onclick = activateElephantryExtendedRange;
                document.getElementById('controls').insertBefore(elephantryExtendedButton, document.getElementById('guard-honour-button'));
            }
            if (!elephantryMoveShootButton) {
                elephantryMoveShootButton = document.createElement('button');
                elephantryMoveShootButton.id = 'elephantry-moveshoot-button';
                elephantryMoveShootButton.textContent = 'Move+Shoot';
                elephantryMoveShootButton.style.display = 'none';
                elephantryMoveShootButton.onclick = activateElephantryMoveShoot;
                document.getElementById('controls').insertBefore(elephantryMoveShootButton, document.getElementById('guard-honour-button'));
            }
            // Pistolier special buttons
            let pistolierMoveShootButton = document.getElementById('pistolier-moveshoot-button');
            if (!pistolierMoveShootButton) {
                pistolierMoveShootButton = document.createElement('button');
                pistolierMoveShootButton.id = 'pistolier-moveshoot-button';
                pistolierMoveShootButton.textContent = 'Move+Shoot';
                pistolierMoveShootButton.style.display = 'none';
                pistolierMoveShootButton.onclick = activatePistolierMoveShoot;
                document.getElementById('controls').insertBefore(pistolierMoveShootButton, document.getElementById('guard-honour-button'));
            }
            // Fusilier special buttons
            let fusilierCrackShotButton = document.getElementById('fusilier-crackshot-button');
            let fusilierStrafeButton = document.getElementById('fusilier-strafe-button');
            if (!fusilierCrackShotButton) {
                fusilierCrackShotButton = document.createElement('button');
                fusilierCrackShotButton.id = 'fusilier-crackshot-button';
                fusilierCrackShotButton.textContent = 'Crack Shot';
                fusilierCrackShotButton.style.display = 'none';
                fusilierCrackShotButton.onclick = activateFusilierCrackShot;
                document.getElementById('controls').insertBefore(fusilierCrackShotButton, document.getElementById('guard-honour-button'));
            }
            if (!fusilierStrafeButton) {
                fusilierStrafeButton = document.createElement('button');
                fusilierStrafeButton.id = 'fusilier-strafe-button';
                fusilierStrafeButton.textContent = 'Strafe';
                fusilierStrafeButton.style.display = 'none';
                fusilierStrafeButton.onclick = activateFusilierStrafe;
                document.getElementById('controls').insertBefore(fusilierStrafeButton, document.getElementById('guard-honour-button'));
            }
            // King summoning button
            let kingSummonButton = document.getElementById('king-summon-button');
            if (!kingSummonButton) {
                kingSummonButton = document.createElement('button');
                kingSummonButton.id = 'king-summon-button';
                kingSummonButton.textContent = 'Summon Unit';
                kingSummonButton.style.display = 'none';
                kingSummonButton.onclick = openKingSummonModal;
                document.getElementById('controls').insertBefore(kingSummonButton, document.getElementById('guard-honour-button'));
            }
            let necromancerZombieButton = document.getElementById('necromancer-summon-zombie-button');
            if (!necromancerZombieButton) {
                necromancerZombieButton = document.createElement('button');
                necromancerZombieButton.id = 'necromancer-summon-zombie-button';
                necromancerZombieButton.textContent = 'Summon Zombie';
                necromancerZombieButton.style.display = 'none';
                necromancerZombieButton.onclick = () => openNecromancerSummonModal('zombie');
                document.getElementById('controls').insertBefore(necromancerZombieButton, document.getElementById('guard-honour-button'));
            }
            let necromancerSpectreButton = document.getElementById('necromancer-summon-spectre-button');
            if (!necromancerSpectreButton) {
                necromancerSpectreButton = document.createElement('button');
                necromancerSpectreButton.id = 'necromancer-summon-spectre-button';
                necromancerSpectreButton.textContent = 'Summon Spectre';
                necromancerSpectreButton.style.display = 'none';
                necromancerSpectreButton.onclick = () => openNecromancerSummonModal('spectre');
                document.getElementById('controls').insertBefore(necromancerSpectreButton, document.getElementById('guard-honour-button'));
            }
            let necromancerTeleportButton = document.getElementById('necromancer-teleport-button');
            if (!necromancerTeleportButton) {
                necromancerTeleportButton = document.createElement('button');
                necromancerTeleportButton.id = 'necromancer-teleport-button';
                necromancerTeleportButton.textContent = 'Necro Teleport';
                necromancerTeleportButton.style.display = 'none';
                necromancerTeleportButton.onclick = activateTeleport;
                document.getElementById('controls').insertBefore(necromancerTeleportButton, document.getElementById('guard-honour-button'));
            }
            let championSummonButton = document.getElementById('champion-summon-button');
            if (!championSummonButton) {
                championSummonButton = document.createElement('button');
                championSummonButton.id = 'champion-summon-button';
                championSummonButton.textContent = 'Summon Necromancer';
                championSummonButton.style.display = 'none';
                championSummonButton.onclick = openChampionSummonModal;
                document.getElementById('controls').insertBefore(championSummonButton, document.getElementById('guard-honour-button'));
            }

            turnButton.style.display = 'none';
            turnMoveButton.style.display = 'none';
            turnShootButton.style.display = 'none';
            archerMoveDiagShootButton.style.display = 'none';
            archerDiag2ShootButton.style.display = 'none';
            guardHonourButton.style.display = 'none';
            teleportButton.style.display = 'none';
            teleportSwapButton.style.display = 'none';
            chargeButton.style.display = 'none';
            infernoButton.style.display = 'none'; // Hide Inferno button by default
            strafeButton.style.display = 'none'; // Hide Strafe button by default
            summonSpectreButton.style.display = 'none'; // Hide Summon Spectre button by default
            if (ballistaRangeButton) ballistaRangeButton.style.display = 'none';
            if (ballistaDoubleButton) ballistaDoubleButton.style.display = 'none';
            if (elephantryChargeButton) elephantryChargeButton.style.display = 'none';
            if (elephantryExtendedButton) elephantryExtendedButton.style.display = 'none';
            if (elephantryMoveShootButton) elephantryMoveShootButton.style.display = 'none';
            if (pistolierMoveShootButton) pistolierMoveShootButton.style.display = 'none';
            if (fusilierCrackShotButton) fusilierCrackShotButton.style.display = 'none';
            if (fusilierStrafeButton) fusilierStrafeButton.style.display = 'none';
            if (kingSummonButton) kingSummonButton.style.display = 'none';
            if (necromancerZombieButton) necromancerZombieButton.style.display = 'none';
            if (necromancerSpectreButton) necromancerSpectreButton.style.display = 'none';
            if (necromancerTeleportButton) necromancerTeleportButton.style.display = 'none';
            if (championSummonButton) championSummonButton.style.display = 'none';

            if (selectedPiece) {
                const piece = board[selectedPiece.row][selectedPiece.col];
                if (piece && piece.player === currentPlayer && !movedPieces.has(`${selectedPiece.row},${selectedPiece.col}`) && !lastAction?.move) {
                    if (turnablePieces.includes(piece.type)) {
                        turnButton.style.display = 'inline';
                        turnButton.disabled = movesLeft < turnCosts[piece.type];
                        if (piece.type === 'Infantry' || piece.type === 'Mercenary') {
                            turnMoveButton.style.display = 'inline';
                            turnMoveButton.disabled = movesLeft < 2;
                        }
                        if (piece.type === 'Archer') {
                            turnShootButton.style.display = 'inline';
                            turnShootButton.disabled = movesLeft < 2;
                        }
                    }
                    if (piece.type === 'Archer' && movesLeft >= 2) {
                        if (archerMoveDiagShootUsed[currentPlayer] < 2) {
                            archerMoveDiagShootButton.style.display = 'inline';
                            archerMoveDiagShootButton.disabled = false;
                        }
                        if (archerDiag2ShootUsed[currentPlayer] < 2) {
                            archerDiag2ShootButton.style.display = 'inline';
                            archerDiag2ShootButton.disabled = false;
                        }
                    }
                    if (piece.type === 'King' && !kingSpecialUsed[currentPlayer] && movesLeft >= 2) {
                        guardHonourButton.style.display = 'inline';
                        guardHonourButton.disabled = false;
                    }
                    // Show King summon button in Expert-tier modes
                    if (piece.type === 'King' && (gameVariant === '36s-expert' || gameVariant === '36s-elite') && movesLeft >= 2) {
                        const canSummonPistolier = pistoliersSummoned[currentPlayer] < 2;
                        const canSummonFusilier = fusiliersSummoned[currentPlayer] < 2;
                        if (canSummonPistolier || canSummonFusilier) {
                            kingSummonButton.style.display = 'inline';
                            kingSummonButton.disabled = false;
                        }
                    }
                    if (piece.type === 'Champion' && gameVariant === '36s-elite' && movesLeft >= 2) {
                        const maxNecromancers = 2;
                        if (necromancersSummoned[currentPlayer] < maxNecromancers) {
                            championSummonButton.style.display = 'inline';
                            championSummonButton.disabled = false;
                        }
                    }
                    if (piece.type === 'Necromancer' && gameVariant === '36s-elite') {
                        const pieceKey = board[selectedPiece.row][selectedPiece.col];
                        const teleportsUsed = getNecromancerTeleportCount(pieceKey);
                        if (movesLeft >= 2) {
                            const backRow = currentPlayer === 'W' ? ROWS - 1 : 0;
                            const availableBackRow = Array.from({ length: COLS }, (_, c) => c).some(c => !board[backRow][c]);
                            const maxZombies = getMaxZombies(currentPlayer);
                            if (zombiesSummoned[currentPlayer] < maxZombies && availableBackRow) {
                                necromancerZombieButton.style.display = 'inline';
                                necromancerZombieButton.disabled = false;
                            }
                            if (spectresSummoned[currentPlayer] < 2 && availableBackRow) {
                                necromancerSpectreButton.style.display = 'inline';
                                necromancerSpectreButton.disabled = false;
                            }
                            if (teleportsUsed < 2) {
                                necromancerTeleportButton.style.display = 'inline';
                                necromancerTeleportButton.disabled = false;
                            }
                        }
                    }
                    if (piece.type === 'Wizard' && wizardTeleportUsed[currentPlayer] < 2 && movesLeft >= 2) {
                        teleportButton.style.display = 'inline';
                        teleportButton.disabled = false;
                    }
                    if (piece.type === 'Wizard' && !wizardTeleportSwapUsed[currentPlayer] && movesLeft >= 2 && opponentHasWizards(currentPlayer)) {
                        teleportSwapButton.style.display = 'inline';
                        teleportSwapButton.disabled = false;
                    }
                    if (piece.type === 'Cavalry' && !cavalryChargeUsed[currentPlayer] && movesLeft >= 2) {
                        chargeButton.style.display = 'inline';
                        chargeButton.disabled = false;
                    }
                    // Show Inferno button
                    if (piece.type === 'Dragon' && !dragonInfernoUsed[currentPlayer] && movesLeft >= 2) {
                        infernoButton.style.display = 'inline';
                        infernoButton.disabled = false;
                    }
                    // Show Strafe button for Wizard or Dragon
                    if ((piece.type === 'Wizard' && wizardStrafeUsed[currentPlayer] < 2 && movesLeft >= 2) ||
                        (piece.type === 'Dragon' && dragonStrafeUsed[currentPlayer] < 2 && movesLeft >= 2)) {
                        strafeButton.style.display = 'inline';
                        strafeButton.disabled = false;
                    }
                    // Show Summon Spectre button for Wizard
                    if (piece.type === 'Wizard' && movesLeft >= 2 && spectresSummoned[currentPlayer] < 2 && !wizardSummonedThisTurn[currentPlayer]) {
                        const totalCaptured = capturedPieces['W'].length + capturedPieces['B'].length;
                        if (totalCaptured >= 5) {
                            summonSpectreButton.style.display = 'inline';
                            summonSpectreButton.disabled = false;
                        }
                    }
                    if (piece.type === 'Ballista' && movesLeft >= 2) {
                        if (!ballistaRangeBoostUsedThisTurn[currentPlayer]) {
                            ballistaRangeButton.style.display = 'inline';
                            ballistaRangeButton.disabled = false;
                        }
                        if (ballistaDoubleTimeUsed[currentPlayer] < 2) {
                            ballistaDoubleButton.style.display = 'inline';
                            ballistaDoubleButton.disabled = false;
                        }
                    }
                    if (piece.type === 'Elephantry' && movesLeft >= 2) {
                        const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
                        if (!elephantryChargeUsed.has(pieceKey)) {
                            elephantryChargeButton.style.display = 'inline';
                            elephantryChargeButton.disabled = false;
                        }
                        // Initialize shots remaining if not set
                        if (!(pieceKey in elephantryExtendedRangeShotsRemaining)) {
                            elephantryExtendedRangeShotsRemaining[pieceKey] = 3;
                        }
                        if (elephantryExtendedRangeShotsRemaining[pieceKey] > 0) {
                            elephantryExtendedButton.style.display = 'inline';
                            elephantryExtendedButton.disabled = false;
                            elephantryExtendedButton.textContent = `Triple Shot (${elephantryExtendedRangeShotsRemaining[pieceKey]})`;
                        }
                        // Show Move+Shoot button if there are valid move+shoot positions
                        const moveShootMoves = validMoves.filter(m => m.special === 'elephantryMoveShoot');
                        if (moveShootMoves.length > 0) {
                            elephantryMoveShootButton.style.display = 'inline';
                            elephantryMoveShootButton.disabled = false;
                        }
                    }
                    if (piece.type === 'Pistolier' && movesLeft >= 2) {
                        // Show Move+Shoot button if there are valid move+shoot positions
                        const moveShootMoves = validMoves.filter(m => m.special === 'pistolierMoveShoot');
                        if (moveShootMoves.length > 0) {
                            pistolierMoveShootButton.style.display = 'inline';
                            pistolierMoveShootButton.disabled = false;
                        }
                    }
                    if (piece.type === 'Fusilier' && movesLeft >= 2) {
                        const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
                        // Initialize counts if not set
                        if (!(pieceKey in fusilierCrackShotCount)) {
                            fusilierCrackShotCount[pieceKey] = 3;
                        }
                        if (!(pieceKey in fusilierStrafeCount)) {
                            fusilierStrafeCount[pieceKey] = 2;
                        }
                        const fusilierPiece = piece;
                        const fusilierOnCooldown = fusilierShotLastTurn[currentPlayer].has(fusilierPiece) ||
                            fusilierShotThisTurn[currentPlayer].has(fusilierPiece);
                        // Show Crack Shot button if uses remaining and not on cooldown
                        if (fusilierCrackShotCount[pieceKey] > 0 && !fusilierOnCooldown) {
                            fusilierCrackShotButton.style.display = 'inline';
                            fusilierCrackShotButton.disabled = false;
                            fusilierCrackShotButton.textContent = `Crack Shot (${fusilierCrackShotCount[pieceKey]})`;
                        } else {
                            fusilierCrackShotButton.style.display = 'none';
                        }
                        // Show Strafe button if uses remaining
                        if (fusilierStrafeCount[pieceKey] > 0) {
                            fusilierStrafeButton.style.display = 'inline';
                            fusilierStrafeButton.disabled = false;
                            fusilierStrafeButton.textContent = `Strafe (${fusilierStrafeCount[pieceKey]})`;
                        }
                    }
                }
            }
        }

        function updateScoreDisplay() {
            document.getElementById('score-display').textContent = `Player Score: ${scores['W']} | ${getOpponentDisplayName()} Score: ${scores['B']}`;
        }

        function showPieceInfo(piece, player) {
            const infoBox = document.getElementById('info-box');
            if (!piece) {
                infoBox.style.display = 'none';
                infoBox.innerHTML = '';
                return;
            }
            const info = pieceInfo[piece.type];
            infoBox.style.display = 'block';
            infoBox.innerHTML = `
                <strong>${player === 'W' ? 'White' : 'Black'} ${piece.type}</strong><br>
                <strong>Move Points:</strong> ${info.points}<br>
                <strong>Score Value:</strong> ${pieceValues[piece.type]} points<br>
                <strong>Extra Info:</strong> ${info.extra}${piece.facing ? `<br><strong>Facing:</strong> ${piece.facing} (${facingIcons[piece.facing]})` : ''}
            `;
        }

        function updateGameLog() {
            const logDiv = document.getElementById('game-log');
            logDiv.innerHTML = gameLog.join('<br>');
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function getValidTurnDirections(currentFacing) {
            const validDirections = {
                'U': ['L', 'R'],
                'D': ['L', 'R'],
                'L': ['U', 'D'],
                'R': ['U', 'D']
            };
            return validDirections[currentFacing] || [];
        }

        function activateGuardOfHonour() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'King' && !kingSpecialUsed[currentPlayer]) {
                guardOfHonourMode = true;
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
            }
        }

        function activateTeleport() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece) return;
            let canTeleport = false;
            if (piece.type === 'Wizard' && wizardTeleportUsed[currentPlayer] < 2) {
                canTeleport = true;
            } else if (piece.type === 'Necromancer' && gameVariant === '36s-elite') {
                if (getNecromancerTeleportCount(piece) < 2) {
                    canTeleport = true;
                }
            }
            if (canTeleport) {
                teleportMode = true;
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
            }
        }

        function activateTeleportSwap() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || wizardTeleportSwapUsed[currentPlayer]) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Wizard' && opponentHasWizards(currentPlayer)) {
                teleportSwapMode = true;
                validMoves = getValidTeleportSwapMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
            }
        }

        function activateCharge() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || cavalryChargeUsed[currentPlayer]) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Cavalry') {
                chargeMode = true;
                validMoves = getValidChargeMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
            }
        }

        function activateInferno() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || dragonInfernoUsed[currentPlayer]) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Dragon') {
                infernoMode = true;
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col); // This will now get Inferno moves
                renderBoard();
            }
        }

        function activateElephantryCharge() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
            if (piece.type === 'Elephantry' && !elephantryChargeUsed.has(pieceKey)) {
                elephantryChargeMode = true;
                validMoves = getElephantryChargeMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
            }
        }

        function activateElephantryExtendedRange() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
            if (piece.type === 'Elephantry') {
                if (!(pieceKey in elephantryExtendedRangeShotsRemaining)) {
                    elephantryExtendedRangeShotsRemaining[pieceKey] = 3;
                }
                if (elephantryExtendedRangeShotsRemaining[pieceKey] > 0) {
                    // Deduct the 2 points immediately when activating Triple Shot
                    movesLeft -= 2;
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    elephantryExtendedRangeActive = true;
                    validMoves = getElephantryExtendedRangeMoves(selectedPiece.row, selectedPiece.col);
                    updateStatus();
                    updateEndTurnButton();
                    renderBoard();
                }
            }
        }

        function activateElephantryMoveShoot() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Elephantry') {
                // Filter valid moves to only show move+shoot positions
                validMoves = validMoves.filter(m => m.special === 'elephantryMoveShoot');
                renderBoard();
            }
        }

        function activatePistolierMoveShoot() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Pistolier') {
                // Filter valid moves to only show move+shoot positions
                validMoves = validMoves.filter(m => m.special === 'pistolierMoveShoot');
                renderBoard();
            }
        }

        function activateFusilierCrackShot() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
            if (piece.type === 'Fusilier' && fusilierCrackShotCount[pieceKey] > 0) {
                // Deduct points and usage
                movesLeft -= 2;
                fusilierCrackShotCount[pieceKey]--;
                lastAction = { move: true };
                movedPieces.add(pieceKey);

                // Activate extended range shooting (temporarily increase range by +1)
                fusilierCrackShotActive = piece;
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);

                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier activated Crack Shot (+1 range)`);
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                renderBoard();
                checkGameOver();
                if (movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                }
            }
        }

        function activateFusilierStrafe() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
            if (piece.type === 'Fusilier' && fusilierStrafeCount[pieceKey] > 0) {
                // Deduct points and usage
                movesLeft -= 2;
                fusilierStrafeCount[pieceKey]--;
                lastAction = { move: true };
                movedPieces.add(pieceKey);

                // Show strafe move options (1 square orthogonal, no capture)
                fusilierStrafeActive = true;
                validMoves = getFusilierStrafeMoves(selectedPiece.row, selectedPiece.col);

                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier activated Strafe`);
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                renderBoard();
            }
        }

        function getFusilierStrafeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            let moves = [];
            // Move 1 square orthogonally without capturing
            for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                let nr = row + d[0], nc = col + d[1];
                if (isValid(nr, nc) && !board[nr][nc]) {
                    moves.push({ type: 'move', pos: [nr, nc], cost: 0, special: 'fusilierStrafe' });
                }
            }
            return moves;
        }

        function getValidTeleportSwapMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            const opponent = player === 'W' ? 'B' : 'W';
            const color = (row + col) % 2;
            let moves = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] && board[r][c].type === 'Wizard' && board[r][c].player === opponent && (r + c) % 2 === color) {
                        moves.push({ type: 'teleportSwap', pos: [r, c], cost: 2 });
                    }
                }
            }
            return moves;
        }

        function getValidChargeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            let moves = [];
            for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                let r = row, c = col;
                while (true) {
                    r += d[0];
                    c += d[1];
                    if (!isValid(r, c)) break;
                    if (board[r][c]) {
                        if (board[r][c].player !== player) {
                            moves.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                        }
                        break;
                    }
                    moves.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                }
            }
            return moves;
        }

        function getElephantryChargeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            const facing = piece.facing;
            const pieceKey = `${row},${col},${player}`;
            let moves = [];

            if (elephantryChargeUsed.has(pieceKey)) return moves;

            // Determine forward directions based on facing
            let directions = [];
            if (facing === 'U') {
                directions = [[-1,0], [-1,-1], [-1,1]]; // Up, Up-Left, Up-Right
            } else if (facing === 'D') {
                directions = [[1,0], [1,-1], [1,1]]; // Down, Down-Left, Down-Right
            } else if (facing === 'L') {
                directions = [[0,-1], [-1,-1], [1,-1]]; // Left, Up-Left, Down-Left
            } else if (facing === 'R') {
                directions = [[0,1], [-1,1], [1,1]]; // Right, Up-Right, Down-Right
            }

            for (let d of directions) {
                let capturesInPath = [];
                let canCharge = true;
                let finalPos = null;

                // Check all 3 squares in this direction
                for (let dist = 1; dist <= 3; dist++) {
                    let r = row + d[0] * dist;
                    let c = col + d[1] * dist;

                    if (!isValid(r, c)) {
                        canCharge = false;
                        break;
                    }

                    const target = board[r][c];
                    if (target) {
                        // Cannot charge through Spectre or Zombies
                        if (target.type === 'Spectre' || target.type === 'Zombie') {
                            canCharge = false;
                            break;
                        }

                        // Can capture enemy pieces
                        if (target.player !== player) {
                            capturesInPath.push([r, c, target.type]);
                            // Stop on Elephantry, Ogre, Troll, or Dragon (but still capture them)
                            if (target.type === 'Elephantry' || target.type === 'Ogre' || target.type === 'Troll' || target.type === 'Dragon') {
                                finalPos = [r, c];
                                break;
                            }
                        } else {
                            // Cannot charge through own pieces
                            canCharge = false;
                            break;
                        }
                    }

                    // If we've gone 3 squares without stopping, this is the final position
                    if (dist === 3) {
                        finalPos = [r, c];
                    }
                }

                if (canCharge && finalPos) {
                    moves.push({
                        type: 'move',
                        pos: finalPos,
                        cost: 2,
                        special: 'elephantryCharge',
                        captures: capturesInPath
                    });
                }
            }

            return moves;
        }

        function getElephantryExtendedRangeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            const pieceKey = `${row},${col},${player}`;
            let moves = [];

            // Initialize if not set
            if (!(pieceKey in elephantryExtendedRangeShotsRemaining)) {
                elephantryExtendedRangeShotsRemaining[pieceKey] = 3;
            }

            if (elephantryExtendedRangeShotsRemaining[pieceKey] <= 0) return moves;

            // Can shoot 2 squares in any direction
            for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                for (let dist = 1; dist <= 2; dist++) {
                    let nr = row + d[0] * dist;
                    let nc = col + d[1] * dist;
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== player) {
                        moves.push({
                            type: 'shoot',
                            pos: [nr, nc],
                            cost: 0, // No additional cost per shot - already paid 2 points on activation
                            special: 'elephantryExtendedRange',
                            shotsRemaining: elephantryExtendedRangeShotsRemaining[pieceKey]
                        });
                    }
                }
            }

            return moves;
        }

        function handleClick(row, col) {
            if (currentPlayer !== 'W' || reinforcementPending || zombieAutoAdvanceInProgress) return;
            const piece = board[row][col];

            if (isAnySpecialModeActive()) {
                if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                    cancelSpecialModes({ resetSelection: false });
                    return;
                }
                if (!selectedPiece) {
                    cancelSpecialModes();
                    return;
                }
                // Don't auto-cancel when clicking different squares - let mode handlers decide
                // if (selectedPiece && (selectedPiece.row !== row || selectedPiece.col !== col)) {
                //     cancelSpecialModes();
                // }
            }

            // Handle Inferno Mode
            if (infernoMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'inferno');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const toRow = move.pos[0];
                    const toCol = move.pos[1];

                    // 1. Perform the initial 1-square move (handles landing capture)
                    movePiece(fromRow, fromCol, toRow, toCol, null);
                    
                    // 2. Perform the adjacent Inferno captures
                    performInfernoCapture(toRow, toCol, currentPlayer);

                    // 3. Update state
                    dragonInfernoUsed[currentPlayer] = true;
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    movedPieces.add(`${toRow},${toCol}`);
                    
                    selectedPiece = null;
                    validMoves = [];
                    infernoMode = false;
                    
                    // 4. Re-render and check game state
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
                else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            
            // Handle Archer Turn+Shoot mode (after confirming turn)
            if (turnAndShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'shoot');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    shootPiece(fromRow, fromCol, row, col);
                    movesLeft -= move.cost; // spend second point
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    selectedPiece = null;
                    validMoves = [];
                    turnAndShootMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Archer Move + Diagonal (1) Shoot special
            if (archerMoveDiagMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'move');
                if (move && movesLeft >= 1) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    // Perform the 1-point move first
                    movePiece(fromRow, fromCol, row, col, move.jump);
                    movesLeft -= 1;
                    // Prepare diagonal 1-square shoot options from new position
                    selectedPiece = { row, col };
                    const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                    let options = [];
                    for (let d of dirs) {
                        const nr = row + d[0], nc = col + d[1];
                        if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== currentPlayer) {
                            options.push({ type: 'shoot', pos: [nr, nc], cost: 1, special: 'archerDiag1' });
                        }
                    }
                    validMoves = options;
                    // Switch to the second phase: select diagonal shot
                    archerMoveDiagMode = false;
                    archerDiagShootSelectMode = true;
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle second phase of Archer Move + Diagonal (1) Shoot
            if (archerDiagShootSelectMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'shoot');
                if (move && movesLeft >= move.cost) {
                    const currentRow = selectedPiece.row;
                    const currentCol = selectedPiece.col;
                    shootPiece(currentRow, currentCol, row, col);
                    movesLeft -= move.cost; // spend second point
                    lastAction = { move: true };
                    // Mark both original and current squares as moved if we have the original
                    if (archerMoveDiagStart) {
                        movedPieces.add(`${archerMoveDiagStart.row},${archerMoveDiagStart.col}`);
                    }
                    movedPieces.add(`${currentRow},${currentCol}`);
                    archerMoveDiagShootUsed[currentPlayer]++;
                    selectedPiece = null;
                    validMoves = [];
                    archerDiagShootSelectMode = false;
                    archerMoveDiagStart = null;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Archer Diagonal 2-square Shot special
            if (archerDiag2ShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'shoot');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    shootPiece(fromRow, fromCol, row, col);
                    movesLeft -= move.cost; // cost 2
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    archerDiag2ShootUsed[currentPlayer]++;
                    selectedPiece = null;
                    validMoves = [];
                    archerDiag2ShootMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Strafe special move
            if (summonSpectreMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'summonSpectre');
                if (move && movesLeft >= move.cost) {
                    const wizardRow = selectedPiece.row;
                    const wizardCol = selectedPiece.col;
                    const wizardPiece = board[wizardRow][wizardCol];

                    // Store placement info for callback
                    const summonRow = row;
                    const summonCol = col;

                    // Deduct points immediately
                    movesLeft -= move.cost; // cost 2

                    // Trigger coin toss
                    performCoinToss(
                        'Summon Spectre',
                        'Attempting to summon a Spectre...',
                        (success) => {
                            if (success) {
                                // Place Spectre at selected location
                                board[summonRow][summonCol] = { type: 'Spectre', player: currentPlayer };
                                spectresSummoned[currentPlayer]++;
                                wizardSummonedThisTurn[currentPlayer] = true;

                                // Mark wizard as unable to move next turn
                                wizardCannotMoveNextTurn[currentPlayer].add(`${wizardRow},${wizardCol}`);

                                // Award 3 bonus points for successful summoning
                                scores[currentPlayer] += 3;
                                updateScoreDisplay();

                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} summoned a Spectre! (+3 bonus points)`);
                            } else {
                                // Failed summoning
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} failed to summon a Spectre.`);
                            }

                            selectedPiece = null;
                            validMoves = [];
                            summonSpectreMode = false;
                            showPieceInfo(null);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            checkGameOver();
                            if (movesLeft === 0 && !reinforcementPending) {
                                triggerAiTurn();
                            }
                        }
                    );
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            if (strafeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'strafe');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const piece = board[fromRow][fromCol];

                    // Perform the move
                    movePiece(fromRow, fromCol, row, col);
                    movesLeft -= move.cost; // cost 2
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    movedPieces.add(`${row},${col}`); // Mark destination as moved so piece can't move again

                    // Increment usage counter based on piece type
                    if (piece.type === 'Wizard') {
                        wizardStrafeUsed[currentPlayer]++;
                    } else if (piece.type === 'Dragon') {
                        dragonStrafeUsed[currentPlayer]++;
                    }

                    selectedPiece = null;
                    validMoves = [];
                    strafeMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Fusilier Strafe special move
            if (fusilierStrafeActive && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'fusilierStrafe');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;

                    // Perform the move (no capture)
                    board[row][col] = board[fromRow][fromCol];
                    board[fromRow][fromCol] = null;

                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier strafed to (${row},${col})`);

                    selectedPiece = null;
                    validMoves = [];
                    fusilierStrafeActive = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            if (turnAndMoveMode && selectedPiece && (board[selectedPiece.row][selectedPiece.col]?.type === 'Infantry' || board[selectedPiece.row][selectedPiece.col]?.type === 'Mercenary')) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col);
                if (move && move.type === 'move' && movesLeft >= 1) {
                    movePiece(selectedPiece.row, selectedPiece.col, row, col, move.jump);
                    movesLeft -= 1;
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    turnAndMoveMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (guardOfHonourMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'swap');
                if (move && movesLeft >= move.cost) {
                    const guardRow = move.pos[0];
                    const guardCol = move.pos[1];
                    const guard = board[guardRow][guardCol];
                    board[guardRow][guardCol] = board[selectedPiece.row][selectedPiece.col];
                    board[selectedPiece.row][selectedPiece.col] = guard;
                    kingSpecialUsed[currentPlayer] = true;
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Guard of Honour to swap King and Guard at (${selectedPiece.row},${selectedPiece.col}) and (${guardRow},${guardCol})`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${guardRow},${guardCol}`);
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    selectedPiece = null;
                    validMoves = [];
                    guardOfHonourMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    checkSupremacy(currentPlayer);
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (teleportMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'teleport');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const teleportPiece = board[fromRow][fromCol];
                    board[move.pos[0]][move.pos[1]] = teleportPiece;
                    board[fromRow][fromCol] = null;
                    if (teleportPiece.type === 'Wizard') {
                        wizardTeleportUsed[currentPlayer]++;
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Wizard from (${fromRow},${fromCol}) to (${move.pos[0]},${move.pos[1]})`);
                    } else if (teleportPiece.type === 'Necromancer') {
                        incrementNecromancerTeleportCount(teleportPiece);
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Necromancer from (${fromRow},${fromCol}) to (${move.pos[0]},${move.pos[1]})`);
                    } else {
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported ${teleportPiece.type} from (${fromRow},${fromCol}) to (${move.pos[0]},${move.pos[1]})`);
                    }
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                    selectedPiece = null;
                    validMoves = [];
                    teleportMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (teleportSwapMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'teleportSwap');
                if (move && movesLeft >= move.cost) {
                    const opponentWizardRow = move.pos[0];
                    const opponentWizardCol = move.pos[1];
                    const playerWizard = board[selectedPiece.row][selectedPiece.col];
                    const opponentWizard = board[opponentWizardRow][opponentWizardCol];
                    board[opponentWizardRow][opponentWizardCol] = playerWizard;
                    board[selectedPiece.row][selectedPiece.col] = opponentWizard;
                    wizardTeleportSwapUsed[currentPlayer] = true;
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Teleport Swap to swap Wizard at (${selectedPiece.row},${selectedPiece.col}) with opponent's Wizard at (${opponentWizardRow},${opponentWizardCol})`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    movedPieces.add(`${opponentWizardRow},${opponentWizardCol}`);
                    selectedPiece = null;
                    validMoves = [];
                    teleportSwapMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (chargeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'move');
                if (move && movesLeft >= move.cost) {
                    movePiece(selectedPiece.row, selectedPiece.col, row, col, move.jump);
                    cavalryChargeUsed[currentPlayer] = true;
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Charge to move Cavalry from (${selectedPiece.row},${selectedPiece.col}) to (${row},${col})`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    chargeMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Elephantry Charge
            if (elephantryChargeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'elephantryCharge');
                if (move && movesLeft >= move.cost) {
                    const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;

                    // Process all captures along the path
                    if (move.captures && move.captures.length > 0) {
                        for (let [captureRow, captureCol, captureType] of move.captures) {
                            const capturedPiece = board[captureRow][captureCol];
                            if (capturedPiece) {
                                capturedSquares.push([captureRow, captureCol]);
                                capturedPieces[currentPlayer].push(capturedPiece);
                                const captureValue = pieceValues[capturedPiece.type];
                                scores[currentPlayer] += captureValue;
                                registerScoreGain(currentPlayer, captureValue);
                                registerPieceLoss(capturedPiece.player, capturedPiece.type);
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry charged and captured ${capturedPiece.type} (+${captureValue} points) at (${captureRow},${captureCol})`);

                                if (capturedPiece.type === 'Champion') {
                                    championCaptured[capturedPiece.player] = true;
                                }
                                if (capturedPiece.type === 'King') {
                                    endGame(currentPlayer);
                                }
                                board[captureRow][captureCol] = null;
                            }
                        }
                    }

                    // Move the Elephantry to final position
                    movePiece(fromRow, fromCol, row, col, null);
                    elephantryChargeUsed.add(pieceKey);
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Elephantry Charge from (${fromRow},${fromCol}) to (${row},${col})`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    elephantryChargeMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    updateCapturedPiecesDisplay();
                    updateScoreDisplay();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Pistolier move+shoot final shot selection
            if (pistolierMoveShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'pistolierMoveShootFinal');
                if (move) {
                    // Execute the shoot
                    shootPiece(selectedPiece.row, selectedPiece.col, row, col);
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier shot at (${row},${col})`);

                    // Clean up
                    pistolierMoveShootMode = false;
                    pistolierMoveShootPosition = null;
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Elephantry move+shoot final shot selection
            if (elephantryMoveShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'elephantryMoveShootFinal');
                if (move) {
                    // Execute the shoot
                    shootPiece(selectedPiece.row, selectedPiece.col, row, col);
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry shot at (${row},${col})`);

                    // Clean up
                    elephantryMoveShootMode = false;
                    elephantryMoveShootPosition = null;
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Elephantry Triple Shot
            if (elephantryExtendedRangeActive && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'elephantryExtendedRange');
                if (move) {
                    const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
                    const targetRow = row;
                    const targetCol = col;
                    const elephantryRow = selectedPiece.row;
                    const elephantryCol = selectedPiece.col;

                    // Trigger coin flip for this shot
                    performCoinToss(
                        'Elephantry Triple Shot',
                        `Shot ${4 - elephantryExtendedRangeShotsRemaining[pieceKey]}/3: Attempting shot at (${targetRow},${targetCol})...`,
                        (success) => {
                            if (success) {
                                // Successful hit - capture the target
                                const targetPiece = board[targetRow][targetCol];
                                if (targetPiece && targetPiece.player !== currentPlayer) {
                                    capturedSquares.push([targetRow, targetCol]);
                                    capturedPieces[currentPlayer].push(targetPiece);
                                    const captureValue = pieceValues[targetPiece.type];
                                    scores[currentPlayer] += captureValue;
                                    registerScoreGain(currentPlayer, captureValue);
                                    registerPieceLoss(targetPiece.player, targetPiece.type);
                                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry triple shot hit! Captured ${targetPiece.type} (+${captureValue} points)`);

                                    if (targetPiece.type === 'Champion') {
                                        championCaptured[targetPiece.player] = true;
                                    }
                                    if (targetPiece.type === 'King') {
                                        endGame(currentPlayer);
                                    }
                                    board[targetRow][targetCol] = null;
                                    updateCapturedPiecesDisplay();
                                    updateScoreDisplay();
                                    checkSupremacy(currentPlayer);
                                }
                            } else {
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry triple shot missed at (${targetRow},${targetCol}).`);
                            }

                            // Decrement shots remaining (whether hit or miss)
                            elephantryExtendedRangeShotsRemaining[pieceKey]--;

                            // Update display
                            updateGameLog();
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();

                            // If shots remain in this Triple Shot usage, keep the mode active
                            if (elephantryExtendedRangeShotsRemaining[pieceKey] > 0) {
                                validMoves = getElephantryExtendedRangeMoves(elephantryRow, elephantryCol);
                                renderBoard();
                            } else {
                                // All 3 shots used, end the Triple Shot mode
                                elephantryExtendedRangeActive = false;
                                selectedPiece = null;
                                validMoves = [];
                                showPieceInfo(null);
                                renderBoard();
                            }

                            checkGameOver();
                            if (movesLeft === 0 && !reinforcementPending) {
                                triggerAiTurn();
                            }
                        }
                    );
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            if (!selectedPiece && piece && piece.player === 'W' && !movedPieces.has(`${row},${col}`)) {
                selectedPiece = { row, col };
                validMoves = getValidMoves(row, col);
                showPieceInfo(piece, piece.player);
                lastAction = null;
                renderBoard();
            } else if (selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col);
                if (move && movesLeft >= move.cost) {
                    if (move.type === 'move') {
                        // Handle Pistolier capturing by landing - requires coin flip
                        if (move.special === 'pistolierCapture') {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const toRow = row;
                            const toCol = col;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            // Trigger coin toss for capture
                            performCoinToss(
                                'Pistolier Capture',
                                `Attempting to capture at (${toRow},${toCol})...`,
                                (success) => {
                                    if (success) {
                                        // Successfully captured
                                        movePiece(fromRow, fromCol, toRow, toCol, null);
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier successfully captured by landing!`);
                                    } else {
                                        // Failed to capture - still move but don't capture
                                        const targetPiece = board[toRow][toCol];
                                        board[toRow][toCol] = board[fromRow][fromCol];
                                        board[fromRow][fromCol] = null;
                                        // Piece stays in place, no capture
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier failed to capture - move blocked.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    movedPieces.add(`${toRow},${toCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                }
                            );
                            return;
                        }

                        // Handle Pistolier move+shoot combination - enter shoot selection mode
                        if (move.special === 'pistolierMoveShoot') {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            // Move to the position first
                            movePiece(fromRow, fromCol, row, col, null);
                            movesLeft -= move.cost;
                            movedPieces.add(`${fromRow},${fromCol}`);
                            movedPieces.add(`${row},${col}`);
                            lastAction = { move: true };

                            // Enter shoot selection mode
                            pistolierMoveShootMode = true;
                            pistolierMoveShootPosition = { row, col };
                            selectedPiece = { row, col };

                            // Generate shoot targets from new position (1 square diagonal only)
                            validMoves = [];
                            for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = row + d[0], shootC = col + d[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== currentPlayer) {
                                    validMoves.push({ type: 'shoot', pos: [shootR, shootC], cost: 0, special: 'pistolierMoveShootFinal' });
                                }
                            }

                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier moved to (${row},${col}), select shoot target...`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            return;
                        }

                        // Handle Elephantry move+shoot combination - enter shoot selection mode
                        if (move.special === 'elephantryMoveShoot') {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            // Move to the position first
                            movePiece(fromRow, fromCol, row, col, null);
                            movesLeft -= move.cost;
                            movedPieces.add(`${fromRow},${fromCol}`);
                            movedPieces.add(`${row},${col}`);
                            lastAction = { move: true };

                            // Enter shoot selection mode
                            elephantryMoveShootMode = true;
                            elephantryMoveShootPosition = { row, col };
                            selectedPiece = { row, col };

                            // Generate shoot targets from new position
                            validMoves = [];
                            for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = row + d[0], shootC = col + d[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== currentPlayer) {
                                    validMoves.push({ type: 'shoot', pos: [shootR, shootC], cost: 0, special: 'elephantryMoveShootFinal' });
                                }
                            }

                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry moved to (${row},${col}), select shoot target...`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            return;
                        }

                        // Check if capturing a Spectre - requires coin toss (except for Wizards/Spectres)
                        const targetPiece = board[row][col];
                        const attackingPiece = board[selectedPiece.row][selectedPiece.col];
                        const isCapturingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                        const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';

                        if (isCapturingSpectre && !captureExempt) {
                            // Store move info for callback
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const toRow = row;
                            const toCol = col;
                            const jump = move.jump;
                            const special = move.special;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            // Trigger coin toss
                            performCoinToss(
                                'Capture Spectre',
                                'Attempting to capture the Spectre...',
                                (success) => {
                                    if (success) {
                                        // Successfully captured Spectre
                                        movePiece(fromRow, fromCol, toRow, toCol, jump);
                                        if (special === 'charge') {
                                            cavalryChargeUsed[currentPlayer] = true;
                                        }
                                        if (special === 'ballistaDoubleTime') {
                                            ballistaDoubleTimeUsed[currentPlayer]++;
                                        }
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} successfully captured the Spectre!`);
                                    } else {
                                        // Failed to capture Spectre - move not executed
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} failed to capture the Spectre.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                }
                            );
                            return;
                        } else {
                            // Normal move/capture
                            movePiece(selectedPiece.row, selectedPiece.col, row, col, move.jump);
                            if (move.special === 'charge') {
                                cavalryChargeUsed[currentPlayer] = true;
                            }
                            if (move.special === 'ballistaDoubleTime') {
                                if (board[row][col]?.type === 'Ballista') {
                                    // after moving, board[row][col] is the piece moved
                                }
                                ballistaDoubleTimeUsed[currentPlayer]++;
                            }
                        }
                    } else if (move.type === 'shoot') {
                        // Check if shooting a Spectre - requires coin toss (except for Wizards/Spectres)
                        const targetPiece = board[row][col];
                        const attackingPiece = board[selectedPiece.row][selectedPiece.col];
                        const isShootingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                        const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';
                        const autoCrackShot = move.special === 'fusilierCrackShotAuto';
                        const usingCrackShot = attackingPiece && attackingPiece.type === 'Fusilier' && fusilierCrackShotActive === attackingPiece;
                        const isNecromancerShot = attackingPiece && attackingPiece.type === 'Necromancer' && move.special === 'necromancerShoot';

                        if (isShootingSpectre && !captureExempt) {
                            // Store move info for callback
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const toRow = row;
                            const toCol = col;
                            const special = move.special;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            // Trigger coin toss
                            performCoinToss(
                                'Shoot Spectre',
                                'Attempting to shoot the Spectre...',
                                (success) => {
                                    if (success) {
                                        // Successfully shot Spectre
                                        shootPiece(fromRow, fromCol, toRow, toCol);
                                        if (special === 'archerDiag2') {
                                            archerDiag2ShootUsed[currentPlayer]++;
                                        }
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} successfully shot the Spectre!`);
                                    } else {
                                        // Failed to shoot Spectre
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} failed to shoot the Spectre.`);
                                    }
                                    if (isNecromancerShot) {
                                        setNecromancerShotCooldown(attackingPiece, 2);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                }
                            );
                            return;
                        } else if (autoCrackShot) {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const pieceKey = `${fromRow},${fromCol},${currentPlayer}`;

                            movesLeft -= move.cost;

                            if (!(pieceKey in fusilierCrackShotCount)) {
                                fusilierCrackShotCount[pieceKey] = 3;
                            }
                            if (fusilierCrackShotCount[pieceKey] > 0) {
                                fusilierCrackShotCount[pieceKey]--;
                            }

                            performCoinToss(
                                'Crack Shot',
                                'Attempting Crack Shot...',
                                (success) => {
                                    fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                    fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);

                                    if (success) {
                                        shootPiece(fromRow, fromCol, row, col);
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot hit!`);
                                    } else {
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot missed.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                }
                            );
                            return;
                        } else if (usingCrackShot) {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            performCoinToss(
                                'Crack Shot',
                                'Attempting Crack Shot...',
                                (success) => {
                                    // Mark the shot attempt for cooldown regardless of outcome
                                    fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                    fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);

                                    fusilierCrackShotActive = null;

                                    if (success) {
                                        shootPiece(fromRow, fromCol, row, col);
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot hit!`);
                                    } else {
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot missed.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                }
                            );
                            return;
                        } else {
                            // Normal shoot
                            shootPiece(selectedPiece.row, selectedPiece.col, row, col);
                            if (move.special === 'archerDiag2') {
                                archerDiag2ShootUsed[currentPlayer]++;
                            }
                            if (isNecromancerShot) {
                                setNecromancerShotCooldown(attackingPiece, 2);
                            }
                        }
                    } else if (move.type === 'swap') {
                        const guardRow = move.pos[0];
                        const guardCol = move.pos[1];
                        const guard = board[guardRow][guardCol];
                        board[guardRow][guardCol] = board[selectedPiece.row][selectedPiece.col];
                        board[selectedPiece.row][selectedPiece.col] = guard;
                        kingSpecialUsed[currentPlayer] = true;
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Guard of Honour to swap King and Guard at (${selectedPiece.row},${selectedPiece.col}) and (${guardRow},${guardCol})`);
                        checkSupremacy(currentPlayer);
                        movedPieces.add(`${guardRow},${guardCol}`);
                        movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    } else if (move.type === 'teleport') {
                        const teleportPiece = board[selectedPiece.row][selectedPiece.col];
                        board[move.pos[0]][move.pos[1]] = teleportPiece;
                        board[selectedPiece.row][selectedPiece.col] = null;
                        if (teleportPiece.type === 'Wizard') {
                            wizardTeleportUsed[currentPlayer]++;
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Wizard from (${selectedPiece.row},${selectedPiece.col}) to (${move.pos[0]},${move.pos[1]})`);
                        } else if (teleportPiece.type === 'Necromancer') {
                            incrementNecromancerTeleportCount(teleportPiece);
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Necromancer from (${selectedPiece.row},${selectedPiece.col}) to (${move.pos[0]},${move.pos[1]})`);
                        } else {
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported ${teleportPiece.type} from (${selectedPiece.row},${selectedPiece.col}) to (${move.pos[0]},${move.pos[1]})`);
                        }
                        movedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                    } else if (move.type === 'teleportSwap') {
                        const opponentWizardRow = row;
                        const opponentWizardCol = col;
                        const playerWizard = board[selectedPiece.row][selectedPiece.col];
                        const opponentWizard = board[opponentWizardRow][opponentWizardCol];
                        board[opponentWizardRow][opponentWizardCol] = playerWizard;
                        board[selectedPiece.row][selectedPiece.col] = opponentWizard;
                        wizardTeleportSwapUsed[currentPlayer] = true;
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Teleport Swap to swap Wizard at (${selectedPiece.row},${selectedPiece.col}) with opponent's Wizard at (${opponentWizardRow},${opponentWizardCol})`);
                        movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                        movedPieces.add(`${opponentWizardRow},${opponentWizardCol}`);
                    }
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    if (move.type === 'move' || move.type === 'teleport') {
                        movedPieces.add(`${row},${col}`);
                    }
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes();
                }
            }
        }

        function openTurnModal() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (turnablePieces.includes(piece.type) && movesLeft >= turnCosts[piece.type]) {
                const validDirections = getValidTurnDirections(piece.facing);
                const select = document.getElementById('turn-select');
                select.innerHTML = validDirections.map(dir => `<option value="${dir}">${dir} (${facingIcons[dir]})</option>`).join('');
                document.getElementById('turn-modal').style.display = 'block';
            }
        }

        function activateBallistaRange() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || ballistaRangeBoostUsedThisTurn[currentPlayer]) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Ballista') {
                ballistaRangeBoostActive[currentPlayer] = true;
                ballistaRangeBoostUsedThisTurn[currentPlayer] = true;
                movesLeft -= 2;
                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} activated Ballista Extend Range (+1 range this turn)`);
                // Keep the piece selected and recalculate valid moves with extended range
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                checkGameOver();
                if (movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                }
            }
        }

        function getBallistaDoubleTimeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            let moves = [];
            for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                const r1 = row + d[0], c1 = col + d[1];
                const r2 = row + d[0]*2, c2 = col + d[1]*2;
                if (!isValid(r1, c1) || board[r1][c1]) continue; // path blocked on first
                if (isValid(r2, c2) && !board[r2][c2]) {
                    // Ballista can only move to empty squares - cannot capture by landing
                    moves.push({ type: 'move', pos: [r2, c2], cost: 2, special: 'ballistaDoubleTime' });
                }
            }
            return moves;
        }

        function activateBallistaDoubleTime() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || ballistaDoubleTimeUsed[currentPlayer] >= 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Ballista') {
                const options = getBallistaDoubleTimeMoves(selectedPiece.row, selectedPiece.col);
                validMoves = options;
                renderBoard();
            }
        }
        function activateArcherMoveDiagShoot() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (archerMoveDiagMode || archerDiagShootSelectMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Archer' && archerMoveDiagShootUsed[currentPlayer] < 2) {
                archerMoveDiagMode = true;
                archerMoveDiagStart = { row: selectedPiece.row, col: selectedPiece.col };
                // Only allow the Archer's basic 1-square orthogonal moves for the first step
                const moves = pieceTypes['Archer'].move(selectedPiece.row, selectedPiece.col, board, currentPlayer, null, piece.facing) || [];
                validMoves = moves.filter(m => m.type === 'move' && m.cost === 1);
                renderBoard();
            }
        }

        function activateArcherDiag2Shoot() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (archerDiag2ShootMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Archer' && archerDiag2ShootUsed[currentPlayer] < 2) {
                archerDiag2ShootMode = true;
                // Compute diagonal 2-square shoot targets
                const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                const row = selectedPiece.row, col = selectedPiece.col;
                let options = [];
                for (let d of dirs) {
                    const nr = row + d[0]*2, nc = col + d[1]*2;
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== currentPlayer) {
                        options.push({ type: 'shoot', pos: [nr, nc], cost: 2, special: 'archerDiag2' });
                    }
                }
                validMoves = options;
                renderBoard();
            }
        }

        function activateStrafe() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (strafeMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            const usedCount = piece.type === 'Wizard' ? wizardStrafeUsed[currentPlayer] : dragonStrafeUsed[currentPlayer];

            if ((piece.type === 'Wizard' || piece.type === 'Dragon') && usedCount < 2) {
                strafeMode = true;
                // Compute orthogonal 1-square moves to empty squares only
                const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                const row = selectedPiece.row, col = selectedPiece.col;
                let options = [];
                for (let d of dirs) {
                    const nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        options.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'strafe' });
                    }
                }
                validMoves = options;
                renderBoard();
            }
        }

        function activateSummonSpectre() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (summonSpectreMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            const totalCaptured = capturedPieces['W'].length + capturedPieces['B'].length;

            if (piece.type === 'Wizard' && spectresSummoned[currentPlayer] < 2 && !wizardSummonedThisTurn[currentPlayer] && totalCaptured >= 5) {
                summonSpectreMode = true;
                // Compute adjacent squares (8 directions) for Spectre placement
                const dirs = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                const row = selectedPiece.row, col = selectedPiece.col;
                let options = [];
                for (let d of dirs) {
                    const nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        options.push({ type: 'summon', pos: [nr, nc], cost: 2, special: 'summonSpectre' });
                    }
                }
                validMoves = options;
                renderBoard();
            }
        }

        function confirmTurn() {
            if (!selectedPiece) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const newFacing = document.getElementById('turn-select').value;
            turnPiece(selectedPiece.row, selectedPiece.col, newFacing);
            document.getElementById('turn-modal').style.display = 'none';
            movesLeft -= turnCosts[piece.type];
            movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
            selectedPiece = null;
            validMoves = [];
            showPieceInfo(null);
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
            checkGameOver();
            if (movesLeft === 0 && !reinforcementPending) {
                triggerAiTurn();
            }
        }

        function openTurnAndMoveModal() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if ((piece.type === 'Infantry' || piece.type === 'Mercenary') && movesLeft >= 2) {
                const validDirections = getValidTurnDirections(piece.facing);
                const select = document.getElementById('turn-move-select');
                select.innerHTML = validDirections.map(dir => `<option value="${dir}">${dir} (${facingIcons[dir]})</option>`).join('');
                document.getElementById('turn-move-modal').style.display = 'block';
            }
        }

        function confirmTurnAndMove() {
            if (!selectedPiece) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const newFacing = document.getElementById('turn-move-select').value;
            turnPiece(selectedPiece.row, selectedPiece.col, newFacing);
            document.getElementById('turn-move-modal').style.display = 'none';
            movesLeft -= 1;
            lastAction = { turn: true };
            turnAndMoveMode = true;
            validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
        }

        function closeTurnModal() {
            const modal = document.getElementById('turn-modal');
            if (modal) modal.style.display = 'none';
        }

        function openKingSummonModal() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'King' && (gameVariant === '36s-expert' || gameVariant === '36s-elite')) {
                const select = document.getElementById('king-summon-select');
                select.innerHTML = '';

                // Add available summon options
                if (pistoliersSummoned[currentPlayer] < 2) {
                    const option = document.createElement('option');
                    option.value = 'Pistolier';
                    option.textContent = `Pistolier (${pistoliersSummoned[currentPlayer]}/2 summoned)`;
                    select.appendChild(option);
                }
                if (fusiliersSummoned[currentPlayer] < 2) {
                    const option = document.createElement('option');
                    option.value = 'Fusilier';
                    option.textContent = `Fusilier (${fusiliersSummoned[currentPlayer]}/2 summoned)`;
                    select.appendChild(option);
                }

                if (select.options.length > 0) {
                    document.getElementById('king-summon-modal').style.display = 'block';
                }
            }
        }

        function closeKingSummonModal() {
            const modal = document.getElementById('king-summon-modal');
            if (modal) modal.style.display = 'none';
        }

        function confirmKingSummon() {
            if (!selectedPiece || currentPlayer !== 'W') return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type !== 'King') return;

            const select = document.getElementById('king-summon-select');
            const unitType = select.value;

            if (!unitType) return;

            // Close modal
            closeKingSummonModal();

            // Deduct points immediately
            movesLeft -= 2;

            // Perform coin toss for summon
            performCoinToss(
                'Summon Unit',
                `Attempting to summon ${unitType}...`,
                (success) => {
                    if (success) {
                        // Find empty square in back row
                        const backRow = currentPlayer === 'W' ? ROWS - 1 : 0;
                        let emptySquares = [];
                        for (let c = 0; c < COLS; c++) {
                            if (!board[backRow][c]) {
                                emptySquares.push(c);
                            }
                        }

                        if (emptySquares.length > 0) {
                            // Place unit in first available empty square
                            const col = emptySquares[0];
                            const facing = currentPlayer === 'W' ? 'U' : 'D';
                            board[backRow][col] = { type: unitType, player: currentPlayer, facing: facing };

                            // Update summon counter
                            if (unitType === 'Pistolier') {
                                pistoliersSummoned[currentPlayer]++;
                            } else if (unitType === 'Fusilier') {
                                fusiliersSummoned[currentPlayer]++;
                            }

                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} successfully summoned ${unitType} at (${backRow},${col})!`);
                        } else {
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} succeeded summon but no empty squares in back row!`);
                        }
                    } else {
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} failed to summon ${unitType}.`);
                    }

                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
            );
        }

        function openChampionSummonModal() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || piece.type !== 'Champion' || gameVariant !== '36s-elite') return;
            if (necromancersSummoned[currentPlayer] >= 2) return;

            const backRow = currentPlayer === 'W' ? ROWS - 1 : 0;
            const select = document.getElementById('champion-summon-select');
            if (!select) return;
            const availableCols = [];
            for (let c = 0; c < COLS; c++) {
                if (!board[backRow][c]) {
                    availableCols.push(c);
                }
            }

            if (availableCols.length === 0) {
                gameLog.push('No open squares on the back row to summon a Necromancer.');
                updateGameLog();
                return;
            }

            select.innerHTML = availableCols.map(c => `<option value="${c}">Column ${c + 1}</option>`).join('');
            championSummonSource = { row: selectedPiece.row, col: selectedPiece.col, player: currentPlayer };
            const modal = document.getElementById('champion-summon-modal');
            if (modal) {
                modal.style.display = 'block';
            }
        }

        function closeChampionSummonModal() {
            const modal = document.getElementById('champion-summon-modal');
            if (modal) modal.style.display = 'none';
            championSummonSource = null;
        }

        function confirmChampionSummon() {
            if (!championSummonSource) return;
            const { row, col, player } = championSummonSource;
            const piece = board[row]?.[col];
            if (!piece || piece.type !== 'Champion' || player !== currentPlayer) {
                closeChampionSummonModal();
                return;
            }
            if (movesLeft < 2) {
                closeChampionSummonModal();
                return;
            }

            const select = document.getElementById('champion-summon-select');
            if (!select || select.value === '') {
                return;
            }
            const targetCol = parseInt(select.value, 10);
            if (Number.isNaN(targetCol)) return;

            closeChampionSummonModal();

            movesLeft = Math.max(0, movesLeft - 2);

            const backRow = player === 'W' ? ROWS - 1 : 0;
            const summonMessage = `Attempting to summon a Necromancer to column ${targetCol + 1}.`;
            performCoinToss(
                'Summon Necromancer',
                summonMessage,
                (success) => {
                    if (success) {
                        if (!board[backRow][targetCol]) {
                            const necromancerPiece = { type: 'Necromancer', player, facing: null };
                            board[backRow][targetCol] = necromancerPiece;
                            necromancersSummoned[player] = (necromancersSummoned[player] || 0) + 1;
                            necromancerTeleportCounts.set(necromancerPiece, 0);
                            setNecromancerShotCooldown(necromancerPiece, 0);
                            gameLog.push(`${player === 'W' ? 'Player' : 'AI'} summoned a Necromancer at (${backRow},${targetCol}).`);
                        } else {
                            gameLog.push('Necromancer summon succeeded but the chosen square was no longer available.');
                        }
                    } else {
                        gameLog.push(`${player === 'W' ? 'Player' : 'AI'} failed to summon a Necromancer.`);
                    }

                    lastAction = { move: true };
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
            );
        }

        function openNecromancerSummonModal(type) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || piece.type !== 'Necromancer' || gameVariant !== '36s-elite') return;

            if (type === 'zombie') {
                const maxZombies = getMaxZombies(currentPlayer);
                if (zombiesSummoned[currentPlayer] >= maxZombies) {
                    gameLog.push('Zombie limit reached. Cannot summon more.');
                    updateGameLog();
                    return;
                }
            } else if (type === 'spectre') {
                if (spectresSummoned[currentPlayer] >= 2) {
                    gameLog.push('Spectre limit reached. Cannot summon more.');
                    updateGameLog();
                    return;
                }
            }

            const backRow = currentPlayer === 'W' ? ROWS - 1 : 0;
            const select = document.getElementById('necromancer-summon-select');
            if (!select) return;
            const availableCols = [];
            for (let c = 0; c < COLS; c++) {
                if (!board[backRow][c]) availableCols.push(c);
            }
            if (!availableCols.length) {
                gameLog.push('No open squares on the back row to place a summon.');
                updateGameLog();
                return;
            }
            select.innerHTML = availableCols.map(c => `<option value="${c}">Column ${c + 1}</option>`).join('');
            necromancerSummonContext = { row: selectedPiece.row, col: selectedPiece.col, player: currentPlayer };
            necromancerSummonType = type;
            const modal = document.getElementById('necromancer-summon-modal');
            if (modal) modal.style.display = 'block';
        }

        function closeNecromancerSummonModal() {
            const modal = document.getElementById('necromancer-summon-modal');
            if (modal) modal.style.display = 'none';
            necromancerSummonContext = null;
            necromancerSummonType = null;
        }

        function confirmNecromancerSummon() {
            if (!necromancerSummonContext || !necromancerSummonType) return;
            const { row, col, player } = necromancerSummonContext;
            const piece = board[row]?.[col];
            if (!piece || piece.type !== 'Necromancer' || player !== currentPlayer) {
                closeNecromancerSummonModal();
                return;
            }
            if (movesLeft < 2) {
                closeNecromancerSummonModal();
                return;
            }

            const select = document.getElementById('necromancer-summon-select');
            if (!select || select.value === '') return;
            const targetCol = parseInt(select.value, 10);
            if (Number.isNaN(targetCol)) return;

            const summonKey = necromancerSummonType;

            if (summonKey === 'zombie') {
                const maxZombies = getMaxZombies(player);
                if (zombiesSummoned[player] >= maxZombies) {
                    gameLog.push('Zombie limit reached. Cannot summon more.');
                    updateGameLog();
                    closeNecromancerSummonModal();
                    return;
                }
            } else if (summonKey === 'spectre' && spectresSummoned[player] >= 2) {
                gameLog.push('Spectre limit reached. Cannot summon more.');
                updateGameLog();
                closeNecromancerSummonModal();
                return;
            }

            closeNecromancerSummonModal();

            movesLeft = Math.max(0, movesLeft - 2);
            const backRow = player === 'W' ? ROWS - 1 : 0;
            const isZombieSummon = summonKey === 'zombie';
            const summonType = isZombieSummon ? 'Zombie' : 'Spectre';
            const title = isZombieSummon ? 'Summon Zombie' : 'Summon Spectre';
            const message = isZombieSummon
                ? `Attempting to summon a Zombie to column ${targetCol + 1}...`
                : `Attempting to summon a Spectre to column ${targetCol + 1}...`;

            performCoinToss(
                title,
                message,
                (success) => {
                    if (success) {
                        if (!board[backRow][targetCol]) {
                            if (isZombieSummon) {
                                const zombiePiece = createZombiePiece(player);
                                board[backRow][targetCol] = zombiePiece;
                                zombiesSummoned[player] = (zombiesSummoned[player] || 0) + 1;
                                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} summoned a Zombie at (${backRow},${targetCol}).`);
                            } else {
                                const spectrePiece = createSpectrePiece(player);
                                board[backRow][targetCol] = spectrePiece;
                                spectresSummoned[player] = (spectresSummoned[player] || 0) + 1;
                                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} summoned a Spectre at (${backRow},${targetCol}).`);
                            }
                        } else {
                            gameLog.push('Summon succeeded but the chosen square was occupied.');
                        }
                    } else {
                        gameLog.push(`${player === 'W' ? 'Player' : 'AI'} failed to summon ${summonType}.`);
                    }

                    lastAction = { move: true };
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
            );
        }

        function closeTurnMoveModal() {
            const modal = document.getElementById('turn-move-modal');
            if (modal) modal.style.display = 'none';
            cancelSpecialModes({ resetSelection: false });
        }

        function closeTurnShootModal() {
            const modal = document.getElementById('turn-shoot-modal');
            if (modal) modal.style.display = 'none';
            cancelSpecialModes({ resetSelection: false });
        }

        function openTurnAndShootModal() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Archer' && movesLeft >= 2) {
                const validDirections = getValidTurnDirections(piece.facing);
                const select = document.getElementById('turn-shoot-select');
                select.innerHTML = validDirections.map(dir => `<option value="${dir}">${dir} (${facingIcons[dir]})</option>`).join('');
                document.getElementById('turn-shoot-modal').style.display = 'block';
            }
        }

        function confirmTurnAndShoot() {
            if (!selectedPiece) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const newFacing = document.getElementById('turn-shoot-select').value;
            turnPiece(selectedPiece.row, selectedPiece.col, newFacing);
            document.getElementById('turn-shoot-modal').style.display = 'none';
            // Spend 1 for the turn now; the shot will spend the 2nd point
            movesLeft -= 1;
            lastAction = { turn: true };
            turnAndShootMode = true;
            // Limit valid moves to only shooting options after the turn
            validMoves = getValidMoves(selectedPiece.row, selectedPiece.col).filter(m => m.type === 'shoot');
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
        }

        function getValidMoves(row, col) {
            const piece = board[row][col];
            if (!piece || movedPieces.has(`${row},${col}`)) return [];

            // Check if wizard is restricted from moving this turn
            if (piece.type === 'Wizard' && wizardCannotMoveNextTurn[piece.player].has(`${row},${col}`)) {
                return [];
            }

            const type = piece.type;
            const player = piece.player;
            let valid = [];
            
            // Handle Inferno Mode
            if (type === 'Dragon' && infernoMode && !dragonInfernoUsed[player] && movesLeft >= 2) {
                const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                for (let d of directions) {
                    let nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && (!board[nr][nc] || board[nr][nc].player !== player)) {
                        valid.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'inferno' });
                    }
                }
                return valid; // Return *only* inferno moves
            }

            // Standard Moves
            const isFirstMove = firstMoves.has(`${row},${col},${player}`);
            let moves = pieceTypes[type].move(row, col, board, player, isFirstMove, piece.facing, movesLeft);
            
            for (let move of moves) {
                if (move.type === 'move') {
                    const [r, c] = move.pos;
                    if (!board[r][c] || board[r][c].player !== player) {
                        if (type !== 'King' || !isCheckAfterMove(row, col, r, c, player)) {
                            if (movesLeft >= move.cost) {
                                valid.push(move);
                            }
                        }
                    }
                } else if (move.type === 'shoot') {
                    if (movesLeft >= move.cost) {
                        valid.push(move);
                    }
                }
            }

            // Special Moves
            if (type === 'King' && !kingSpecialUsed[player] && movesLeft >= 2) {
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].type === 'Guard' && board[nr][nc].player === player) {
                        valid.push({ type: 'swap', pos: [nr, nc], cost: 2 });
                    }
                }
            }
            if (type === 'Wizard' && wizardTeleportUsed[player] < 2 && movesLeft >= 2) {
                const currentColor = (row + col) % 2;
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if ((r + c) % 2 === currentColor && !board[r][c] && (r !== row || c !== col)) {
                            valid.push({ type: 'teleport', pos: [r, c], cost: 2 });
                        }
                    }
                }
            }
            if (type === 'Necromancer' && gameVariant === '36s-elite' && movesLeft >= 2) {
                const pieceObj = piece;
                if (getNecromancerTeleportCount(pieceObj) < 2) {
                    for (let r = 0; r < ROWS; r++) {
                        for (let c = 0; c < COLS; c++) {
                            if (!board[r][c] && (r !== row || c !== col)) {
                                valid.push({ type: 'teleport', pos: [r, c], cost: 2 });
                            }
                        }
                    }
                }
            }
            if (type === 'Wizard' && !wizardTeleportSwapUsed[player] && movesLeft >= 2 && opponentHasWizards(player)) {
                const color = (row + col) % 2;
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (board[r][c] && board[r][c].type === 'Wizard' && board[r][c].player !== player && (r + c) % 2 === color) {
                            valid.push({ type: 'teleportSwap', pos: [r, c], cost: 2 });
                        }
                    }
                }
            }
            if (type === 'Cavalry' && !cavalryChargeUsed[player] && movesLeft >= 2) {
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let r = row, c = col;
                    while (true) {
                        r += d[0];
                        c += d[1];
                        if (!isValid(r, c)) break;
                        if (board[r][c]) {
                            if (board[r][c].player !== player) {
                                valid.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                            }
                            break;
                        }
                        valid.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                    }
                }
            }
            if (type === 'Archer' && movesLeft >= 2 && archerDiag2ShootUsed[player] < 2) {
                // Add diagonal 2-square shot (no movement)
                const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                for (let d of dirs) {
                    const nr = row + d[0]*2, nc = col + d[1]*2;
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== player) {
                        valid.push({ type: 'shoot', pos: [nr, nc], cost: 2, special: 'archerDiag2' });
                    }
                }
            }
            if (type === 'Ballista') {
                if (!ballistaRangeBoostUsedThisTurn[player] && movesLeft >= 2) {
                    valid.push({ type: 'activate', pos: [row, col], cost: 2, special: 'ballistaRange' });
                }
                if (ballistaDoubleTimeUsed[player] < 2 && movesLeft >= 2) {
                    valid.push(...getBallistaDoubleTimeMoves(row, col));
                }
            }
            // Note: Dragon Inferno is *not* added here because it's activated by a button, not as a passive option.
            // The logic above handles showing Inferno moves *only when infernoMode is true*.
            
            return valid;
        }

        // New function to execute the Inferno AOE capture
        function performInfernoCapture(row, col, player) {
            const opponent = player === 'W' ? 'B' : 'W';
            const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
            let capturedSomething = false;

            for (let d of directions) {
                let nr = row + d[0], nc = col + d[1];
                if (isValid(nr, nc)) {
                    const targetPiece = board[nr][nc];
                    // Dragons cannot capture other Dragons with Inferno
                    if (targetPiece && targetPiece.player === opponent && targetPiece.type !== 'Dragon') {
                        capturedSomething = true;
                        capturedSquares.push([nr, nc]);
                        capturedPieces[player].push(targetPiece);
                        const captureValue = pieceValues[targetPiece.type];
                        scores[player] += captureValue;
                        registerScoreGain(player, captureValue);
                        registerPieceLoss(opponent, targetPiece.type);
                        gameLog.push(`${player === 'W' ? 'Player' : 'AI'} captured ${targetPiece.type} (+${captureValue} points) with Dragon's Inferno at (${nr},${nc})`);

                        if (targetPiece.type === 'Champion') {
                            championCaptured[targetPiece.player] = true;
                        }
                        if (targetPiece.type === 'King') {
                            endGame(player);
                        }
                        cleanupNecromancerTracking(targetPiece);
                        board[nr][nc] = null;
                    }
                }
            }

            if (capturedSomething) {
                checkSupremacy(player);
                updateGameLog();
                updateCapturedPiecesDisplay();
                updateScoreDisplay();
            }
        }


        function movePiece(fromRow, fromCol, toRow, toCol, jump) {
            const piece = board[fromRow][fromCol];
            const opponent = getOpponent(piece.player);
            let captured = false;
            const opponentBackRow = piece.player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);
            const ownBackRow = piece.player === 'W' ? (gameVariant === 'ccb' ? 7 : 9) : 0;

            if (piece.type === 'Champion' && fromRow === opponentBackRow) {
                championsOnBackRow[piece.player] = championsOnBackRow[piece.player].filter(pos => pos[0] !== fromRow || pos[1] !== fromCol);
            }

            if (jump && board[jump[0]][jump[1]] && board[jump[0]][jump[1]].player !== piece.player) {
                const capturedPiece = board[jump[0]][jump[1]];
                if (capturedPiece.type === 'Zombie') {
                    const result = handleZombieCaptureAttempt(piece, fromRow, fromCol, jump[0], jump[1], { jumpCapture: true });
                    if (!result.success) {
                        return;
                    }
                    captured = true;
                } else {
                    capturedSquares.push([jump[0], jump[1]]);
                    capturedPieces[piece.player].push(capturedPiece);
                    const captureValue = pieceValues[capturedPiece.type];
                    scores[piece.player] += captureValue;
                    registerScoreGain(piece.player, captureValue);
                    registerPieceLoss(opponent, capturedPiece.type);
                    gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} captured ${capturedPiece.type} (+${captureValue} points) with ${piece.type} at (${jump[0]},${jump[1]})`);
                    cleanupNecromancerTracking(capturedPiece);
                    board[jump[0]][jump[1]] = null;
                    captured = true;
                }
            }

            if (board[toRow][toCol]) {
                // Archers and Ballistas cannot capture by landing - they can only shoot
                if (piece.type === 'Archer' || piece.type === 'Ballista') {
                    gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} ${piece.type} cannot capture by landing - must shoot instead`);
                    // Don't allow the move - this shouldn't happen but just in case
                } else {
                    const capturedPiece = board[toRow][toCol];
                    if (capturedPiece.type === 'Zombie') {
                        const result = handleZombieCaptureAttempt(piece, fromRow, fromCol, toRow, toCol);
                        if (!result.success) {
                            return;
                        }
                        captured = true;
                    } else {
                        capturedSquares.push([toRow, toCol]);
                        capturedPieces[piece.player].push(capturedPiece);
                        const captureValue = pieceValues[capturedPiece.type];
                        scores[piece.player] += captureValue;
                        registerScoreGain(piece.player, captureValue);
                        registerPieceLoss(opponent, capturedPiece.type);
                        gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} captured ${capturedPiece.type} (+${captureValue} points) with ${piece.type} at (${toRow},${toCol})`);
                        if (capturedPiece.type === 'Champion') {
                            championCaptured[capturedPiece.player] = true;
                        }
                        cleanupNecromancerTracking(capturedPiece);
                        if (capturedPiece.type === 'King') {
                            endGame(piece.player);
                        }
                        captured = true;
                    }
                }
            } else {
                gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} moved ${piece.type} from (${fromRow},${fromCol}) to (${toRow},${toCol})`);
            }

            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            firstMoves.delete(`${fromRow},${fromCol},${piece.player}`);

            // If a Ballista moved and had an active range boost, it persists for the turn (no change needed)

            if (piece.type === 'Champion' && toRow === opponentBackRow) {
                championsOnBackRow[piece.player].push([toRow, toCol]);
            }

            if ((piece.type === 'Infantry' || piece.type === 'Champion' || piece.type === 'King') && toRow === opponentBackRow && !captured) {
                reinforce(piece.player, toRow, toCol);
            }

            checkSupremacy(piece.player);

            updateGameLog();
            updateCapturedPiecesDisplay();
        }

        function shootPiece(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            if (!piece) return;
            if (piece.type === 'Fusilier') {
                fusilierShotThisTurn[piece.player].add(piece);
                fusilierShotLastTurn[piece.player].delete(piece);
                if (fusilierCrackShotActive === piece) {
                    fusilierCrackShotActive = null;
                }
            }
            const targetPiece = board[toRow][toCol];
            if (targetPiece && targetPiece.type === 'Zombie') {
                const result = handleZombieCaptureAttempt(piece, fromRow, fromCol, toRow, toCol, { ranged: true });
                if (result.handled) {
                    if (result.success) {
                        renderBoard();
                        updateScoreDisplay();
                        updateCapturedPiecesDisplay();
                        updateGameLog();
                    }
                    return;
                }
            }
            if (targetPiece) {
                capturedSquares.push([toRow, toCol]);
                capturedPieces[piece.player].push(targetPiece);
                const captureValue = pieceValues[targetPiece.type];
                scores[piece.player] += captureValue;
                registerScoreGain(piece.player, captureValue);
                registerPieceLoss(getOpponent(piece.player), targetPiece.type);
                gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} shot ${targetPiece.type} (+${captureValue} points) with ${piece.type} at (${toRow},${toCol})`);
                if (targetPiece.type === 'Champion') {
                    championCaptured[targetPiece.player] = true;
                }
                cleanupNecromancerTracking(targetPiece);
                if (targetPiece.type === 'King') {
                    endGame(piece.player);
                }
                board[toRow][toCol] = null;
                checkSupremacy(piece.player);
            }
            updateGameLog();
            updateCapturedPiecesDisplay();
        }

        function turnPiece(row, col, newFacing) {
            const piece = board[row][col];
            if (piece && turnablePieces.includes(piece.type)) {
                piece.facing = newFacing;
                gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} turned ${piece.type} at (${row},${col}) to face ${newFacing} (${facingIcons[newFacing]})`);
            }
        }

        function reinforce(player, row, col) {
            reinforcementPending = { player, row, col };
            let availablePieces = capturedPieces[player].map(p => p.type);
            const piece = board[row][col];
            if (piece.type === 'Champion' || piece.type === 'King') {
                if (gameVariant === '36s-expert' || gameVariant === '36s-elite') {
                    availablePieces.push(...Array(2).fill('Ballista'), ...Array(2).fill('Elephantry'), ...Array(2).fill('Mercenary'));
                }
            }
            if (availablePieces.length === 0) {
                reinforcementPending = null;
                return;
            }
            if (player === 'W') {
                const modal = document.getElementById('reinforce-modal');
                const select = document.getElementById('reinforce-select');
                select.innerHTML = availablePieces.map(p => `<option value="${p}">${p}</option>`).join('');
                modal.style.display = 'block';
            } else {
                // AI prioritizes high-value pieces for reinforcement
                const sortedPieces = availablePieces.sort((a, b) => {
                    return (aiPieceValues[b] || basePieceValues[b] || 0) - (aiPieceValues[a] || basePieceValues[a] || 0);
                });
                // Take the highest value piece (or occasionally second-highest for variety)
                const pieceType = Math.random() < 0.8 ? sortedPieces[0] : (sortedPieces[1] || sortedPieces[0]);
                confirmReinforcement(pieceType);
            }
        }

        function confirmReinforcement(pieceType) {
            if (!reinforcementPending) return;
            const { player, row, col } = reinforcementPending;
            const backRow = player === 'W' ? (gameVariant === 'ccb' ? 7 : 9) : 0;
            let relentlessTriggered = false;
            for (let c = 0; c < COLS; c++) {
                if (!board[backRow][c]) {
                    const type = pieceType || document.getElementById('reinforce-select').value;
                    board[backRow][c] = {
                        type,
                        player,
                        facing: turnablePieces.includes(type) ? (player === 'W' ? 'U' : 'D') : null
                    };
                    gameLog.push(`${player === 'W' ? 'Player' : 'AI'} reinforced ${type} at (${backRow},${c})`);
                    relentlessTriggered = registerReinforcement(player, type);
                    break;
                }
            }
            document.getElementById('reinforce-modal').style.display = 'none';
            reinforcementPending = null;
            if (relentlessTriggered) {
                return;
            }
            renderBoard();
            updateStatus();
            updateGameLog();
            checkGameOver();
            // After reinforcement, explicitly check if turn should end
            if (currentPlayer === 'W') {
                if (movesLeft <= 0) {
                    triggerAiTurn();
                } else {
                    ensureAITurnIfNeeded();
                }
            }
        }

        function cloneBoard(board) {
            return board.map(row => row.map(cell => cell ? { ...cell } : null));
        }

        /**
         * New aggressive evaluation function.
         */
        function evaluateBoard(board, player) {
            let score = 0;
            const opponent = player === 'W' ? 'B' : 'W';
            const opponentBackRow = player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);
            const centerRow = (ROWS - 1) / 2;
            const centerCol = (COLS - 1) / 2;

            // Use AI profile weights (if AI is playing, adjust weights based on profile)
            const profile = (player === 'B' && currentAiProfile) ? currentAiProfile : null;
            const MOBILITY_WEIGHT = profile ? (0.45 * profile.mobilityWeight) : 0.45;
            const CENTER_WEIGHT = profile ? (0.25 * profile.centerWeight) : 0.25;
            const THREAT_MULTIPLIER = profile ? profile.threatWeight : 1.0;
            
            let playerPieceValue = 0;
            let opponentPieceValue = 0;
            let playerThreats = 0;
            let opponentThreats = 0;
            let playerMobility = 0;
            let opponentMobility = 0;
            let playerCenterControl = 0;
            let opponentCenterControl = 0;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece) continue;

                    const value = aiPieceValues[piece.type];
                    const distToCenter = Math.hypot(r - centerRow, c - centerCol);

                    if (piece.player === player) {
                        playerPieceValue += value;
                        playerCenterControl -= distToCenter;
                        if ((piece.type === 'Infantry' || piece.type === 'Champion') && r === opponentBackRow) {
                            playerPieceValue += 5; // Promotion/reinforcement bonus
                        }

                        // Add advancement bonus for pieces that can trigger reinforcements
                        if (piece.type === 'Infantry' || piece.type === 'Champion' || piece.type === 'King') {
                            const distanceToBackRow = Math.abs(r - opponentBackRow);
                            const maxDistance = player === 'W' ? ROWS - 1 : (gameVariant === 'ccb' ? 7 : 9);
                            const advancementBonus = (1 - distanceToBackRow / maxDistance) * 3; // Up to +3 bonus for being close to back row
                            playerPieceValue += advancementBonus;
                        }

                        const moves = pieceTypes[piece.type].move(r, c, board, player, false, piece.facing, 3) || [];
                        playerMobility += moves.length;
                        for (const move of moves) {
                            if (move.type === 'move' || move.type === 'shoot') {
                                const targetPiece = board[move.pos[0]]?.[move.pos[1]];
                                if (targetPiece && targetPiece.player === opponent) {
                                    playerThreats += aiPieceValues[targetPiece.type] * 0.85 * THREAT_MULTIPLIER;
                                }
                            }
                        }
                    } else {
                        opponentPieceValue += value;
                        opponentCenterControl -= distToCenter;

                        const moves = pieceTypes[piece.type].move(r, c, board, opponent, false, piece.facing, 3) || [];
                        opponentMobility += moves.length;
                        for (const move of moves) {
                            if (move.type === 'move' || move.type === 'shoot') {
                                const targetPiece = board[move.pos[0]]?.[move.pos[1]];
                                if (targetPiece && targetPiece.player === player) {
                                    opponentThreats += aiPieceValues[targetPiece.type] * 0.85 * THREAT_MULTIPLIER;
                                }
                            }
                        }
                    }
                }
            }
            
            score = (playerPieceValue - opponentPieceValue)
                  + (playerThreats - opponentThreats)
                  + MOBILITY_WEIGHT * (playerMobility - opponentMobility)
                  + CENTER_WEIGHT * (playerCenterControl - opponentCenterControl);
            
            return score;
        }

        function simulateMove(board, fromRow, fromCol, toRow, toCol, jump, player, capturedPieces, scores, championsOnBackRow) {
            const newBoard = cloneBoard(board);
            const piece = newBoard[fromRow][fromCol];
            let captured = false;
            const opponentBackRow = player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);

            if (piece.type === 'Champion' && fromRow === opponentBackRow) {
                championsOnBackRow[player] = championsOnBackRow[player].filter(pos => pos[0] !== fromRow || pos[1] !== fromCol);
            }

            if (jump && newBoard[jump[0]][jump[1]] && newBoard[jump[0]][jump[1]].player !== player) {
                capturedPieces[player].push(newBoard[jump[0]][jump[1]]);
                scores[player] += aiPieceValues[newBoard[jump[0]][jump[1]].type];
                newBoard[jump[0]][jump[1]] = null;
                captured = true;
            }
            if (newBoard[toRow][toCol]) {
                capturedPieces[player].push(newBoard[toRow][toCol]);
                scores[player] += aiPieceValues[newBoard[toRow][toCol].type];
                captured = true;
            }
            newBoard[toRow][toCol] = piece;
            newBoard[fromRow][fromCol] = null;

            if (piece.type === 'Champion' && toRow === opponentBackRow) {
                championsOnBackRow[player].push([toRow, toCol]);
            }

            return { board: newBoard, captured };
        }

        function simulateShoot(board, fromRow, fromCol, toRow, toCol, player, capturedPieces, scores) {
            const newBoard = cloneBoard(board);
            if (newBoard[toRow][toCol]) {
                capturedPieces[player].push(newBoard[toRow][toCol]);
                scores[player] += aiPieceValues[newBoard[toRow][toCol].type];
                newBoard[toRow][toCol] = null;
            }
            return newBoard;
        }

        function simulateTurn(board, row, col, newFacing) {
            const newBoard = cloneBoard(board);
            newBoard[row][col].facing = newFacing;
            return newBoard;
        }

        /**
         * Find moves for low-value pieces (Infantry, Archer, etc.) to use final move point
         */
        function findLowValuePieceMove(player, movedPieces) {
            const LOW_VALUE_PIECES = ['Infantry', 'Archer', 'Zombie', 'Pistolier', 'Cavalry'];
            const centerRow = (ROWS - 1) / 2;
            const centerCol = (COLS - 1) / 2;
            let best = null;
            let bestScore = -Infinity;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player || movedPieces.has(`${r},${c}`)) continue;

                    // Prioritize low-value pieces
                    if (!LOW_VALUE_PIECES.includes(piece.type)) continue;

                    const moves = pieceTypes[piece.type].move(r, c, board, player, false, piece.facing, 1);
                    if (!moves) continue;

                    for (const move of moves) {
                        if (move.cost > 1) continue; // Only 1-cost moves
                        const [mr, mc] = move.pos;
                        const targetPiece = board[mr]?.[mc];

                        let score = 0;

                        // Prioritize captures even for low-value pieces
                        if (targetPiece && targetPiece.player !== player) {
                            score += aiPieceValues[targetPiece.type] * 10;

                            // Extra bonus for adjacent captures
                            const distance = Math.abs(mr - r) + Math.abs(mc - c);
                            if (distance === 1) {
                                score += 50; // High priority for using last move on adjacent capture
                            }
                        } else {
                            // For non-captures, prefer moving towards center or forward
                            const distToCenter = Math.hypot(mr - centerRow, mc - centerCol);
                            score -= distToCenter * 0.1;

                            // Encourage forward movement (towards opponent's side)
                            if (player === 'B' && mr > r) score += 2; // AI moves down
                            if (player === 'W' && mr < r) score += 2; // Player moves up
                        }

                        // Slightly prefer Infantry to use last point
                        if (piece.type === 'Infantry') score += 1;

                        if (score > bestScore) {
                            bestScore = score;
                            best = { ...move, from: [r, c], pieceType: piece.type };
                        }
                    }
                }
            }
            return best;
        }

        function findSimpleAIAction(player, movesLeft, movedPieces) {
            let best = null;
            let bestScore = -Infinity;
            const centerRow = (ROWS - 1) / 2;
            const centerCol = (COLS - 1) / 2;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player || movedPieces.has(`${r},${c}`)) continue;
                    const moves = getValidMoves(r, c) || [];
                    for (let move of moves) {
                        if (move.cost > movesLeft) continue;
                        const [mr, mc] = move.pos;
                        const targetPiece = board[mr]?.[mc];
                        const moveCost = typeof move.cost === 'number' ? move.cost : 1;
                        let score = moveCost * 0.45; // encourage spending available points
                        if (targetPiece && targetPiece.player !== player) {
                            const captureBonus = currentAiProfile ? currentAiProfile.captureBonus : 1.0;
                            score += aiPieceValues[targetPiece.type] * 2.4 * captureBonus; // heavily favour captures (adjusted by AI profile)
                            // Add proximity bonus for close attacks
                            const distance = Math.abs(mr - r) + Math.abs(mc - c);
                            if (distance === 1) {
                                // CRITICAL PRIORITY: Adjacent pieces are immediate threats - heavily prioritize capturing them
                                const captureBonus = currentAiProfile ? currentAiProfile.captureBonus : 1.0;
                                score += aiPieceValues[targetPiece.type] * 7.56 * captureBonus; // 756% bonus for adjacent captures (increased by 80% from original 4.2, adjusted by AI profile)
                                // Extra flat bonus for ANY adjacent capture to encourage eliminating all immediate threats
                                score += 15; // Flat bonus to encourage capturing even low-value adjacent pieces
                            } else if (distance <= 2) {
                                score += aiPieceValues[targetPiece.type] * 0.5; // 50% bonus for close attacks in simple AI
                            }
                        } else if (move.special) {
                            let specialBonus = 2.0; // Base special move bonus
                            if (aiDifficulty === 'Hard') specialBonus = 5.85; // +30% difficulty (4.5 → 5.85)
                            else if (aiDifficulty === 'Medium') specialBonus = 4.2; // +20% difficulty (3.5 → 4.2)
                            else if (aiDifficulty === 'Easy') specialBonus = 2.2; // Slightly higher for Easy (+10%)

                            // Apply AI profile modifier to special ability usage
                            if (currentAiProfile) {
                                specialBonus *= currentAiProfile.specialAbilityBonus;
                            }
                            score += specialBonus;
                        } else {
                            score -= 0.5; // penalise idle repositioning
                        }
                        if (move.type === 'turn') score -= 0.6; // avoid standalone turns unless needed
                        if (move.type === 'move' && !targetPiece && !move.special) {
                            score -= 0.2 * Math.max(0, movesLeft - moveCost); // don't leave points unused
                        }
                        const distToCenter = Math.hypot(mr - centerRow, mc - centerCol);
                        score -= distToCenter * 0.05;
                        if (score > bestScore) {
                            bestScore = score;
                            best = { ...move, from: [r, c], pieceType: piece.type };
                        }
                    }
                }
            }
            return best;
        }

        // New AI simulation function for Inferno AOE
        function simulateInfernoCapture(board, row, col, player, capturedPieces, scores) {
            const newBoard = cloneBoard(board);
            const opponent = player === 'W' ? 'B' : 'W';
            const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];

            for (let d of directions) {
                let nr = row + d[0], nc = col + d[1];
                if (isValid(nr, nc)) {
                    const targetPiece = newBoard[nr][nc];
                    if (targetPiece && targetPiece.player === opponent) {
                        capturedPieces[player].push(targetPiece);
                        scores[player] += aiPieceValues[targetPiece.type];
                        newBoard[nr][nc] = null;
                    }
                }
            }
            return newBoard;
        }


        function simulateTurnAndMove(board, row, col, newFacing, toRow, toCol, jump, player, capturedPieces, scores, championsOnBackRow) {
            let newBoard = cloneBoard(board);
            newBoard[row][col].facing = newFacing;
            const piece = newBoard[row][col];
            let captured = false;
            const opponentBackRow = player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);

            if (piece.type === 'Champion' && row === opponentBackRow) {
                championsOnBackRow[player] = championsOnBackRow[player].filter(pos => pos[0] !== row || pos[1] !== col);
            }

            if (jump && newBoard[jump[0]][jump[1]] && newBoard[jump[0]][jump[1]].player !== player) {
                capturedPieces[player].push(newBoard[jump[0]][jump[1]]);
                scores[player] += aiPieceValues[newBoard[jump[0]][jump[1]].type];
                newBoard[jump[0]][jump[1]] = null;
                captured = true;
            }
            if (newBoard[toRow][toCol]) {
                capturedPieces[player].push(newBoard[toRow][toCol]);
                scores[player] += aiPieceValues[newBoard[toRow][toCol].type];
                captured = true;
            }
            newBoard[toRow][toCol] = piece;
            newBoard[row][col] = null;

            if (piece.type === 'Champion' && toRow === opponentBackRow) {
                championsOnBackRow[player].push([toRow, toCol]);
            }

            return { board: newBoard, captured };
        }

        function minimax(board, depth, isMaximizing, player, movesLeft, movedPieces, capturedPieces, scores, alpha, beta, championsOnBackRow) {
            const leafScore = () => {
                const leftover = Math.max(0, movesLeft);
                return evaluateBoard(board, player) - AI_LEFTOVER_PENALTY * leftover;
            };

            if (aiTimeExpired()) {
                return { score: leafScore(), sequence: [], sequenceCost: 0 };
            }

            if (depth === 0 || movesLeft <= 0) {
                return { score: leafScore(), sequence: [], sequenceCost: 0 };
            }
            const opponent = player === 'W' ? 'B' : 'W';
            let bestAction = null;
            if (isMaximizing) {
                let maxEval = -Infinity;
                let allPossibleActions = [];
                let bestSequence = [];
                let bestSequenceCost = 0;

                // 1. Find all possible moves
                outerBuild:
                for (let r = 0; r < ROWS; r++) {
                    if (aiTimeExpired()) break outerBuild;
                    for (let c = 0; c < COLS; c++) {
                        if (aiTimeExpired()) break outerBuild;
                        if (board[r][c] && board[r][c].player === player && !movedPieces.has(`${r},${c}`)) {
                            const piece = board[r][c];
                            const moves = getValidMoves(r, c); // This is already filtered by movesLeft
                            for (let move of moves) {
                                if (aiTimeExpired()) break outerBuild;
                                let targetValue = 0;
                                if ((move.type === 'move' || move.type === 'shoot') && board[move.pos[0]][move.pos[1]]) {
                                    const targetPiece = board[move.pos[0]][move.pos[1]];
                                    const captureBonus = currentAiProfile ? currentAiProfile.captureBonus : 1.0;
                                    targetValue = aiPieceValues[targetPiece.type] * captureBonus;
                                    // If capturing a Spectre, account for 50% success rate (unless exempt)
                                    if (targetPiece.type === 'Spectre' && piece.type !== 'Wizard' && piece.type !== 'Spectre') {
                                        targetValue *= 0.5; // 50% chance of success
                                    }
                                    // Add proximity bonus: prioritize attacking adjacent/in-range pieces
                                    const distance = Math.abs(move.pos[0] - r) + Math.abs(move.pos[1] - c);
                                    if (distance === 1) {
                                        // CRITICAL PRIORITY: Adjacent pieces are immediate threats - heavily prioritize capturing them
                                        targetValue += aiPieceValues[targetPiece.type] * 4.32 * captureBonus; // 432% bonus for adjacent captures in minimax (increased by 80% from original 2.4, adjusted by AI profile)
                                        // Extra flat bonus for ANY adjacent capture to encourage eliminating all immediate threats
                                        targetValue += 10; // Flat bonus to encourage capturing even low-value adjacent pieces
                                    } else if (distance <= 2) {
                                        targetValue += aiPieceValues[targetPiece.type] * 0.3 * captureBonus; // 30% bonus for close attacks (adjusted by AI profile)
                                    }
                                }
                                allPossibleActions.push({
                                    ...move,
                                    from: [r,c],
                                    pieceType: piece.type,
                                    targetValue: targetValue
                                });
                            }
                            
                            // Check for Dragon Inferno
                            if (piece.type === 'Dragon' && !dragonInfernoUsed[player] && movesLeft >= 2) {
                                const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                                for (let d of directions) {
                                    if (aiTimeExpired()) break outerBuild;
                                    let nr = r + d[0], nc = c + d[1];
                                    if (isValid(nr, nc) && (!board[nr][nc] || board[nr][nc].player !== player)) {
                                        // Calculate total value of this Inferno move
                                        let infernoValue = 0;
                                        if (board[nr][nc] && board[nr][nc].player === opponent) {
                                            infernoValue += aiPieceValues[board[nr][nc].type];
                                        }
                                        // Check adjacent squares to the *landing spot*
                                        // Dragons cannot capture other Dragons with Inferno
                                        for (let d2 of directions) {
                                            let nnr = nr + d2[0], nnc = nc + d2[1];
                                            if (isValid(nnr, nnc) && board[nnr][nnc] && board[nnr][nnc].player === opponent && board[nnr][nnc].type !== 'Dragon') {
                                                infernoValue += aiPieceValues[board[nnr][nnc].type];
                                            }
                                        }
                                        // Add 40% bonus to encourage using Inferno special ability
                                        infernoValue *= 1.4;
                                        // Apply difficulty multiplier for special moves: Medium 1.2x, Hard 1.4x
                                        if (aiDifficulty === 'Hard') infernoValue *= 1.82; // +30% difficulty (1.4 → 1.82)
                                        else if (aiDifficulty === 'Medium') infernoValue *= 1.44; // +20% difficulty (1.2 → 1.44)
                                        allPossibleActions.push({ type: 'move', pos: [nr, nc], from: [r,c], cost: 2, special: 'inferno', pieceType: 'Dragon', targetValue: infernoValue });
                                    }
                                }
                            }

                            // Check for Wizard Strafe
                            if (piece.type === 'Wizard' && wizardStrafeUsed[player] < 2 && movesLeft >= 2) {
                                const strafeDirs = [[0,1], [0,-1], [1,0], [-1,0]];
                                for (let d of strafeDirs) {
                                    if (aiTimeExpired()) break outerBuild;
                                    let nr = r + d[0], nc = c + d[1];
                                    if (isValid(nr, nc) && !board[nr][nc]) {
                                        // Strafe is a positional move, increased value for tactical positioning
                                        let strafeValue = 2.5;
                                        if (aiDifficulty === 'Hard') strafeValue *= 1.69; // +30% difficulty (1.3 → 1.69)
                                        else if (aiDifficulty === 'Medium') strafeValue *= 1.38; // +20% difficulty (1.15 → 1.38)
                                        allPossibleActions.push({ type: 'move', pos: [nr, nc], from: [r,c], cost: 2, special: 'strafe', pieceType: 'Wizard', targetValue: strafeValue });
                                    }
                                }
                            }

                            // Check for Dragon Strafe
                            if (piece.type === 'Dragon' && dragonStrafeUsed[player] < 2 && movesLeft >= 2) {
                                const strafeDirs = [[0,1], [0,-1], [1,0], [-1,0]];
                                for (let d of strafeDirs) {
                                    if (aiTimeExpired()) break outerBuild;
                                    let nr = r + d[0], nc = c + d[1];
                                    if (isValid(nr, nc) && !board[nr][nc]) {
                                        // Strafe is a positional move, increased value for tactical positioning
                                        let strafeValue = 2.5;
                                        if (aiDifficulty === 'Hard') strafeValue *= 1.69; // +30% difficulty (1.3 → 1.69)
                                        else if (aiDifficulty === 'Medium') strafeValue *= 1.38; // +20% difficulty (1.15 → 1.38)
                                        allPossibleActions.push({ type: 'move', pos: [nr, nc], from: [r,c], cost: 2, special: 'strafe', pieceType: 'Dragon', targetValue: strafeValue });
                                    }
                                }
                            }

                            // Check for Wizard Spectre Summoning
                            if (piece.type === 'Wizard' && spectresSummoned[player] < 2 && !wizardSummonedThisTurn[player] && movesLeft >= 2) {
                                const totalCaptured = capturedPieces['W'].length + capturedPieces['B'].length;
                                if (totalCaptured >= 5) {
                                    const summonDirs = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                                    for (let d of summonDirs) {
                                        if (aiTimeExpired()) break outerBuild;
                                        let nr = r + d[0], nc = c + d[1];
                                        if (isValid(nr, nc) && !board[nr][nc]) {
                                            // Summoning has 50% success rate, but Spectre is valuable (value 9)
                                            // Base value = 0.5 * 9 = 4.5, increased to 9.0 to heavily encourage summoning
                                            // Apply difficulty multiplier: Easy 1.0x, Medium 1.3x, Hard 1.5x
                                            let summonValue = 9.0;
                                            if (aiDifficulty === 'Hard') summonValue *= 1.95; // +30% difficulty (1.5 → 1.95)
                                            else if (aiDifficulty === 'Medium') summonValue *= 1.56; // +20% difficulty (1.3 → 1.56)
                                            allPossibleActions.push({ type: 'summon', pos: [nr, nc], from: [r,c], cost: 2, special: 'summonSpectre', pieceType: 'Wizard', targetValue: summonValue });
                                        }
                                    }
                                }
                            }

                            // Check for Necromancer Zombie Summoning (36s-elite only)
                            if (piece.type === 'Necromancer' && gameVariant === '36s-elite' && movesLeft >= 2) {
                                const maxZombies = getMaxZombies(player);
                                if (zombiesSummoned[player] < maxZombies) {
                                    const backRow = player === 'W' ? ROWS - 1 : 0;
                                    for (let col = 0; col < COLS; col++) {
                                        if (aiTimeExpired()) break outerBuild;
                                        if (!board[backRow][col]) {
                                            // Zombie summoning has 50% success rate, Zombie value is 3
                                            // Expected value = 0.5 * 3 = 1.5, increased to 6.0 to encourage summoning
                                            // Apply difficulty multiplier: Easy 1.0x, Medium 1.3x, Hard 1.5x
                                            let summonValue = 6.0;
                                            if (aiDifficulty === 'Hard') summonValue *= 1.95; // +30% difficulty (1.5 → 1.95)
                                            else if (aiDifficulty === 'Medium') summonValue *= 1.56; // +20% difficulty (1.3 → 1.56)
                                            allPossibleActions.push({ type: 'summon', pos: [backRow, col], from: [r,c], cost: 2, special: 'summonZombie', pieceType: 'Necromancer', targetValue: summonValue });
                                        }
                                    }
                                }
                            }

                            // Check for Necromancer Spectre Summoning (36s-elite only)
                            if (piece.type === 'Necromancer' && gameVariant === '36s-elite' && spectresSummoned[player] < 2 && movesLeft >= 2) {
                                const backRow = player === 'W' ? ROWS - 1 : 0;
                                for (let col = 0; col < COLS; col++) {
                                    if (aiTimeExpired()) break outerBuild;
                                    if (!board[backRow][col]) {
                                        // Spectre summoning has 50% success rate, Spectre value is 9
                                        // Expected value = 0.5 * 9 = 4.5, increased to 10.0 to heavily encourage summoning
                                        // Apply difficulty multiplier: Easy 1.0x, Medium 1.3x, Hard 1.5x
                                        let summonValue = 10.0;
                                        if (aiDifficulty === 'Hard') summonValue *= 1.5;
                                        else if (aiDifficulty === 'Medium') summonValue *= 1.3;
                                        allPossibleActions.push({ type: 'summon', pos: [backRow, col], from: [r,c], cost: 2, special: 'summonNecromancerSpectre', pieceType: 'Necromancer', targetValue: summonValue });
                                    }
                                }
                            }

                            // Check for Elephantry Charge
                            if (piece.type === 'Elephantry' && movesLeft >= 2) {
                                const pieceKey = `${r},${c},${player}`;
                                if (!elephantryChargeUsed.has(pieceKey)) {
                                    const facing = piece.facing;
                                    let directions = [];
                                    if (facing === 'U') directions = [[-1,0], [-1,-1], [-1,1]];
                                    else if (facing === 'D') directions = [[1,0], [1,-1], [1,1]];
                                    else if (facing === 'L') directions = [[0,-1], [-1,-1], [1,-1]];
                                    else if (facing === 'R') directions = [[0,1], [-1,1], [1,1]];

                                    for (let d of directions) {
                                        if (aiTimeExpired()) break outerBuild;
                                        let capturesInPath = [];
                                        let canCharge = true;
                                        let finalPos = null;

                                        for (let dist = 1; dist <= 3; dist++) {
                                            let nr = r + d[0] * dist;
                                            let nc = c + d[1] * dist;
                                            if (!isValid(nr, nc)) {
                                                canCharge = false;
                                                break;
                                            }

                                            const target = board[nr][nc];
                                            if (target) {
                                                if (target.type === 'Spectre' || target.type === 'Zombie') {
                                                    canCharge = false;
                                                    break;
                                                }
                                                if (target.player !== player) {
                                                    capturesInPath.push(aiPieceValues[target.type]);
                                                    if (target.type === 'Elephantry' || target.type === 'Ogre' || target.type === 'Troll' || target.type === 'Dragon') {
                                                        finalPos = [nr, nc];
                                                        break;
                                                    }
                                                } else {
                                                    canCharge = false;
                                                    break;
                                                }
                                            }
                                            if (dist === 3) finalPos = [nr, nc];
                                        }

                                        if (canCharge && finalPos) {
                                            let chargeValue = capturesInPath.reduce((sum, val) => sum + val, 0);
                                            // Encourage charge if it captures multiple pieces
                                            if (capturesInPath.length > 1) chargeValue *= 1.3;
                                            allPossibleActions.push({ type: 'move', pos: finalPos, from: [r,c], cost: 2, special: 'elephantryCharge', pieceType: 'Elephantry', targetValue: chargeValue });
                                        }
                                    }
                                }
                            }

                            // Check for turn actions
                            if (turnablePieces.includes(piece.type) && movesLeft >= turnCosts[piece.type]) {
                                const validDirections = getValidTurnDirections(piece.facing);
                                for (let facing of validDirections) {
                                    if (aiTimeExpired()) break outerBuild;
                                    allPossibleActions.push({ type: 'turn', pos: [r,c], from: [r,c], facing, cost: turnCosts[piece.type], pieceType: piece.type, targetValue: 0 });
                                    
                                    // Check for turn and move
                                    if ((piece.type === 'Infantry' || piece.type === 'Mercenary') && movesLeft >= turnCosts[piece.type] + 1) {
                                        // Simulate the turn to get new moves
                                        const tempBoard = cloneBoard(board);
                                        tempBoard[r][c].facing = facing;
                                        const turnMoves = pieceTypes[piece.type].move(r, c, tempBoard, player, false, facing, movesLeft - turnCosts[piece.type]);
                                        for (let tm of turnMoves.filter(m => m.type === 'move' && m.cost <= (movesLeft - turnCosts[piece.type]))) {
                                            if (aiTimeExpired()) break outerBuild;
                                             allPossibleActions.push({ 
                                                type: 'turnAndMove', 
                                                pos: [r,c], 
                                                from: [r,c], 
                                                facing, 
                                                move: tm.pos, 
                                                cost: turnCosts[piece.type] + tm.cost, 
                                                jump: tm.jump,
                                                pieceType: piece.type,
                                                targetValue: board[tm.pos[0]][tm.pos[1]] ? aiPieceValues[board[tm.pos[0]][tm.pos[1]].type] : 0
                                            });
                                        }
                                    }

                                    // Archer Turn + Shoot (player-only)
                                    if (piece.type === 'Archer' && movesLeft >= turnCosts[piece.type] + 1) {
                                        const tempBoard2 = cloneBoard(board);
                                        tempBoard2[r][c].facing = facing;
                                        const turnMoves2 = pieceTypes['Archer'].move(r, c, tempBoard2, player, false, facing, movesLeft - turnCosts[piece.type]);
                                        for (let tm of turnMoves2.filter(m => m.type === 'shoot' && m.cost === 1)) {
                                            if (aiTimeExpired()) break outerBuild;
                                            allPossibleActions.push({
                                                type: 'turnAndShoot',
                                                pos: [r,c],
                                                from: [r,c],
                                                facing,
                                                shoot: tm.pos,
                                                cost: turnCosts[piece.type] + 1,
                                                pieceType: piece.type,
                                                targetValue: aiPieceValues[board[tm.pos[0]][tm.pos[1]]?.type] || 0
                                            });
                                        }
                                    }
                                }
                            }

                            // Archer Move + Diagonal Shoot (player-only)
                            if (piece.type === 'Archer' && movesLeft >= 2 && archerMoveDiagShootUsed[player] < 2) {
                                const basicMoves = pieceTypes['Archer'].move(r, c, board, player, null, piece.facing) || [];
                                for (let mv of basicMoves.filter(m => m.type === 'move' && m.cost === 1 && (!board[m.pos[0]][m.pos[1]] || board[m.pos[0]][m.pos[1]].player !== player))) {
                                    if (aiTimeExpired()) break outerBuild;
                                    const nr = mv.pos[0], nc = mv.pos[1];
                                    // Only consider if square is empty or capture allowed; allow both
                                    const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                                    for (let d of dirs) {
                                        if (aiTimeExpired()) break outerBuild;
                                        const sr = nr + d[0], sc = nc + d[1];
                                        if (isValid(sr, sc) && board[sr][sc] && board[sr][sc].player !== player) {
                                            allPossibleActions.push({
                                                type: 'archerMoveDiagShoot',
                                                from: [r,c],
                                                move: [nr, nc],
                                                shoot: [sr, sc],
                                                cost: 2,
                                                pieceType: 'Archer',
                                                targetValue: aiPieceValues[board[sr][sc].type]
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // 2. Sort actions: prioritize captures, then cost (prefer using more move points), then special abilities, then avoid unnecessary turns
                allPossibleActions.sort((a, b) => {
                    // Prioritize captures by target value
                    if (a.targetValue > b.targetValue) return -1;
                    if (a.targetValue < b.targetValue) return 1;

                    // Strongly prefer actions that use more move points (encourage AI to spend all points)
                    const aCost = typeof a.cost === 'number' ? a.cost : 1;
                    const bCost = typeof b.cost === 'number' ? b.cost : 1;
                    if (aCost !== bCost) return bCost - aCost; // Higher cost = better (spend more points)

                    // Prioritize special abilities
                    if (a.special && !b.special) return -1;
                    if (b.special && !a.special) return 1;

                    // Avoid unnecessary turns (don't penalize shooting pieces for turning)
                    if (a.type === 'turn' && !['Archer', 'Ballista'].includes(a.pieceType) && b.type !== 'turn') return 1;
                    if (b.type === 'turn' && !['Archer', 'Ballista'].includes(b.pieceType) && a.type !== 'turn') return -1;

                    return 0; // Keep stable order otherwise
                });

                const actionCap = isLargeBoardVariant() ? 80 : 220;
                if (allPossibleActions.length > actionCap) {
                    allPossibleActions = allPossibleActions.slice(0, actionCap);
                }
                
                // 3. Evaluate sorted actions
                for (let action of allPossibleActions) {
                    if (aiTimeExpired()) break;
                    const { from, pos, cost, jump, special, type, facing, move } = action;
                    const actionCost = typeof cost === 'number' ? cost : 0;
                    const r = from[0];
                    const c = from[1];

                    if (movesLeft < actionCost) continue; 

                    const newCapturedPieces = { W: [...capturedPieces.W], B: [...capturedPieces.B] };
                    const newScores = { ...scores };
                    const newChampionsOnBackRow = { W: [...championsOnBackRow.W], B: [...championsOnBackRow.B] };
                    let newBoard;
                    let newMovedPieces = new Set(movedPieces);
                    newMovedPieces.add(`${r},${c}`);
                    
                    if (type === 'move') {
                        const result = simulateMove(board, r, c, pos[0], pos[1], jump, player, newCapturedPieces, newScores, newChampionsOnBackRow);
                        newBoard = result.board;
                        if (special === 'inferno') {
                            newBoard = simulateInfernoCapture(newBoard, pos[0], pos[1], player, newCapturedPieces, newScores);
                        }
                        newMovedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (type === 'shoot') {
                        newBoard = simulateShoot(board, r, c, pos[0], pos[1], player, newCapturedPieces, newScores);
                    } else if (type === 'activate' && special === 'ballistaRange') {
                        // No board change; treat as state-only in real play. Here, approximate as no-op.
                        newBoard = cloneBoard(board);
                    } else if (type === 'swap') {
                        newBoard = cloneBoard(board);
                        const guardPiece = newBoard[pos[0]][pos[1]];
                        newBoard[pos[0]][pos[1]] = newBoard[r][c];
                        newBoard[r][c] = guardPiece;
                        newMovedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (type === 'teleport') {
                        newBoard = cloneBoard(board);
                        newBoard[pos[0]][pos[1]] = newBoard[r][c];
                        newBoard[r][c] = null;
                        newMovedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (type === 'teleportSwap') {
                        newBoard = cloneBoard(board);
                        const playerWizard = newBoard[r][c];
                        const opponentWizard = newBoard[pos[0]][pos[1]];
                        newBoard[pos[0]][pos[1]] = playerWizard;
                        newBoard[r][c] = opponentWizard;
                        newMovedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (type === 'turn') {
                        newBoard = simulateTurn(board, r, c, facing);
                    } else if (type === 'turnAndMove') {
                         const result = simulateTurnAndMove(board, r, c, facing, move[0], move[1], jump, player, newCapturedPieces, newScores, newChampionsOnBackRow);
                         newBoard = result.board;
                         newMovedPieces.add(`${move[0]},${move[1]}`);
                    } else if (type === 'turnAndShoot') {
                        // Approximate: turn then apply shoot
                        const turned = simulateTurn(board, r, c, facing);
                        newBoard = simulateShoot(turned, r, c, action.shoot[0], action.shoot[1], player, newCapturedPieces, newScores);
                    } else if (type === 'archerMoveDiagShoot') {
                        const mv = simulateMove(board, r, c, action.move[0], action.move[1], null, player, newCapturedPieces, newScores, newChampionsOnBackRow);
                        newBoard = simulateShoot(mv.board, action.move[0], action.move[1], action.shoot[0], action.shoot[1], player, newCapturedPieces, newScores);
                        newMovedPieces.add(`${action.move[0]},${action.move[1]}`);
                    } else if (type === 'summon') {
                        // Simulate summoning (has 50% success rate, we evaluate expected value in targetValue)
                        newBoard = cloneBoard(board);
                        // Optimistically place the summoned piece for evaluation
                        if (special === 'summonSpectre') {
                            newBoard[pos[0]][pos[1]] = { type: 'Spectre', player };
                            // Note: In real execution, this has 50% success which is factored into targetValue
                        } else if (special === 'summonZombie') {
                            newBoard[pos[0]][pos[1]] = { type: 'Zombie', player, facing: player === 'W' ? 'U' : 'D' };
                        } else if (special === 'summonNecromancerSpectre') {
                            newBoard[pos[0]][pos[1]] = { type: 'Spectre', player };
                        }
                    } else {
                        continue; // Should not happen
                    }
                    
                    const childResult = minimax(newBoard, depth - 1, false, player, movesLeft - actionCost, newMovedPieces, newCapturedPieces, newScores, alpha, beta, newChampionsOnBackRow);
                    const eval = childResult.score;
                    const totalCost = actionCost + (childResult.sequenceCost || 0);
                    if (eval > maxEval + AI_TIE_EPSILON || (Math.abs(eval - maxEval) <= AI_TIE_EPSILON && totalCost > bestSequenceCost)) {
                        maxEval = eval;
                        bestAction = action;
                        bestSequence = [action, ...(childResult.sequence || [])];
                        bestSequenceCost = totalCost;
                    }
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                if (maxEval === -Infinity) {
                    maxEval = leafScore();
                }
                return { score: maxEval, action: bestAction, sequence: bestSequence, sequenceCost: bestSequenceCost };
            } else { // Minimizing player (opponent simulation)
                let minEval = Infinity;
                // Note: We don't need to sort for the minimizing player, just find their best (worst for us) response.
                for (let r = 0; r < ROWS; r++) {
                    if (aiTimeExpired()) break;
                    for (let c = 0; c < COLS; c++) {
                        if (aiTimeExpired()) break;
                        if (board[r][c] && board[r][c].player === opponent && !movedPieces.has(`${r},${c}`)) {
                            const piece = board[r][c];
                            const moves = getValidMoves(r, c); // Already filtered by movesLeft
                            for (let move of moves) {
                                if (aiTimeExpired()) break;
                                // ... (Simulation logic as above) ...
                                const newCapturedPieces = { W: [...capturedPieces.W], B: [...capturedPieces.B] };
                                const newScores = { ...scores };
                                const newChampionsOnBackRow = { W: [...championsOnBackRow.W], B: [...championsOnBackRow.B] };
                                let newBoard;
                                let newMovedPieces = new Set(movedPieces);
                                newMovedPieces.add(`${r},${c}`);

                                if (move.type === 'move') {
                                    const result = simulateMove(board, r, c, move.pos[0], move.pos[1], move.jump, opponent, newCapturedPieces, newScores, newChampionsOnBackRow);
                                    newBoard = result.board;
                                    if (move.special === 'inferno') {
                                        newBoard = simulateInfernoCapture(newBoard, move.pos[0], move.pos[1], opponent, newCapturedPieces, newScores);
                                    }
                                    newMovedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                                } else if (move.type === 'shoot') {
                                    newBoard = simulateShoot(board, r, c, move.pos[0], move.pos[1], opponent, newCapturedPieces, newScores);
                                } else if (move.type === 'swap') {
                                    newBoard = cloneBoard(board);
                                    const guardPiece = newBoard[move.pos[0]][move.pos[1]];
                                    newBoard[move.pos[0]][move.pos[1]] = newBoard[r][c];
                                    newBoard[r][c] = guardPiece;
                                    newMovedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                                } else if (move.type === 'teleport') {
                                    newBoard = cloneBoard(board);
                                    newBoard[move.pos[0]][move.pos[1]] = newBoard[r][c];
                                    newBoard[r][c] = null;
                                    newMovedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                                } else if (move.type === 'teleportSwap') {
                                    newBoard = cloneBoard(board);
                                    const playerWizard = newBoard[r][c];
                                    const opponentWizard = newBoard[move.pos[0]][move.pos[1]];
                                    newBoard[move.pos[0]][move.pos[1]] = playerWizard;
                                    newBoard[r][c] = opponentWizard;
                                    newMovedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                                } else {
                                    continue;
                                }

                                const eval = minimax(newBoard, depth - 1, true, player, movesLeft - move.cost, newMovedPieces, newCapturedPieces, newScores, alpha, beta, newChampionsOnBackRow).score;
                                minEval = Math.min(minEval, eval);
                                beta = Math.min(beta, eval);
                                if (beta <= alpha) break;
                            }
                            if (beta <= alpha) break;
                            
                            // Check for Dragon Inferno for opponent
                            if (piece.type === 'Dragon' && !dragonInfernoUsed[opponent] && movesLeft >= 2) {
                                const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                                for (let d of directions) {
                                    if (aiTimeExpired()) break;
                                    let nr = r + d[0], nc = c + d[1];
                                    if (isValid(nr, nc) && (!board[nr][nc] || board[nr][nc].player !== opponent)) {
                                        const newCapturedPieces = { W: [...capturedPieces.W], B: [...capturedPieces.B] };
                                        const newScores = { ...scores };
                                        const newChampionsOnBackRow = { W: [...championsOnBackRow.W], B: [...championsOnBackRow.B] };
                                        let newMovedPieces = new Set(movedPieces);
                                        newMovedPieces.add(`${r},${c}`);
                                        
                                        const result = simulateMove(board, r, c, nr, nc, null, opponent, newCapturedPieces, newScores, newChampionsOnBackRow);
                                        let newBoard = result.board;
                                        newBoard = simulateInfernoCapture(newBoard, nr, nc, opponent, newCapturedPieces, newScores);
                                        newMovedPieces.add(`${nr},${nc}`);
                                        
                                        const eval = minimax(newBoard, depth - 1, true, player, movesLeft - 2, newMovedPieces, newCapturedPieces, newScores, alpha, beta, newChampionsOnBackRow).score;
                                        minEval = Math.min(minEval, eval);
                                        beta = Math.min(beta, eval);
                                        if (beta <= alpha) break;
                                    }
                                }
                            }
                            if (beta <= alpha) break;

                            // Check opponent's turn actions
                            if (turnablePieces.includes(piece.type) && movesLeft >= turnCosts[piece.type]) {
                                const validDirections = getValidTurnDirections(piece.facing);
                                for (let facing of validDirections) {
                                    if (aiTimeExpired()) break;
                                    const newBoard = simulateTurn(board, r, c, facing);
                                    const newMovedPieces = new Set(movedPieces);
                                    newMovedPieces.add(`${r},${c}`);
                                    let newMovesLeft = movesLeft - turnCosts[piece.type];
                                    
                                    let eval;
                                    if ((piece.type === 'Infantry' || piece.type === 'Mercenary') && newMovesLeft >= 1) {
                                        // Opponent turn-and-move
                                        const tempBoard = cloneBoard(newBoard);
                                        const turnMoves = pieceTypes[piece.type].move(r, c, tempBoard, opponent, false, facing, newMovesLeft);
                                        
                                        let bestTurnMoveEval = Infinity;
                                        for (let tm of turnMoves.filter(m => m.type === 'move' && m.cost <= newMovesLeft)) {
                                            if (aiTimeExpired()) break;
                                            const tmCapturedPieces = { W: [...capturedPieces.W], B: [...capturedPieces.B] };
                                            const tmScores = { ...scores };
                                            const tmChampions = { W: [...championsOnBackRow.W], B: [...championsOnBackRow.B] };
                                            const result = simulateTurnAndMove(board, r, c, facing, tm.pos[0], tm.pos[1], tm.jump, opponent, tmCapturedPieces, tmScores, tmChampions);
                                            const tmBoard = result.board;
                                            const tmMovedPieces = new Set(newMovedPieces);
                                            tmMovedPieces.add(`${tm.pos[0]},${tm.pos[1]}`);
                                            
                                            const tmEval = minimax(tmBoard, depth - 1, true, player, newMovesLeft - tm.cost, tmMovedPieces, tmCapturedPieces, tmScores, alpha, beta, tmChampions).score;
                                            bestTurnMoveEval = Math.min(bestTurnMoveEval, tmEval);
                                        }
                                        eval = bestTurnMoveEval;
                                        
                                    } else {
                                        // Simple turn
                                        eval = minimax(newBoard, depth - 1, true, player, newMovesLeft, newMovedPieces, capturedPieces, scores, alpha, beta, championsOnBackRow).score;
                                    }
                                    
                                    minEval = Math.min(minEval, eval);
                                    beta = Math.min(beta, eval);
                                    if (beta <= alpha) break;
                                }
                            }
                        }
                        if (beta <= alpha) break;
                    }
                }
                if (minEval === Infinity) {
                    minEval = leafScore();
                }
                return { score: minEval, sequence: [], sequenceCost: 0 };
            }
        }


        function evaluateTurn(row, col, newFacing, player) {
            const piece = board[row][col];
            const tempFacing = piece.facing;
            piece.facing = newFacing;
            const moves = getValidMoves(row, col);
            piece.facing = tempFacing;
            let score = (piece.type === 'Infantry' || piece.type === 'Mercenary') ? 1 : 0;
            const opponentBackRow = player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);
            for (let move of moves) {
                if (move.type === 'shoot') {
                    const [r, c] = move.pos;
                    score += aiPieceValues[board[r][c]?.type] || 0;
                } else if (move.type === 'move' && (piece.type === 'Infantry' || piece.type === 'Mercenary') && move.pos[0] === opponentBackRow) {
                    score += 5;
                }
            }
            return score + Math.random();
        }

        function isValid(row, col) {
            return row >= 0 && row < ROWS && col >= 0 && col < COLS;
        }

        function isCheckAfterMove(fromRow, fromCol, toRow, toCol, player) {
            return false;
        }

        function highlightValidMoves() {
            if (!selectedPiece) return;
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                const r = parseInt(square.dataset.row);
                const c = parseInt(square.dataset.col);
                const move = validMoves.find(m => m.pos[0] === r && m.pos[1] === c);
                if (r === selectedPiece.row && c === selectedPiece.col) {
                    square.classList.add('selected');
                } else if (move) {
                    if (move.type === 'move' && !board[r][c]) {
                        square.classList.add('valid-move');
                    } else if (move.type === 'move' && board[r][c] && board[r][c].player !== board[selectedPiece.row][selectedPiece.col].player) {
                        square.classList.add('valid-capture');
                    } else if (move.type === 'shoot') {
                        square.classList.add('valid-shoot');
                    } else if (move.type === 'swap' || move.type === 'teleportSwap') {
                        square.classList.add('valid-swap');
                    } else if (move.type === 'teleport') {
                        square.classList.add('valid-move');
                    } else if (move.type === 'summon') {
                        square.classList.add('valid-move');
                    }
                }
            });
        }

        function aiTurn() {
            currentPlayer = 'B';
            aiPending = false; // clear any scheduled AI flag
            const baseMoves = calculateBaseMoves('B');
            // Reset Ballista per-turn boost for AI
            ballistaRangeBoostActive['B'] = false;
            ballistaRangeBoostUsedThisTurn['B'] = false;
            // Reset wizard summoning flag for new turn
            wizardSummonedThisTurn['B'] = false;
            // Clear wizard movement restrictions from previous turn
            wizardCannotMoveNextTurn['B'].clear();
            isFirstPlayerTurn = false;
            aiSearchDeadline = 0;

            if (!applyStartTurnModifiers('B', baseMoves, { skipStopTimer: true })) {
                completeAiTurn();
                return;
            }

            movedPieces.clear();
            updateStatus();
            updateEndTurnButton();

            let plannedActions = [];

            function makeNextMove() {
                try {
                    if (currentPlayer !== 'B') {
                        return;
                    }
                    if (aiTurnTimeoutForced) {
                        aiTurnTimeoutForced = false;
                        movesLeft = 0;
                    }
                    // *** UPDATED: AI turn ends when out of moves or pending reinforcement
                    if (movesLeft <= 0 || reinforcementPending) {
                        highlightSquares = [];
                        plannedActions = [];
                        completeAiTurn();
                        return;
                    }
                    
                const canExecuteAction = (candidate) => {
                    if (!candidate) return false;
                    const cost = typeof candidate.cost === 'number' ? candidate.cost : 1;
                    if (cost > movesLeft) return false;
                    if (candidate.from) {
                        const [fr, fc] = candidate.from;
                        const piece = board[fr] && board[fr][fc];
                        if (!piece || piece.player !== 'B') return false;
                    }
                    if (candidate.type === 'move' && candidate.pos) {
                        const targetRow = candidate.pos[0];
                        const targetCol = candidate.pos[1];
                        const targetPiece = board[targetRow] && board[targetRow][targetCol];
                        if (targetPiece && targetPiece.player === 'B') return false;
                    }
                    if ((candidate.type === 'turn' || candidate.type === 'turnAndMove' || candidate.type === 'turnAndShoot') && candidate.pos) {
                        const turnRow = candidate.pos[0];
                        const turnCol = candidate.pos[1];
                        const turnPiece = board[turnRow] && board[turnRow][turnCol];
                        if (!turnPiece || turnPiece.player !== 'B') return false;
                    }
                    return true;
                };

                let action = null;

                if (plannedActions.length > 0) {
                    action = plannedActions.shift();
                    if (!canExecuteAction(action)) {
                        action = null;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    aiSearchDeadline = Date.now() + getAiTimeBudget();
                    const result = minimax(board, aiMaxDepth, true, 'B', movesLeft, movedPieces, capturedPieces, scores, -Infinity, Infinity, championsOnBackRow);
                    if (result.sequence && result.sequence.length) {
                        action = result.sequence[0];
                        plannedActions = result.sequence.slice(1);
                        if (plannedActions.length > 3) {
                            plannedActions.length = 3;
                        }
                    } else {
                        action = result.action;
                        plannedActions = [];
                    }
                    if (!canExecuteAction(action)) {
                        action = null;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    plannedActions = [];
                    action = findSimpleAIAction('B', movesLeft, movedPieces);
                }

                if (!canExecuteAction(action)) {
                    action = null;
                }

                    if (aiTurnTimeoutForced) {
                        aiTurnTimeoutForced = false;
                        movesLeft = 0;
                        plannedActions = [];
                        action = null;
                    }

                    if (!action) {
                        // Special case: if AI has exactly 1 move point left, try to use it on low-value pieces
                        if (movesLeft === 1) {
                            action = findLowValuePieceMove('B', movedPieces);
                        }

                        // If still no action, end turn
                        if (!action) {
                            highlightSquares = [];
                            plannedActions = [];
                            completeAiTurn();
                            return;
                        }
                    }
                    
                    highlightSquares = [];
                    if (action.type === 'move' || action.type === 'shoot' || action.type === 'swap' || action.type === 'teleport' || action.type === 'teleportSwap' || action.type === 'activate' || action.type === 'summon') {
                        const { from, pos, cost, jump, special } = action;
                        highlightSquares = [from, pos];
                        if (action.type === 'summon' && special === 'summonSpectre') {
                            // AI attempts to summon Spectre
                            const wizardRow = from[0], wizardCol = from[1];
                            const summonRow = pos[0], summonCol = pos[1];

                            // Deduct cost before coin toss
                            movesLeft -= cost;
                            movedPieces.add(`${wizardRow},${wizardCol}`);

                            // Show automated coin toss popup for AI
                            performCoinToss(
                                'Summon Spectre',
                                'AI is attempting to summon a Spectre...',
                                (success) => {
                                    if (success) {
                                        // Successfully summoned Spectre
                                        board[summonRow][summonCol] = { type: 'Spectre', player: 'B' };
                                        spectresSummoned['B']++;
                                        wizardSummonedThisTurn['B'] = true;
                                        wizardCannotMoveNextTurn['B'].add(`${wizardRow},${wizardCol}`);

                                        // Award 3 bonus points for successful summoning
                                        scores['B'] += 3;

                                        gameLog.push(`AI summoned a Spectre at (${summonRow},${summonCol})! (+3 bonus points)`);
                                    } else {
                                        // Failed summoning
                                        gameLog.push(`AI failed to summon a Spectre.`);
                                    }

                                    renderBoard();
                                    updateGameLog();
                                    updateScoreDisplay();

                                    // Continue AI turn
                                    setTimeout(() => makeNextMove(), 500);
                                },
                                true // Automated mode
                            );
                            return; // Exit to wait for coin toss callback
                        } else if (action.type === 'summon' && special === 'summonZombie') {
                            // AI attempts to summon Zombie (Necromancer)
                            const necromancerRow = from[0], necromancerCol = from[1];
                            const summonRow = pos[0], summonCol = pos[1];

                            // Deduct cost before coin toss
                            movesLeft -= cost;
                            movedPieces.add(`${necromancerRow},${necromancerCol}`);

                            // Show automated coin toss popup for AI
                            performCoinToss(
                                'Summon Zombie',
                                'AI is attempting to summon a Zombie...',
                                (success) => {
                                    if (success) {
                                        // Successfully summoned Zombie
                                        const zombiePiece = createZombiePiece('B');
                                        board[summonRow][summonCol] = zombiePiece;
                                        zombiesSummoned['B'] = (zombiesSummoned['B'] || 0) + 1;

                                        gameLog.push(`AI summoned a Zombie at (${summonRow},${summonCol})!`);
                                    } else {
                                        // Failed summoning
                                        gameLog.push(`AI failed to summon a Zombie.`);
                                    }

                                    renderBoard();
                                    updateGameLog();
                                    updateScoreDisplay();

                                    // Continue AI turn
                                    setTimeout(() => makeNextMove(), 500);
                                },
                                true // Automated mode
                            );
                            return; // Exit to wait for coin toss callback
                        } else if (action.type === 'summon' && special === 'summonNecromancerSpectre') {
                            // AI attempts to summon Spectre (Necromancer)
                            const necromancerRow = from[0], necromancerCol = from[1];
                            const summonRow = pos[0], summonCol = pos[1];

                            // Deduct cost before coin toss
                            movesLeft -= cost;
                            movedPieces.add(`${necromancerRow},${necromancerCol}`);

                            // Show automated coin toss popup for AI
                            performCoinToss(
                                'Summon Spectre',
                                'AI is attempting to summon a Spectre...',
                                (success) => {
                                    if (success) {
                                        // Successfully summoned Spectre
                                        const spectrePiece = createSpectrePiece('B');
                                        board[summonRow][summonCol] = spectrePiece;
                                        spectresSummoned['B'] = (spectresSummoned['B'] || 0) + 1;

                                        gameLog.push(`AI summoned a Spectre at (${summonRow},${summonCol})!`);
                                    } else {
                                        // Failed summoning
                                        gameLog.push(`AI failed to summon a Spectre.`);
                                    }

                                    renderBoard();
                                    updateGameLog();
                                    updateScoreDisplay();

                                    // Continue AI turn
                                    setTimeout(() => makeNextMove(), 500);
                                },
                                true // Automated mode
                            );
                            return; // Exit to wait for coin toss callback
                        } else if (action.type === 'move') {
                            // Check if capturing a Spectre - requires coin toss
                            const targetPiece = board[pos[0]][pos[1]];
                            const attackingPiece = board[from[0]][from[1]];
                            const isCapturingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                            const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';

                            if (isCapturingSpectre && !captureExempt) {
                                // Deduct cost before coin toss
                                movesLeft -= cost;

                                // Show automated coin toss popup for AI
                                performCoinToss(
                                    'Capture Spectre',
                                    'AI is attempting to capture the Spectre...',
                                    (success) => {
                                        if (success) {
                                            movePiece(from[0], from[1], pos[0], pos[1], jump);
                                            gameLog.push(`AI successfully captured the Spectre!`);
                                        } else {
                                            gameLog.push(`AI failed to capture the Spectre.`);
                                        }

                                        if (special === 'charge') {
                                            cavalryChargeUsed['B'] = true;
                                        }
                                        if (special === 'inferno') {
                                            performInfernoCapture(pos[0], pos[1], 'B');
                                            dragonInfernoUsed['B'] = true;
                                        }
                                        if (special === 'strafe') {
                                            const piece = board[pos[0]][pos[1]];
                                            if (piece && piece.type === 'Wizard') {
                                                wizardStrafeUsed['B']++;
                                            } else if (piece && piece.type === 'Dragon') {
                                                dragonStrafeUsed['B']++;
                                            }
                                        }
                                        if (special === 'ballistaDoubleTime') {
                                            ballistaDoubleTimeUsed['B']++;
                                        }
                                        if (special === 'elephantryCharge') {
                                            const pieceKey = `${from[0]},${from[1]},B`;
                                            elephantryChargeUsed.add(pieceKey);
                                            gameLog.push(`AI used Elephantry Charge from (${from[0]},${from[1]}) to (${pos[0]},${pos[1]})`);
                                        }
                                        movedPieces.add(`${pos[0]},${pos[1]}`);

                                        renderBoard();
                                        updateGameLog();

                                        // Continue AI turn
                                        setTimeout(() => makeNextMove(), 500);
                                    },
                                    true // Automated mode
                                );
                                return; // Exit to wait for coin toss callback
                            } else {
                                // Normal move/capture
                                movePiece(from[0], from[1], pos[0], pos[1], jump);
                            }

                            if (special === 'charge') {
                                cavalryChargeUsed['B'] = true;
                            }
                            // Handle AI Inferno
                            if (special === 'inferno') {
                                performInfernoCapture(pos[0], pos[1], 'B');
                                dragonInfernoUsed['B'] = true;
                            }
                            // Handle AI Strafe
                            if (special === 'strafe') {
                                const piece = board[pos[0]][pos[1]]; // Piece is now at destination
                                if (piece && piece.type === 'Wizard') {
                                    wizardStrafeUsed['B']++;
                                } else if (piece && piece.type === 'Dragon') {
                                    dragonStrafeUsed['B']++;
                                }
                            }
                            if (special === 'ballistaDoubleTime') {
                                ballistaDoubleTimeUsed['B']++;
                            }
                            if (special === 'elephantryCharge') {
                                const pieceKey = `${from[0]},${from[1]},B`;
                                elephantryChargeUsed.add(pieceKey);
                                gameLog.push(`AI used Elephantry Charge from (${from[0]},${from[1]}) to (${pos[0]},${pos[1]})`);
                            }
                            movedPieces.add(`${pos[0]},${pos[1]}`);
                        } else if (action.type === 'shoot') {
                            // Check if shooting a Spectre - requires coin toss
                        const targetPiece = board[pos[0]][pos[1]];
                        const attackingPiece = board[from[0]][from[1]];
                        const isShootingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                        const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';
                        const autoCrackShot = special === 'fusilierCrackShotAuto';
                        const usingCrackShot = attackingPiece && attackingPiece.type === 'Fusilier' && fusilierCrackShotActive === attackingPiece;
                        const isNecromancerShot = attackingPiece && attackingPiece.type === 'Necromancer' && special === 'necromancerShoot';

                        if (isShootingSpectre && !captureExempt) {
                            // Deduct cost before coin toss
                            movesLeft -= cost;

                                // Show automated coin toss popup for AI
                                performCoinToss(
                                    'Shoot Spectre',
                                    'AI is attempting to shoot the Spectre...',
                                    (success) => {
                                        if (success) {
                                            shootPiece(from[0], from[1], pos[0], pos[1]);
                                            gameLog.push(`AI successfully shot the Spectre!`);
                                        } else {
                                            gameLog.push(`AI failed to shoot the Spectre.`);
                                        }

                                        if (special === 'archerDiag2') {
                                            archerDiag2ShootUsed['B']++;
                                        }
                                        if (isNecromancerShot) {
                                            setNecromancerShotCooldown(attackingPiece, 2);
                                        }

                                        renderBoard();
                                        updateGameLog();

                                        // Continue AI turn
                                        setTimeout(() => makeNextMove(), 500);
                                    },
                                    true // Automated mode
                                );
                                return; // Exit to wait for coin toss callback
                            } else if (autoCrackShot) {
                                movesLeft -= cost;

                                const pieceKey = `${from[0]},${from[1]},B`;
                                if (!(pieceKey in fusilierCrackShotCount)) {
                                    fusilierCrackShotCount[pieceKey] = 3;
                                }
                                if (fusilierCrackShotCount[pieceKey] > 0) {
                                    fusilierCrackShotCount[pieceKey]--;
                                }

                                performCoinToss(
                                    'Crack Shot',
                                    'AI is attempting a Crack Shot...',
                                    (success) => {
                                        fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                        fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);

                                        if (success) {
                                            shootPiece(from[0], from[1], pos[0], pos[1]);
                                            gameLog.push(`AI Fusilier Crack Shot hit!`);
                                        } else {
                                            gameLog.push(`AI Fusilier Crack Shot missed.`);
                                        }

                                        renderBoard();
                                        updateGameLog();

                                        // Continue AI turn
                                        setTimeout(() => makeNextMove(), 500);
                                    },
                                    true // Automated mode
                                );
                                return;
                            } else if (usingCrackShot) {
                                movesLeft -= cost;

                                performCoinToss(
                                    'Crack Shot',
                                    'AI is attempting a Crack Shot...',
                                    (success) => {
                                        fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                        fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);
                                        fusilierCrackShotActive = null;

                                        if (success) {
                                            shootPiece(from[0], from[1], pos[0], pos[1]);
                                            gameLog.push(`AI Fusilier Crack Shot hit!`);
                                        } else {
                                            gameLog.push(`AI Fusilier Crack Shot missed.`);
                                        }

                                        renderBoard();
                                        updateGameLog();

                                        // Continue AI turn
                                        setTimeout(() => makeNextMove(), 500);
                                    },
                                    true // Automated mode
                                );
                                return;
                            } else {
                                // Normal shoot
                                shootPiece(from[0], from[1], pos[0], pos[1]);
                            }

                            if (special === 'archerDiag2') {
                                archerDiag2ShootUsed['B']++;
                            }
                            if (isNecromancerShot) {
                                setNecromancerShotCooldown(attackingPiece, 2);
                            }
                        } else if (action.type === 'activate' && special === 'ballistaRange') {
                            // Extend range for Ballista this turn
                            ballistaRangeBoostActive['B'] = true;
                            ballistaRangeBoostUsedThisTurn['B'] = true;
                            gameLog.push(`AI activated Ballista Extend Range (+1 range this turn)`);
                        } else if (action.type === 'swap') {
                            const kingRow = from[0], kingCol = from[1];
                            const guardRow = pos[0], guardCol = pos[1];
                            const kingPiece = board[kingRow][kingCol];
                            const guardPiece = board[guardRow][guardCol];
                            board[guardRow][guardCol] = kingPiece;
                            board[kingRow][kingCol] = guardPiece;
                            kingSpecialUsed['B'] = true;
                            gameLog.push(`AI used Guard of Honour to swap King and Guard at (${kingRow},${kingCol}) and (${guardRow},${guardCol})`);
                            checkSupremacy('B');
                            movedPieces.add(`${guardRow},${guardCol}`);
                        } else if (action.type === 'teleport') {
                            const wizardRow = from[0], wizardCol = from[1];
                            const newRow = pos[0], newCol = pos[1];
                            const teleportPiece = board[wizardRow][wizardCol];
                            board[newRow][newCol] = teleportPiece;
                            board[wizardRow][wizardCol] = null;
                            if (teleportPiece.type === 'Wizard') {
                                wizardTeleportUsed['B']++;
                                gameLog.push(`AI teleported Wizard from (${wizardRow},${wizardCol}) to (${newRow},${newCol})`);
                            } else if (teleportPiece.type === 'Necromancer') {
                                incrementNecromancerTeleportCount(teleportPiece);
                                gameLog.push(`AI teleported Necromancer from (${wizardRow},${wizardCol}) to (${newRow},${newCol})`);
                            } else {
                                gameLog.push(`AI teleported ${teleportPiece.type} from (${wizardRow},${wizardCol}) to (${newRow},${newCol})`);
                            }
                            movedPieces.add(`${newRow},${newCol}`);
                        } else if (action.type === 'teleportSwap') {
                            const playerWizardRow = from[0], playerWizardCol = from[1];
                            const opponentWizardRow = pos[0], opponentWizardCol = pos[1];
                            const playerWizard = board[playerWizardRow][playerWizardCol];
                            const opponentWizard = board[opponentWizardRow][opponentWizardCol];
                            board[opponentWizardRow][opponentWizardCol] = playerWizard;
                            board[playerWizardRow][playerWizardCol] = opponentWizard;
                            wizardTeleportSwapUsed['B'] = true;
                            gameLog.push(`AI used Teleport Swap to swap Wizard at (${playerWizardRow},${playerWizardCol}) with opponent's Wizard at (${opponentWizardRow},${opponentWizardCol})`);
                            movedPieces.add(`${opponentWizardRow},${opponentWizardCol}`);
                        }
                        movesLeft -= cost;
                        movedPieces.add(`${from[0]},${from[1]}`);
                    } else if (action.type === 'turn') {
                        const { pos, facing, cost } = action;
                        highlightSquares = [pos];
                        turnPiece(pos[0], pos[1], facing);
                        movesLeft -= cost;
                        movedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (action.type === 'turnAndMove') {
                        const { pos, facing, move, cost, jump } = action;
                        highlightSquares = [pos, move];
                        turnPiece(pos[0], pos[1], facing);
                        movePiece(pos[0], pos[1], move[0], move[1], jump);
                        movesLeft -= cost;
                        movedPieces.add(`${pos[0]},${pos[1]}`);
                        movedPieces.add(`${move[0]},${move[1]}`);
                    } else if (action.type === 'turnAndShoot') {
                        const { pos, facing, shoot, cost } = action;
                        highlightSquares = [pos, shoot];
                        turnPiece(pos[0], pos[1], facing);
                        shootPiece(pos[0], pos[1], shoot[0], shoot[1]);
                        movesLeft -= cost;
                        movedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (action.type === 'archerMoveDiagShoot') {
                        const { from, move, shoot, cost } = action;
                        highlightSquares = [from, move, shoot];
                        movePiece(from[0], from[1], move[0], move[1]);
                        shootPiece(move[0], move[1], shoot[0], shoot[1]);
                        archerMoveDiagShootUsed['B']++;
                        movesLeft -= cost;
                        movedPieces.add(`${move[0]},${move[1]}`);
                    }
                    
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    
                    // Shorter delays for faster AI play
                    setTimeout(() => {
                        try {
                            highlightSquares = [];
                            renderBoard();
                            setTimeout(() => {
                                try {
                                    makeNextMove();
                                } catch (err) {
                                    console.error('AI move loop failed:', err);
                                    completeAiTurn({ reason: 'AI move error. Player resumes turn.' });
                                }
                            }, 1000); // Make next move
                        } catch (err) {
                            console.error('AI post-move cleanup failed:', err);
                            completeAiTurn({ reason: 'AI move error. Player resumes turn.' });
                        }
                    }, 800); // Highlight duration
                } catch (err) {
                    console.error('AI move evaluation failed:', err);
                    completeAiTurn({ reason: 'AI move error. Player resumes turn.' });
                }
            }
            setTimeout(() => makeNextMove(), 800); // Start after brief delay for player to see board state
        }

        function resetGame() {
            // Initialize all game state variables first
            currentPlayer = 'W'; // Will be set by coin toss
            turnCount = 0; // Reset turn counter
            playerTurnNumber = 0; // Reset player turn counter
            selectedPiece = null;
            validMoves = [];
            movedPieces.clear();
            reinforcementPending = null;
            aiPending = false;
            stopGameTimer();
            stopTurnTimer();
            aiTurnTimeoutForced = false;
            movesLeft = 0;
            initialMovesLeft = 0;
            capturedPieces = { 'W': [], 'B': [] };
            championCaptured = { 'W': false, 'B': false };
            championsOnBackRow = { 'W': [], 'B': [] };
            scores = { 'W': 0, 'B': 0 };
            firstMoves.clear();
            gameLog = [];
            isFirstPlayerTurn = true;
            lastAction = null;
            turnAndShootMode = false;
            turnAndMoveMode = false;
            guardOfHonourMode = false;
            teleportMode = false;
            teleportSwapMode = false;
            chargeMode = false;
            infernoMode = false;
            strafeMode = false;
            summonSpectreMode = false;
            archerMoveDiagMode = false;
            archerDiagShootSelectMode = false;
            archerDiag2ShootMode = false;
            elephantryChargeMode = false;
            elephantryExtendedRangeActive = false;
            fusilierCrackShotActive = null;
            elephantryMoveShootMode = false;
            elephantryMoveShootPosition = null;
            pistolierMoveShootMode = false;
            pistolierMoveShootPosition = null;
            archerMoveDiagStart = null;
            highlightSquares = [];
            kingSpecialUsed = { 'W': false, 'B': false };
            wizardTeleportUsed = { 'W': 0, 'B': 0 };
            wizardTeleportSwapUsed = { 'W': false, 'B': false };
            cavalryChargeUsed = { 'W': false, 'B': false };
            dragonInfernoUsed = { 'W': false, 'B': false };
            wizardStrafeUsed = { 'W': 0, 'B': 0 };
            dragonStrafeUsed = { 'W': 0, 'B': 0 };
            fusilierShotLastTurn = { 'W': new Set(), 'B': new Set() };
            fusilierShotThisTurn = { 'W': new Set(), 'B': new Set() };
            spectresSummoned = { 'W': 0, 'B': 0 };
            wizardSummonedThisTurn = { 'W': false, 'B': false };
            wizardCannotMoveNextTurn = { 'W': new Set(), 'B': new Set() };
            necromancersSummoned = { 'W': 0, 'B': 0 };
            necromancerTeleportCounts = new Map();
            necromancerShootCooldown = new Map();
            zombiesSummoned = { 'W': 0, 'B': 0 };
            zombiePendingAdvanceQueue = [];
            zombieAutoAdvanceInProgress = false;
            clearZombieCoinAnimations();
            if (zombieAdvanceTimer) {
                clearTimeout(zombieAdvanceTimer);
                zombieAdvanceTimer = null;
            }
            championSummonSource = null;
            closeChampionSummonModal();
            necromancerSummonContext = null;
            necromancerSummonType = null;
            closeNecromancerSummonModal();
            zombieConversions = { 'W': 0, 'B': 0 };
            archerMoveDiagShootUsed = { 'W': 0, 'B': 0 };
            archerDiag2ShootUsed = { 'W': 0, 'B': 0 };
            ballistaRangeBoostActive = { 'W': false, 'B': false };
            ballistaRangeBoostUsedThisTurn = { 'W': false, 'B': false };
            ballistaDoubleTimeUsed = { 'W': 0, 'B': 0 };
            elephantryChargeUsed = new Set();
            elephantryExtendedRangeShotsRemaining = {};
            capturedSquares = [];
            turnScoreGain = { 'W': 0, 'B': 0 };
            turnLosses = { 'W': {}, 'B': {} };
            nextTurnModifier = { 'W': 0, 'B': 0 };
            reinforcementTotals = { 'W': 0, 'B': 0 };
            infantryReinforcements = { 'W': 0, 'B': 0 };
            truceAttempts = 0;
            truceDeclinedTurns = 0;
            truceEligible = true;
            trucePlayerVote = null;
            truceAIVote = null;
            gameTimeRemaining = GAME_TIME_OPTIONS[selectedGameTimerKey];
            playerTurnTimeRemaining = TURN_TIME_OPTIONS[selectedTurnTimerKey];
            aiTurnTimeRemaining = TURN_TIME_OPTIONS[selectedTurnTimerKey];
            updateTimerDisplay();

            initBoard();
            showPieceInfo(null);
            const reinforceModal = document.getElementById('reinforce-modal');
            if (reinforceModal) reinforceModal.style.display = 'none';
            const turnModal = document.getElementById('turn-modal');
            if (turnModal) turnModal.style.display = 'none';
            const turnMoveModal = document.getElementById('turn-move-modal');
            if (turnMoveModal) turnMoveModal.style.display = 'none';
            const turnShootModal = document.getElementById('turn-shoot-modal');
            if (turnShootModal) turnShootModal.style.display = 'none';

            // Perform coin toss to determine starting player
            performCoinToss(
                'First Turn',
                'Determining who goes first...',
                (playerWins) => {
                    if (playerWins) {
                        // Player (white) goes first
                        currentPlayer = 'W';
                        gameLog.push('Player won the coin toss and goes first!');

                        const baseMoves = calculateBaseMoves('W');
                        movesLeft = baseMoves;
                        initialMovesLeft = baseMoves;

                        // Render board and update UI after coin toss
                        renderBoard();
                        updateScoreDisplay();
                        updateStatus();
                        updateGameLog();
                        updateCapturedPiecesDisplay();
                        updateEndTurnButton();

                        // Start timer after everything is set up
                        startGameTimer();
                        const startReady = applyStartTurnModifiers('W', baseMoves);

                        if (!startReady) {
                            checkGameOver();
                            setTimeout(() => triggerAiTurn(), 0);
                        }
                    } else {
                        // AI (black) goes first
                        currentPlayer = 'B';
                        gameLog.push(`${getOpponentDisplayName()} won the coin toss and goes first!`);

                        const baseMoves = calculateBaseMoves('B');
                        movesLeft = baseMoves;
                        initialMovesLeft = baseMoves;

                        // Render board and update UI after coin toss
                        renderBoard();
                        updateScoreDisplay();
                        updateStatus();
                        updateGameLog();
                        updateCapturedPiecesDisplay();
                        updateEndTurnButton();

                        // Start timer after everything is set up
                        startGameTimer();

                        // Trigger AI turn after a brief delay
                        setTimeout(() => {
                            aiTurn();
                        }, 1000);
                    }
                }
            );
        }

        function updateStatus() {
            document.getElementById('status').textContent = `${currentPlayer === 'W' ? "Player" : "AI"}'s turn: ${movesLeft} moves remaining`;
            // Explicitly check if turn should end after status update
            if (!gamePaused && currentPlayer === 'W' && movesLeft <= 0 && !reinforcementPending && !aiPending) {
                setTimeout(() => triggerAiTurn(), 0);
            }
        }

        function endGame(winner, reason = '') {
            stopGameTimer();
            stopTurnTimer();
            playerTurnTimeRemaining = 0;
            aiTurnTimeRemaining = 0;
            updateTimerDisplay();
            const scoreSummary = `Final Score - Player: ${scores['W']}, AI: ${scores['B']}`;
            let message;
            if (winner === 'draw') {
                message = `Draw! ${reason ? reason + ' ' : ''}${scoreSummary}`;
            } else {
                const winnerLabel = winner === 'W' ? 'Player' : 'AI';
                message = `${winnerLabel} wins! ${reason ? reason + ' ' : ''}${scoreSummary}`;
            }
            gameLog.push(message);
            alert(message);
            updateGameLog();
            document.getElementById('start-menu').style.display = 'flex';
            document.getElementById('game-container').style.display = 'none';
            const landingHeader = document.getElementById('landing-header');
            if (landingHeader) landingHeader.style.display = 'block';
            const landingFooter = document.getElementById('landing-footer');
            if (landingFooter) landingFooter.style.display = 'block';
            resetVariantSelections();
        }

        function checkGameOver() {
            // First check for Match (only kings remaining)
            if (checkForMatch()) return;

            let wKing = false, bKing = false;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] && board[r][c].type === 'King') {
                        if (board[r][c].player === 'W') wKing = true;
                        else bKing = true;
                    }
                }
            }
            if (!wKing) endGame('B');
            else if (!bKing) endGame('W');
        }

        function updateEndTurnButton() {
            const endTurnButton = document.getElementById('end-turn-button');
            endTurnButton.disabled = currentPlayer !== 'W' || movesLeft >= initialMovesLeft;
            // Update hint button visibility
            updateHintButton();
            // Safety net
            ensureAITurnIfNeeded();
        }

        function updateHintButton() {
            const hintButton = document.getElementById('hint-button');
            if (hintButton) {
                // Show hint button only if hint mode is enabled and it's the player's turn
                if (hintModeEnabled && currentPlayer === 'W' && movesLeft > 0) {
                    hintButton.style.display = 'inline-block';
                } else {
                    hintButton.style.display = 'none';
                }
            }
        }

        function showHint() {
            if (!hintModeEnabled || currentPlayer !== 'W') return;

            // Use simplified AI logic to find a good move
            const action = findSimpleAIAction('W');

            if (!action) {
                alert('No valid moves available.');
                return;
            }

            // Clear any existing highlights
            document.querySelectorAll('.hint-highlight').forEach(cell => {
                cell.classList.remove('hint-highlight');
            });

            // Highlight the suggested move
            const piece = board[action.fromRow][action.fromCol];
            const fromCell = document.querySelector(`[data-row="${action.fromRow}"][data-col="${action.fromCol}"]`);
            const toCell = document.querySelector(`[data-row="${action.toRow}"][data-col="${action.toCol}"]`);

            if (fromCell) {
                fromCell.classList.add('hint-highlight');
            }
            if (toCell) {
                toCell.classList.add('hint-highlight');
            }

            // Create hint message
            let hintMessage = `Suggestion: Move ${piece.type} from (${action.fromRow}, ${action.fromCol}) to (${action.toRow}, ${action.toCol})`;

            if (action.turnDirection) {
                hintMessage += ` and turn ${action.turnDirection}`;
            }
            if (action.shoot) {
                hintMessage += ` and shoot`;
            }
            if (action.specialAbility) {
                hintMessage += ` using ${action.specialAbility}`;
            }

            // Show hint in status
            const statusDiv = document.getElementById('status');
            const originalStatus = statusDiv.textContent;
            statusDiv.textContent = hintMessage;
            statusDiv.style.backgroundColor = '#ffffcc';
            statusDiv.style.padding = '10px';
            statusDiv.style.borderRadius = '5px';

            // Reset after 5 seconds
            setTimeout(() => {
                statusDiv.textContent = originalStatus;
                statusDiv.style.backgroundColor = '';
                statusDiv.style.padding = '';
                statusDiv.style.borderRadius = '';
                document.querySelectorAll('.hint-highlight').forEach(cell => {
                    cell.classList.remove('hint-highlight');
                });
            }, 5000);
        }

        function endTurn() {
            if (movesLeft < initialMovesLeft) {
                // Reset player's per-turn Ballista boost on end turn
                ballistaRangeBoostActive['W'] = false;
                ballistaRangeBoostUsedThisTurn['W'] = false;
                // Force turn transition
                movesLeft = 0;
                triggerAiTurn();
            }
        }

        function updateCapturedPiecesDisplay() {
            const playerCapturedDiv = document.getElementById('player-captured');
            const aiCapturedDiv = document.getElementById('ai-captured');
            playerCapturedDiv.innerHTML = getCapturedPiecesHTML('W');
            aiCapturedDiv.innerHTML = getCapturedPiecesHTML('B');
        }

        function getCapturedPiecesHTML(player) {
            const pieces = capturedPieces[player];
            const counts = {};
            pieces.forEach(p => {
                counts[p.type] = (counts[p.type] || 0) + 1;
            });
            return Object.entries(counts).map(([type, count]) => `<span class="piece ${player === 'W' ? 'white' : 'black'}" style="color: ${player === 'W' ? 'black' : 'white'}">${pieceIcons[type]}</span> x${count}`).join('<br>');
        }

        // New function to add capture effects
        function addCaptureEffect(row, col) {
            const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
            const body = document.body;
            if (square) {
                // Add square background color change
                square.classList.add('capture-background');
                // Add square overlay
                const overlay = document.createElement('div');
                overlay.className = 'capture-overlay';
                square.appendChild(overlay);
                // Add game background color change only if not already applied
                if (!body.classList.contains('capture-game-background')) {
                    body.classList.add('capture-game-background');
                    // Remove game background after 2 seconds
                    setTimeout(() => {
                        body.classList.remove('capture-game-background');
                    }, 2000);
                }
                // Remove square effects after 2 seconds
                setTimeout(() => {
                    square.classList.remove('capture-background');
                    if (square.contains(overlay)) {
                        square.removeChild(overlay);
                    }
                }, 1780);
            }
        }

        document.addEventListener('click', (event) => {
            if (!event.target.closest('.variant-option')) {
                resetVariantSelections();
            }
            const howToModal = document.getElementById('how-to-play-modal');
            if (howToModal && howToModal.style.display === 'block') {
                const clickedInsideModal = event.target.closest('#how-to-play-modal');
                const clickedHowToButton = event.target.closest('.how-to-button');
                if (!clickedInsideModal && !clickedHowToButton) {
                    closeHowToPlay();
                }
            }
        });

        resetVariantSelections();
    </script>
</body>
</html>
